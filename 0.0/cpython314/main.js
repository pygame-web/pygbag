// include: shell.js
// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(moduleArg) => Promise<Module>
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module != 'undefined' ? Module : {};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

var ENVIRONMENT_IS_WEB = true;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
// include: /tmp/tmpaib0rxle.js

  Module['expectedDataFileDownloads'] ??= 0;
  Module['expectedDataFileDownloads']++;
  (() => {
    // Do not attempt to redownload the virtual filesystem data when in a pthread or a Wasm Worker context.
    var isPthread = typeof ENVIRONMENT_IS_PTHREAD != 'undefined' && ENVIRONMENT_IS_PTHREAD;
    var isWasmWorker = typeof ENVIRONMENT_IS_WASM_WORKER != 'undefined' && ENVIRONMENT_IS_WASM_WORKER;
    if (isPthread || isWasmWorker) return;
    function loadPackage(metadata) {

      var PACKAGE_PATH = '';
      if (typeof window === 'object') {
        PACKAGE_PATH = window['encodeURIComponent'](window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/')) + '/');
      } else if (typeof process === 'undefined' && typeof location !== 'undefined') {
        // web worker
        PACKAGE_PATH = encodeURIComponent(location.pathname.substring(0, location.pathname.lastIndexOf('/')) + '/');
      }
      var PACKAGE_NAME = '/home/runner/work/pygbag/pygbag/build/web/archives/0.0/cpython314/main.data';
      var REMOTE_PACKAGE_BASE = 'main.data';
      var REMOTE_PACKAGE_NAME = Module['locateFile'] ? Module['locateFile'](REMOTE_PACKAGE_BASE, '') : REMOTE_PACKAGE_BASE;
var REMOTE_PACKAGE_SIZE = metadata['remote_package_size'];

      function fetchRemotePackage(packageName, packageSize, callback, errback) {
        
        Module['dataFileDownloads'] ??= {};
        fetch(packageName)
          .catch((cause) => Promise.reject(new Error(`Network Error: ${packageName}`, {cause}))) // If fetch fails, rewrite the error to include the failing URL & the cause.
          .then((response) => {
            if (!response.ok) {
              return Promise.reject(new Error(`${response.status}: ${response.url}`));
            }

            if (!response.body && response.arrayBuffer) { // If we're using the polyfill, readers won't be available...
              return response.arrayBuffer().then(callback);
            }

            const reader = response.body.getReader();
            const iterate = () => reader.read().then(handleChunk).catch((cause) => {
              return Promise.reject(new Error(`Unexpected error while handling : ${response.url} ${cause}`, {cause}));
            });

            const chunks = [];
            const headers = response.headers;
            const total = Number(headers.get('Content-Length') ?? packageSize);
            let loaded = 0;

            const handleChunk = ({done, value}) => {
              if (!done) {
                chunks.push(value);
                loaded += value.length;
                Module['dataFileDownloads'][packageName] = {loaded, total};

                let totalLoaded = 0;
                let totalSize = 0;

                for (const download of Object.values(Module['dataFileDownloads'])) {
                  totalLoaded += download.loaded;
                  totalSize += download.total;
                }

                Module['setStatus']?.(`Downloading data... (${totalLoaded}/${totalSize})`);
                return iterate();
              } else {
                const packageData = new Uint8Array(chunks.map((c) => c.length).reduce((a, b) => a + b, 0));
                let offset = 0;
                for (const chunk of chunks) {
                  packageData.set(chunk, offset);
                  offset += chunk.length;
                }
                callback(packageData.buffer);
              }
            };

            Module['setStatus']?.('Downloading data...');
            return iterate();
          });
      };

      function handleError(error) {
        console.error('package error:', error);
      };

      var fetchedCallback = null;
      var fetched = Module['getPreloadedPackage'] ? Module['getPreloadedPackage'](REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE) : null;

      if (!fetched) fetchRemotePackage(REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE, (data) => {
        if (fetchedCallback) {
          fetchedCallback(data);
          fetchedCallback = null;
        } else {
          fetched = data;
        }
      }, handleError);

    function runWithFS(Module) {

      function assert(check, msg) {
        if (!check) throw msg + new Error().stack;
      }
Module['FS_createPath']("/", "data", true, true);
Module['FS_createPath']("/data", "data", true, true);
Module['FS_createPath']("/data/data", "org.python", true, true);
Module['FS_createPath']("/data/data/org.python", "assets", true, true);
Module['FS_createPath']("/data/data/org.python/assets", "site-packages", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages", "_xterm_parser", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages", "aio", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages", "installer", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages/installer", "_scripts", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages", "packaging", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages/packaging", "licenses", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages", "pkg_resources", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages/pkg_resources", "tests", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages/pkg_resources/tests", "data", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages/pkg_resources/tests/data", "my-test-package-source", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages/pkg_resources/tests/data", "my-test-package-zip", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages/pkg_resources/tests/data", "my-test-package_unpacked-egg", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages/pkg_resources/tests/data/my-test-package_unpacked-egg", "my_test_package-1.0-py3.7.egg", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages/pkg_resources/tests/data/my-test-package_unpacked-egg/my_test_package-1.0-py3.7.egg", "EGG-INFO", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages/pkg_resources/tests/data", "my-test-package_zipped-egg", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages", "platform_wasm", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages/platform_wasm", "matplotlib", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages/platform_wasm", "pygame", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages", "pygame", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages/pygame", "__briefcase", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages/pygame", "__pyinstaller", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages/pygame", "_sdl2", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages", "pyparsing", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages/pyparsing", "diagram", true, true);
Module['FS_createPath']("/data/data/org.python/assets/site-packages", "tomllib", true, true);
Module['FS_createPath']("/", "usr", true, true);
Module['FS_createPath']("/usr", "lib", true, true);
Module['FS_createPath']("/usr/lib", "python3.14", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "_pyrepl", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "asyncio", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "collections", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "concurrent", true, true);
Module['FS_createPath']("/usr/lib/python3.14/concurrent", "futures", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "ctypes", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "curses", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "email", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "encodings", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "html", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "http", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "importlib", true, true);
Module['FS_createPath']("/usr/lib/python3.14/importlib", "metadata", true, true);
Module['FS_createPath']("/usr/lib/python3.14/importlib", "resources", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "json", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "lib-dynload", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "logging", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "multiprocessing", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "pathlib", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "re", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "sqlite3", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "sysconfig", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "tomllib", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "unittest", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "urllib", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "xml", true, true);
Module['FS_createPath']("/usr/lib/python3.14/xml", "dom", true, true);
Module['FS_createPath']("/usr/lib/python3.14/xml", "etree", true, true);
Module['FS_createPath']("/usr/lib/python3.14/xml", "parsers", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "zipfile", true, true);
Module['FS_createPath']("/usr/lib/python3.14/zipfile", "_path", true, true);
Module['FS_createPath']("/usr/lib/python3.14", "zoneinfo", true, true);

      function processPackageData(arrayBuffer) {
        assert(arrayBuffer, 'Loading data file failed.');
        assert(arrayBuffer.constructor.name === ArrayBuffer.name, 'bad input to processPackageData');
        var byteArray = new Uint8Array(arrayBuffer);
        var curr;
        var compressedData = {"data":null,"cachedOffset":4385278,"cachedIndexes":[-1,-1],"cachedChunks":[null,null],"offsets":[0,2000,3894,5779,7551,9338,11012,12701,14531,16300,18098,19901,21650,23457,25227,27031,28761,30489,32250,34005,35584,36848,38010,39420,40475,41492,42486,43634,44962,46260,47405,48743,49962,51282,52508,53907,55325,56555,57582,58788,59684,60511,61497,62467,63312,64678,65963,67235,68371,69569,70741,71829,72640,73471,74505,75298,75959,77121,78222,79129,80372,81747,82879,84041,85146,85967,87215,88462,89421,90624,91510,92392,93217,94497,95593,96725,97544,98619,99692,100523,101406,102470,103537,104466,105505,106410,107427,108406,109439,110245,111483,112355,113449,114784,116094,117294,118417,119581,120799,122212,123258,124489,125778,127040,128179,129540,130521,131886,132967,134209,135335,136385,137628,138753,140022,141102,142113,143540,144788,146105,147320,148373,149585,150738,151966,153267,154480,155654,156577,157604,158648,159814,161148,162460,163562,164897,166160,167401,168541,169769,171182,172442,173629,175002,176343,177672,179107,180336,181596,182754,183751,185055,186437,187682,189035,190523,191955,193230,194493,195940,197204,198410,199692,201163,202174,203086,204020,204925,206044,207055,208324,209449,210968,212123,213161,213804,214433,215008,215667,216127,216691,217380,218044,218522,219132,219730,220407,221013,221688,222349,222922,223563,224213,224879,225556,226192,226815,227506,228555,229674,230900,232107,233294,234564,235825,237027,238515,239849,241318,242667,243931,245235,246588,247723,248815,249641,250761,251777,252842,253472,254580,255734,256986,258291,259194,260227,261466,262460,263705,264637,265481,266534,267682,268745,270017,271292,272283,273129,274051,275289,276295,277556,278864,280228,281476,282672,283809,284909,285895,287093,288393,289617,290849,291950,293223,294114,295396,296412,297236,298004,299085,300466,301873,303234,304594,306008,307253,308410,309710,310879,311978,313048,314295,315476,316724,317670,318849,319623,320904,322078,323211,324351,325463,326505,327604,328619,330017,331398,332756,333895,334982,336007,337000,338340,339677,340981,342225,343277,344402,345618,346824,348088,349423,350653,351926,353230,354473,355569,356820,358025,359019,360214,361373,362626,363810,364917,366006,367366,368612,369908,371330,372754,374147,375295,376229,377607,378741,380045,381254,381975,382971,384158,385297,386552,387499,388691,390083,391408,392802,394106,395134,396272,397294,398290,399266,399899,400870,401946,403070,404036,404866,405749,406549,407675,408770,410014,411178,411958,412454,413319,414514,415714,416883,417887,418876,420197,421465,422641,423601,424775,425662,426524,427710,429030,429929,431535,432902,433942,434769,435762,437167,438579,439487,440850,442151,442949,444133,445127,446211,447647,448595,449529,450455,451273,452117,452933,453826,454696,455662,456580,457544,458579,460029,461164,462238,463504,464580,465078,465600,466356,466944,467999,469264,470644,472553,474408,476309,478095,479951,481865,483598,485521,487522,489454,491289,493048,494843,496630,498324,500156,501912,503810,505720,507654,509421,511359,513234,515049,516957,518772,520429,522360,524021,525806,527400,528548,529754,531683,533527,535397,536873,538775,540398,542114,543905,545712,547519,549317,551223,552984,554275,555383,556625,557816,558809,559911,561392,562807,564025,565444,566857,568087,569197,570455,571747,572984,574172,575175,576494,577714,579064,580401,582147,583456,585292,586995,588515,590563,592611,594659,596707,598755,600803,602851,604899,606947,608995,611043,613091,615139,617187,619235,621283,623331,625379,627427,629475,631523,633571,635619,636687,637331,637793,638363,639069,640133,641164,642221,643478,644831,646104,647392,648332,649036,649675,650387,651220,652059,652686,653306,654136,655109,655945,656710,657342,657906,658516,659179,659995,660950,661679,662070,662578,663422,664838,665846,666874,667781,669097,670281,671637,673065,675089,677135,679183,681231,683279,685327,687375,689423,691471,693492,695540,697588,699636,701693,703741,705789,707837,709885,711933,713981,716029,718077,720125,722173,724221,726269,728317,730365,732366,734414,736148,738196,740244,742292,744340,746388,748436,750484,752532,754580,756628,758676,760724,762772,764820,766868,768916,770964,773012,775060,777108,779156,781204,783252,785300,787348,789396,791444,793492,795540,797588,799636,801684,803732,805780,807828,809876,811924,813972,816020,818068,820116,822164,824212,826260,828308,830273,832207,834155,836203,838260,840308,842356,844404,846452,848500,850548,852596,854644,856692,858740,860788,862836,864884,866932,868980,871028,873076,875124,877172,879220,881268,883316,885364,887412,889460,891508,893556,895604,897652,899700,901748,903796,905844,907892,909940,911988,914036,916084,918132,920180,922228,924276,926324,928104,929921,931969,934015,936063,936481,936506,936531,936556,936581,936606,936631,936671,936729,936868,937219,937652,938240,938983,939682,940474,941323,942157,942936,943674,944401,945185,945960,946790,947573,948400,949246,950054,950813,951750,952661,953514,954344,955102,955765,956508,957325,958202,959016,959857,960741,961641,962388,963189,964057,964965,965927,966801,967574,968310,969011,969778,970530,971229,971950,972678,973436,974261,975083,975856,976642,977386,978130,978906,979652,980329,980967,981611,982150,982656,983285,983943,984563,985190,985932,986746,987545,988263,988945,989674,990391,991126,991804,992508,993164,993831,994497,995168,995882,996597,997307,998045,998769,999524,1000331,1001158,1002030,1002931,1003825,1004784,1005754,1006679,1007608,1008554,1009569,1010476,1011377,1012242,1012981,1013623,1014190,1014679,1015071,1015371,1015683,1016160,1016339,1016402,1016449,1016474,1016499,1016524,1016549,1016574,1016599,1016624,1016649,1016674,1017914,1018940,1020392,1021929,1023247,1024290,1025545,1026760,1028150,1029312,1030210,1031233,1032334,1033330,1034547,1035721,1036738,1037896,1038840,1040117,1041253,1042428,1043483,1044340,1045398,1046566,1047825,1048992,1050388,1051467,1052620,1053810,1055244,1056594,1057788,1058879,1059817,1060633,1061851,1063072,1064424,1065569,1066882,1068068,1069015,1070273,1071551,1072777,1074099,1075582,1077076,1078568,1079911,1081009,1082064,1083355,1084695,1085932,1087196,1087831,1088757,1089950,1090934,1092284,1093414,1094901,1096325,1097425,1098630,1099994,1101285,1102445,1103564,1104903,1106143,1107355,1108779,1109912,1111113,1112284,1112994,1113658,1114784,1115819,1116960,1118296,1119573,1120983,1122253,1123125,1124427,1125558,1126826,1127619,1128639,1129298,1130191,1131408,1132439,1133426,1134656,1135795,1136996,1138139,1139366,1140449,1141625,1142669,1143910,1144895,1145993,1147079,1148399,1149254,1150452,1151644,1152818,1154151,1155170,1156095,1157172,1158434,1159749,1160912,1162105,1163137,1164068,1165144,1166192,1167506,1168725,1169872,1170966,1171904,1173031,1174160,1175056,1175974,1177250,1178303,1179346,1180507,1181663,1182830,1184040,1185166,1186450,1187484,1188392,1189587,1190490,1191645,1192837,1194080,1195394,1196594,1198044,1199144,1200338,1201616,1202810,1204070,1205458,1206551,1207594,1208971,1209994,1211324,1212257,1213348,1214604,1215798,1217137,1218259,1219509,1220826,1222103,1223210,1224536,1225892,1227287,1228572,1229923,1231207,1232330,1233485,1234784,1236022,1237021,1237734,1238879,1240190,1241496,1242459,1243745,1245092,1246468,1247756,1249186,1250564,1251866,1253168,1254538,1255843,1257074,1257919,1259034,1260414,1261757,1262940,1264058,1264939,1266264,1267241,1268570,1269752,1270925,1272043,1272984,1274170,1275305,1276313,1277369,1278517,1279677,1280885,1281790,1283043,1284370,1285145,1286174,1287280,1288141,1289248,1290318,1291484,1292637,1293567,1294363,1295173,1296313,1297358,1298320,1299588,1300891,1302156,1303237,1304523,1305773,1306950,1308151,1309237,1310476,1311416,1312552,1313629,1314640,1315959,1317308,1318605,1319843,1321008,1322254,1323434,1324518,1325579,1326783,1328198,1329150,1330267,1331170,1332304,1333491,1334472,1335713,1336902,1337945,1339259,1340429,1341614,1342697,1343882,1345039,1346146,1347418,1348469,1349590,1350983,1352323,1353568,1354598,1355345,1356822,1357963,1359170,1360373,1361319,1362553,1363793,1364926,1366089,1367282,1368071,1369368,1370639,1371889,1372917,1374060,1375356,1376576,1378021,1379000,1380254,1381384,1382277,1383433,1384333,1385461,1386558,1387890,1389312,1390536,1391677,1392691,1393605,1394358,1395483,1396258,1397069,1398178,1399394,1400719,1401801,1403028,1404468,1405700,1406872,1408095,1409176,1410103,1411210,1412301,1413648,1414945,1416143,1416957,1418048,1419019,1420316,1421307,1422418,1423191,1424160,1424993,1425746,1426548,1427404,1428236,1428960,1429781,1430444,1431543,1432819,1433751,1434484,1435257,1435767,1436303,1436989,1437602,1438206,1439304,1440069,1440810,1441859,1442805,1444052,1444895,1446182,1447252,1448369,1449536,1450561,1451465,1452431,1453321,1454623,1455910,1457042,1458402,1459730,1460831,1462083,1463484,1464739,1466040,1467123,1468120,1469191,1470020,1471092,1472193,1473259,1474208,1475277,1476179,1477294,1478468,1479326,1480194,1480947,1481651,1482463,1483528,1484673,1485807,1486819,1487937,1489007,1490070,1491144,1492219,1493211,1494244,1495577,1496625,1497754,1498760,1499815,1500870,1501923,1502709,1503764,1504731,1505757,1506826,1507881,1508856,1509735,1510757,1511946,1512939,1513969,1515144,1516556,1517483,1518692,1519727,1520815,1522011,1523294,1524648,1525787,1527124,1528148,1529434,1530581,1531795,1532665,1533331,1534164,1534988,1535693,1536873,1537932,1539000,1539803,1540808,1541641,1542702,1543618,1544401,1545253,1546309,1547463,1548848,1550068,1551344,1552317,1553361,1554444,1555790,1556956,1557798,1558985,1560129,1561372,1562556,1563627,1564662,1565709,1566753,1567805,1568983,1570044,1570957,1572048,1573250,1574341,1575437,1576521,1577447,1578392,1579521,1580497,1581556,1582423,1583351,1584424,1585502,1586595,1587601,1588637,1589759,1590982,1592017,1593162,1594012,1595080,1596185,1597404,1598805,1599941,1601172,1602203,1603213,1604216,1605290,1606292,1607616,1608658,1609910,1610842,1611541,1612614,1613759,1614784,1615926,1617147,1618426,1619837,1620959,1622061,1623188,1624350,1625338,1626529,1627790,1629025,1630258,1631555,1632842,1634213,1635491,1636817,1637926,1638975,1640201,1641590,1642978,1644267,1645429,1646532,1647551,1648763,1650027,1651239,1652379,1653756,1655148,1656276,1657312,1658522,1659774,1660823,1661836,1662806,1663642,1664646,1665623,1666667,1667610,1668642,1669611,1670825,1672196,1673432,1674806,1676073,1677108,1678207,1679216,1680151,1681317,1682441,1683514,1684718,1685951,1687220,1688402,1689647,1690826,1691661,1692680,1693625,1694712,1695826,1696794,1697836,1699071,1700292,1701642,1702791,1704091,1705268,1706382,1707282,1708485,1709823,1710990,1712125,1713393,1714790,1716112,1717361,1718547,1719969,1721197,1722382,1723526,1724729,1725836,1727010,1728086,1729273,1730491,1731498,1732351,1733501,1734648,1735833,1736920,1737929,1738867,1739999,1741143,1742300,1743291,1744446,1745480,1746661,1747813,1748850,1749885,1751155,1752367,1753521,1754769,1755945,1756983,1758188,1759142,1759986,1760986,1762014,1763116,1764265,1765424,1766610,1767616,1768716,1769750,1770974,1772096,1773226,1774386,1775449,1776484,1777788,1778942,1780196,1781310,1782509,1783531,1784733,1786113,1787121,1788598,1789935,1791197,1792601,1793962,1795238,1796594,1797787,1798931,1800213,1801508,1802590,1803624,1804751,1806023,1807392,1808643,1809852,1810985,1811903,1812688,1813755,1814727,1815793,1816721,1817869,1819067,1820057,1820937,1822367,1823534,1824733,1826004,1826998,1828405,1829827,1831160,1832426,1833778,1834936,1836087,1837178,1838306,1839281,1840530,1841793,1843120,1844325,1845641,1847029,1848176,1849461,1850090,1850747,1851590,1852887,1854053,1855067,1856046,1856683,1857556,1858260,1859066,1859801,1861230,1862222,1863576,1864917,1865780,1867016,1868131,1869115,1870243,1871163,1872311,1873048,1874058,1875293,1876069,1877348,1878537,1879731,1880701,1881733,1882529,1883711,1884791,1886034,1887409,1888515,1889732,1890914,1891967,1893198,1894521,1895720,1896995,1897888,1898888,1900034,1901226,1902316,1903259,1904522,1905573,1906548,1907733,1908890,1909916,1910974,1912058,1913114,1914287,1915469,1916474,1917628,1918857,1919984,1921229,1922505,1923508,1924785,1925832,1927012,1928020,1929065,1930352,1931579,1932919,1934060,1935261,1936515,1937582,1939061,1940313,1941478,1942700,1944009,1945106,1946462,1947645,1949089,1950253,1951320,1952471,1953684,1954698,1956011,1957077,1958358,1959558,1960653,1961790,1962739,1963781,1965159,1966336,1967576,1968707,1969781,1970961,1972170,1973502,1974749,1975727,1976738,1977781,1978801,1980094,1981551,1982549,1983383,1984780,1986186,1987277,1988345,1989646,1990842,1992155,1993315,1994648,1995904,1997000,1998338,1999742,2001010,2002130,2003253,2004606,2005822,2007142,2008227,2009524,2010929,2012252,2013567,2014838,2016077,2017277,2018469,2019794,2021183,2022564,2024032,2025471,2026823,2028019,2029434,2030753,2032090,2033335,2034674,2035882,2037147,2038412,2039501,2040852,2042210,2043380,2044617,2045970,2046982,2048279,2049586,2050880,2052223,2053439,2054595,2056028,2057314,2058568,2059835,2060528,2061755,2062803,2063950,2065225,2066517,2067706,2068885,2070127,2071368,2072491,2073920,2075180,2076204,2077575,2078799,2079756,2080970,2082004,2083109,2084058,2085298,2086131,2087310,2088335,2089576,2090677,2091818,2092957,2094244,2095562,2096565,2097442,2098621,2100018,2101445,2102721,2104048,2105586,2107058,2108545,2109625,2110455,2111021,2111630,2112551,2113486,2114410,2115721,2116754,2117844,2119194,2120392,2121613,2122969,2124242,2125439,2126474,2127407,2128587,2129705,2130636,2131713,2132456,2133540,2134567,2135564,2136733,2137672,2138702,2139983,2141000,2141940,2142890,2144096,2144954,2146052,2147117,2148222,2149484,2150495,2151469,2152539,2153618,2154541,2155876,2157113,2158213,2159428,2160732,2161926,2163247,2164676,2165993,2167276,2168697,2169676,2170554,2171610,2172656,2173531,2174911,2176098,2177461,2178698,2179938,2180992,2182059,2183338,2184798,2186215,2187223,2188583,2189865,2191052,2192170,2193478,2194494,2195634,2196657,2197927,2199161,2200442,2201784,2202933,2204139,2205588,2207037,2208382,2209562,2210810,2211741,2212861,2213921,2214772,2215790,2216982,2218311,2219741,2220888,2222085,2223363,2224622,2225838,2227276,2228295,2229404,2230728,2231930,2233186,2234335,2235502,2236870,2238190,2239424,2240514,2241485,2242439,2243336,2244658,2245957,2247355,2248687,2250102,2251202,2252408,2253611,2254726,2255856,2256837,2257882,2259085,2260145,2261353,2262685,2263706,2264898,2266024,2267229,2268552,2269666,2270877,2272012,2273018,2274364,2275509,2276626,2277875,2279106,2280542,2281810,2283151,2284628,2285847,2287289,2288505,2289862,2291408,2292675,2293909,2295368,2296781,2298139,2299391,2300855,2302163,2303218,2304421,2305179,2305929,2306726,2307442,2308116,2309107,2309959,2310929,2311727,2312368,2313263,2314319,2315101,2315809,2316444,2317269,2318015,2319107,2320081,2320751,2321624,2322301,2323151,2323998,2325047,2326035,2326947,2327956,2328869,2330140,2331180,2332541,2333519,2334631,2335637,2336910,2337979,2339070,2340227,2341444,2342402,2343484,2344709,2345883,2346994,2348153,2349425,2350498,2351652,2352626,2353574,2354882,2355921,2357059,2358276,2359423,2360556,2361495,2362562,2363330,2364396,2365550,2366633,2367556,2368514,2369579,2370621,2371648,2372648,2373416,2374524,2375999,2377275,2378407,2379482,2380426,2381929,2383253,2384224,2385665,2387098,2388313,2389618,2390777,2391699,2392631,2393794,2394957,2395963,2397077,2398261,2399293,2400593,2401608,2402870,2403613,2404502,2405427,2406575,2407780,2408957,2409907,2410399,2411411,2412582,2413662,2414884,2416123,2417371,2418899,2420121,2421135,2422245,2423597,2424875,2426183,2427398,2428284,2429402,2430416,2431826,2433259,2434360,2435450,2436783,2438033,2439269,2440755,2442350,2443523,2444732,2445869,2446820,2448024,2449171,2450059,2451309,2452151,2453285,2454343,2455466,2456416,2457724,2458867,2459905,2460970,2462185,2463456,2464643,2465852,2467259,2468308,2469524,2470565,2471646,2472899,2474062,2475375,2476704,2478014,2479364,2480368,2481559,2482953,2484271,2485821,2487455,2488875,2490286,2491788,2493110,2494088,2495253,2496741,2497840,2499187,2500251,2501381,2502606,2503929,2505228,2506417,2507301,2508354,2509616,2510825,2512112,2513320,2514578,2515711,2516752,2517697,2518547,2519493,2520427,2521349,2522274,2523216,2524098,2525053,2525919,2526810,2527686,2528661,2529539,2530381,2531167,2532047,2533009,2533917,2534840,2535757,2536644,2537484,2538412,2539332,2540248,2541127,2542494,2543872,2545162,2545944,2546721,2547691,2548776,2549968,2551069,2552372,2553676,2555013,2556501,2557685,2559027,2560437,2561902,2563294,2564519,2565722,2566920,2568075,2569301,2570354,2571446,2572472,2573765,2575165,2576408,2577612,2578888,2580037,2581226,2582449,2583676,2584816,2585805,2587006,2588218,2589285,2590348,2591493,2592773,2594063,2595141,2596258,2597384,2598678,2599865,2601113,2602237,2603490,2604819,2605986,2607136,2608374,2609699,2611058,2612425,2613619,2614731,2615932,2616974,2618086,2619409,2620832,2622154,2623373,2624444,2625580,2626852,2627760,2629049,2630288,2631701,2632729,2634087,2635471,2636665,2637925,2639183,2640340,2641703,2642989,2644101,2645165,2646029,2647165,2648233,2649470,2650622,2651860,2653200,2654494,2655515,2656944,2658021,2659219,2660490,2661628,2662784,2663875,2664968,2666155,2667438,2668662,2669687,2670818,2672002,2673155,2674348,2675493,2676682,2677961,2679306,2680405,2681326,2682518,2683660,2684679,2685966,2687225,2688210,2689325,2690439,2691250,2692317,2693406,2694471,2695578,2696627,2697768,2698671,2699746,2700708,2701952,2702830,2703816,2704777,2705688,2706706,2707840,2708966,2710166,2711236,2712177,2713423,2714572,2715584,2716893,2717857,2718807,2719938,2721117,2722075,2723096,2724108,2725046,2726175,2727169,2728174,2728953,2730149,2731299,2732557,2733440,2734448,2735494,2736639,2737731,2738894,2739961,2741042,2742005,2743177,2744272,2745466,2746324,2747184,2748178,2749075,2750220,2751394,2752567,2753880,2755249,2756578,2757926,2758993,2760165,2761411,2762668,2763958,2764996,2765961,2767112,2768310,2769324,2770722,2771940,2773154,2774204,2775120,2775921,2776878,2777765,2779219,2780387,2781852,2783219,2784668,2785096,2785514,2785943,2786388,2786814,2787193,2787606,2787997,2788464,2788894,2789313,2789741,2790157,2790574,2790996,2791422,2791876,2792376,2793528,2794973,2796089,2796988,2797865,2798849,2799689,2801071,2802221,2803180,2803687,2804219,2804906,2805550,2806126,2806615,2807102,2807587,2808081,2808560,2809029,2809511,2809997,2810496,2810975,2811461,2811950,2812429,2812919,2813414,2813892,2814388,2814880,2815361,2815856,2816350,2816843,2817333,2817831,2818319,2818811,2819279,2819980,2821124,2822208,2823714,2824897,2826258,2827552,2828735,2830089,2831137,2832129,2833131,2834092,2835144,2836088,2837057,2838036,2838966,2840002,2840980,2841913,2842903,2843810,2844811,2845767,2846755,2847681,2848665,2849610,2850582,2851503,2852476,2853435,2854409,2855349,2856335,2857319,2858300,2859241,2860174,2861223,2862412,2863978,2865532,2867105,2868660,2870213,2871763,2873312,2874869,2876421,2877972,2879528,2881019,2882256,2883777,2885409,2887030,2888600,2890513,2891864,2893190,2894387,2895487,2896884,2898245,2899639,2900787,2901878,2902962,2904045,2905205,2906309,2907379,2908431,2909534,2910620,2911704,2912797,2913878,2914969,2916038,2917131,2918203,2919298,2920378,2921458,2922543,2923634,2924723,2925813,2926886,2927996,2929141,2930401,2931779,2933343,2934987,2936555,2938107,2939518,2941020,2942174,2943685,2944988,2946120,2947489,2948826,2949927,2950961,2952054,2953135,2954698,2956235,2957476,2958774,2959955,2961467,2963039,2964373,2965576,2966777,2967795,2969034,2970407,2971745,2972999,2974052,2975051,2976471,2978052,2979501,2980862,2982331,2983724,2985152,2986294,2987631,2988833,2990093,2991294,2992723,2993894,2995147,2996219,2997458,2998560,2999661,3000794,3002168,3003491,3004546,3005312,3006473,3007244,3008003,3008757,3009284,3009870,3010416,3010919,3011414,3011987,3012547,3013108,3013693,3014263,3014790,3015329,3015918,3016467,3017073,3017675,3018412,3019661,3020787,3022038,3023169,3024353,3025925,3027124,3028481,3029933,3031146,3032532,3033697,3034877,3035875,3037132,3038317,3039679,3040911,3041959,3043143,3044239,3045576,3046681,3048000,3049129,3050408,3051621,3052829,3054131,3055121,3056438,3057222,3058332,3059600,3060731,3061838,3063054,3064359,3065138,3066323,3067566,3068536,3069598,3070350,3071689,3072925,3074398,3075508,3076828,3077963,3079010,3080422,3081568,3082700,3083913,3085201,3086418,3087728,3088919,3090178,3091580,3092695,3093867,3094973,3096173,3097355,3098492,3099795,3100888,3102168,3103368,3104560,3105765,3107135,3108341,3109533,3110946,3112138,3113201,3114229,3115527,3116801,3118168,3119284,3120674,3121788,3122921,3124014,3125155,3126401,3127360,3128025,3128814,3129813,3131192,3132562,3133641,3134586,3135758,3136707,3137827,3139027,3139965,3140997,3142138,3143232,3144588,3145641,3147016,3148385,3149697,3150869,3152099,3153102,3154297,3155282,3156186,3157054,3158307,3159325,3160241,3161565,3162743,3163757,3164749,3165864,3167047,3168428,3169410,3170675,3171836,3172970,3174178,3175503,3176723,3177806,3179137,3180410,3181781,3183326,3184014,3185118,3186021,3186958,3188120,3189081,3190050,3191185,3192322,3193291,3194355,3195653,3197219,3198344,3199592,3200663,3201751,3202685,3203894,3204922,3206249,3207276,3208341,3209084,3210058,3211109,3212296,3213347,3214342,3215274,3216554,3217926,3219036,3220185,3221325,3222506,3223696,3224793,3225920,3226900,3228350,3229773,3230743,3231814,3233070,3234141,3235227,3236400,3237452,3238474,3239652,3241004,3242015,3243133,3244548,3245726,3246853,3247586,3248689,3249702,3250798,3252025,3253326,3254431,3255029,3256091,3257283,3258545,3259485,3260681,3261679,3262645,3263814,3265126,3266068,3267030,3268261,3269660,3270780,3272053,3273238,3274184,3275229,3276642,3277856,3279015,3280055,3281178,3282274,3283293,3284320,3285269,3286328,3287339,3288528,3289334,3290227,3291245,3292331,3293645,3294808,3295674,3296667,3297552,3298600,3299510,3300632,3301429,3302485,3303539,3304970,3306178,3307281,3308572,3310083,3311368,3312857,3314193,3315774,3317210,3318846,3320218,3321362,3322589,3323831,3325063,3326350,3327593,3328818,3330023,3331390,3332604,3333862,3335209,3336378,3337395,3338658,3339701,3340707,3341810,3343121,3344512,3345999,3347345,3348399,3349377,3350397,3351505,3352743,3353910,3354786,3355997,3356920,3357697,3358687,3359934,3361097,3362389,3363419,3364410,3365256,3366205,3367164,3368151,3369060,3369779,3370707,3371924,3373065,3374485,3375543,3376905,3378415,3379444,3380680,3381839,3383261,3384601,3385847,3387112,3388420,3389623,3390877,3392137,3393298,3394372,3395454,3396679,3397717,3398648,3399478,3400545,3401670,3402667,3403893,3405142,3406436,3407344,3408281,3409402,3410304,3411291,3412401,3413553,3414669,3415840,3417146,3418397,3419466,3420505,3421811,3422820,3424011,3425141,3426322,3427416,3428720,3429747,3431049,3432192,3433141,3434271,3435438,3436647,3437795,3439200,3440378,3441517,3442499,3443501,3444677,3445869,3447258,3448496,3449661,3450859,3452298,3453616,3454818,3455950,3457177,3458545,3459837,3461047,3462288,3463615,3465021,3466262,3467453,3468817,3470132,3471336,3472234,3473619,3474864,3475848,3477298,3478431,3479412,3480479,3481740,3482989,3484139,3485020,3485862,3487099,3487847,3488801,3489707,3490603,3491654,3493026,3494398,3495300,3496505,3497594,3498411,3499287,3500684,3501862,3502808,3504077,3505265,3506154,3506988,3508001,3508882,3509759,3510773,3511940,3512852,3513712,3514646,3515559,3516315,3517134,3518041,3519060,3520009,3521280,3522321,3523312,3524435,3525379,3526799,3528185,3529506,3530616,3531807,3532769,3533755,3534830,3535883,3536783,3538170,3539363,3540384,3541282,3542050,3542794,3544042,3545452,3546796,3548219,3549438,3550586,3551774,3553043,3554157,3555352,3556437,3557868,3559032,3560272,3561443,3562782,3564133,3565245,3566412,3567336,3568480,3569862,3571060,3572363,3573604,3574660,3576088,3577443,3578715,3580021,3581181,3582561,3583826,3584878,3586050,3587183,3588442,3589586,3590651,3591815,3592830,3594040,3595247,3596675,3597595,3599010,3600246,3601571,3603041,3604573,3605834,3607147,3608265,3609359,3610764,3612047,3613299,3614529,3615519,3616579,3617700,3618619,3620022,3621348,3622731,3623853,3624881,3626169,3627317,3628260,3629405,3630214,3631244,3632034,3633100,3634442,3635663,3636917,3638217,3639035,3640231,3641188,3642424,3643809,3644783,3645902,3647036,3648540,3649723,3650876,3652284,3653551,3654794,3656058,3657233,3658613,3659919,3661043,3662267,3663129,3664298,3665175,3666399,3667575,3668804,3669867,3670862,3671775,3672433,3673525,3674491,3675567,3676651,3677554,3678588,3679215,3680157,3681095,3682194,3683126,3684122,3685215,3686191,3687086,3688026,3689071,3690185,3691167,3692210,3692901,3694238,3695586,3696867,3698336,3699519,3700622,3701901,3703222,3704595,3705963,3707574,3708587,3709794,3711218,3712252,3713497,3714379,3715505,3716545,3717727,3718706,3719617,3720737,3721896,3723063,3724112,3725084,3726261,3727455,3728554,3729804,3730961,3732135,3733238,3734447,3735757,3736759,3737693,3738635,3739982,3741018,3742202,3742962,3743956,3744728,3745839,3747040,3748131,3749213,3750267,3751406,3752634,3753840,3754823,3756114,3757090,3758201,3759189,3760149,3761213,3762397,3763674,3764646,3765921,3767327,3768572,3769920,3771146,3772350,3773601,3774994,3776228,3777531,3778821,3779966,3781159,3782244,3783217,3784351,3785692,3786944,3788162,3789224,3790509,3791894,3792995,3793979,3795158,3796503,3797924,3798931,3800123,3801289,3802462,3803650,3804835,3806016,3807313,3808568,3809863,3811274,3812515,3813565,3814958,3816202,3817380,3818676,3819933,3821030,3822116,3823121,3824246,3825449,3826703,3827940,3829306,3830731,3832086,3833524,3834823,3836072,3836995,3837945,3839345,3840500,3841796,3843069,3844330,3845695,3846783,3848078,3849258,3850460,3851574,3852802,3853767,3854941,3856091,3857094,3858350,3859689,3861173,3862613,3863758,3864867,3865994,3867130,3868356,3869687,3870675,3871736,3872730,3873428,3874514,3875665,3876756,3878056,3879414,3880626,3881875,3883085,3884284,3885401,3886702,3887836,3888937,3889922,3890704,3891627,3892312,3893419,3894445,3895603,3896760,3897613,3898962,3900115,3901094,3902031,3902824,3904108,3905110,3906006,3907116,3907979,3909132,3910278,3911507,3912662,3914040,3915283,3916618,3917603,3918739,3920185,3921372,3922626,3924036,3925123,3926359,3927643,3928981,3930249,3931392,3932504,3933820,3935145,3936506,3937897,3939349,3940665,3941958,3943146,3944482,3945612,3946917,3948173,3949424,3950547,3951765,3952745,3953946,3954995,3956133,3957119,3958468,3959797,3961048,3962472,3963581,3964701,3965936,3967163,3968346,3969800,3971203,3972359,3973440,3974473,3975784,3976952,3978215,3979413,3980542,3981396,3982548,3983640,3984733,3985913,3986987,3987891,3989131,3990465,3991479,3992801,3993656,3994897,3995999,3997264,3998737,4000209,4001542,4002739,4003896,4005028,4006162,4007209,4008674,4009868,4010988,4012153,4013122,4013980,4015051,4016125,4017166,4018378,4019679,4020700,4021734,4022695,4023512,4024413,4025148,4026260,4027278,4027974,4028602,4029506,4030463,4031322,4032264,4033438,4034714,4035829,4036919,4038152,4039423,4040434,4041519,4042610,4043627,4044778,4046074,4047177,4048089,4049019,4049897,4051203,4052210,4053380,4054655,4055914,4056970,4057608,4058578,4059628,4060681,4061783,4062933,4064191,4065292,4066171,4066999,4067706,4068765,4069975,4071122,4072304,4073678,4075146,4076631,4077814,4078747,4079813,4080725,4081949,4083453,4084807,4085805,4086960,4088378,4089648,4090755,4092017,4093482,4094846,4096292,4097501,4098602,4099509,4100489,4101869,4103318,4104771,4106208,4107539,4108756,4109871,4110907,4111975,4113195,4114535,4115957,4117232,4118506,4119791,4120864,4122146,4123331,4124515,4125852,4127106,4128347,4129454,4130685,4131857,4133099,4134254,4135445,4136542,4137786,4138907,4139918,4141327,4142740,4143951,4145112,4146229,4147507,4148828,4150225,4151335,4152570,4153396,4154570,4155472,4156660,4158148,4159396,4160526,4161859,4163212,4164432,4165668,4166842,4167999,4169083,4169936,4171169,4172360,4173588,4174777,4176034,4177157,4178470,4179284,4180701,4182016,4183250,4184494,4185483,4186641,4187784,4188864,4190236,4191269,4192487,4193645,4194894,4195955,4197090,4198053,4199085,4200126,4201284,4202437,4203550,4204423,4205723,4207072,4208153,4209448,4210795,4212092,4213078,4214224,4215119,4216072,4216990,4218077,4219222,4220240,4221079,4222281,4223357,4224490,4225497,4226563,4227696,4228566,4229786,4230907,4232079,4232952,4233779,4234818,4236059,4237095,4238154,4239165,4240166,4240972,4242033,4243138,4244040,4244914,4246084,4247262,4248449,4249178,4250075,4251204,4252181,4253154,4254083,4255228,4256401,4257491,4258501,4259441,4260246,4261360,4262464,4263300,4264462,4265712,4266674,4267353,4268466,4269534,4270667,4271997,4273490,4274501,4275276,4276227,4277012,4278143,4279522,4281005,4282304,4283470,4284610,4285519,4286722,4287858,4288889,4290098,4290868,4292067,4293168,4294204,4295195,4296153,4297259,4298473,4299583,4300864,4302099,4303375,4304587,4305726,4306740,4307907,4309011,4309661,4310781,4311787,4313048,4314006,4315049,4316094,4317237,4318191,4319514,4320925,4322337,4323592,4324884,4326112,4327312,4328529,4329655,4330808,4331794,4332969,4334289,4335495,4336495,4337421,4338567,4339785,4340856,4341841,4342791,4343842,4344906,4346100,4347375,4348405,4349553,4350680,4351888,4353106,4354328,4355460,4356803,4358086,4359263,4360355,4361466,4362538,4363461,4364540,4365494,4366344,4367050,4368044,4369128,4370312,4371518,4372840,4374161,4375178,4376387,4377496,4378839,4380090,4381541,4382822,4384149],"sizes":[2000,1894,1885,1772,1787,1674,1689,1830,1769,1798,1803,1749,1807,1770,1804,1730,1728,1761,1755,1579,1264,1162,1410,1055,1017,994,1148,1328,1298,1145,1338,1219,1320,1226,1399,1418,1230,1027,1206,896,827,986,970,845,1366,1285,1272,1136,1198,1172,1088,811,831,1034,793,661,1162,1101,907,1243,1375,1132,1162,1105,821,1248,1247,959,1203,886,882,825,1280,1096,1132,819,1075,1073,831,883,1064,1067,929,1039,905,1017,979,1033,806,1238,872,1094,1335,1310,1200,1123,1164,1218,1413,1046,1231,1289,1262,1139,1361,981,1365,1081,1242,1126,1050,1243,1125,1269,1080,1011,1427,1248,1317,1215,1053,1212,1153,1228,1301,1213,1174,923,1027,1044,1166,1334,1312,1102,1335,1263,1241,1140,1228,1413,1260,1187,1373,1341,1329,1435,1229,1260,1158,997,1304,1382,1245,1353,1488,1432,1275,1263,1447,1264,1206,1282,1471,1011,912,934,905,1119,1011,1269,1125,1519,1155,1038,643,629,575,659,460,564,689,664,478,610,598,677,606,675,661,573,641,650,666,677,636,623,691,1049,1119,1226,1207,1187,1270,1261,1202,1488,1334,1469,1349,1264,1304,1353,1135,1092,826,1120,1016,1065,630,1108,1154,1252,1305,903,1033,1239,994,1245,932,844,1053,1148,1063,1272,1275,991,846,922,1238,1006,1261,1308,1364,1248,1196,1137,1100,986,1198,1300,1224,1232,1101,1273,891,1282,1016,824,768,1081,1381,1407,1361,1360,1414,1245,1157,1300,1169,1099,1070,1247,1181,1248,946,1179,774,1281,1174,1133,1140,1112,1042,1099,1015,1398,1381,1358,1139,1087,1025,993,1340,1337,1304,1244,1052,1125,1216,1206,1264,1335,1230,1273,1304,1243,1096,1251,1205,994,1195,1159,1253,1184,1107,1089,1360,1246,1296,1422,1424,1393,1148,934,1378,1134,1304,1209,721,996,1187,1139,1255,947,1192,1392,1325,1394,1304,1028,1138,1022,996,976,633,971,1076,1124,966,830,883,800,1126,1095,1244,1164,780,496,865,1195,1200,1169,1004,989,1321,1268,1176,960,1174,887,862,1186,1320,899,1606,1367,1040,827,993,1405,1412,908,1363,1301,798,1184,994,1084,1436,948,934,926,818,844,816,893,870,966,918,964,1035,1450,1135,1074,1266,1076,498,522,756,588,1055,1265,1380,1909,1855,1901,1786,1856,1914,1733,1923,2001,1932,1835,1759,1795,1787,1694,1832,1756,1898,1910,1934,1767,1938,1875,1815,1908,1815,1657,1931,1661,1785,1594,1148,1206,1929,1844,1870,1476,1902,1623,1716,1791,1807,1807,1798,1906,1761,1291,1108,1242,1191,993,1102,1481,1415,1218,1419,1413,1230,1110,1258,1292,1237,1188,1003,1319,1220,1350,1337,1746,1309,1836,1703,1520,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,1068,644,462,570,706,1064,1031,1057,1257,1353,1273,1288,940,704,639,712,833,839,627,620,830,973,836,765,632,564,610,663,816,955,729,391,508,844,1416,1008,1028,907,1316,1184,1356,1428,2024,2046,2048,2048,2048,2048,2048,2048,2048,2021,2048,2048,2048,2057,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2001,2048,1734,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,1965,1934,1948,2048,2057,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048,1780,1817,2048,2046,2048,418,25,25,25,25,25,25,40,58,139,351,433,588,743,699,792,849,834,779,738,727,784,775,830,783,827,846,808,759,937,911,853,830,758,663,743,817,877,814,841,884,900,747,801,868,908,962,874,773,736,701,767,752,699,721,728,758,825,822,773,786,744,744,776,746,677,638,644,539,506,629,658,620,627,742,814,799,718,682,729,717,735,678,704,656,667,666,671,714,715,710,738,724,755,807,827,872,901,894,959,970,925,929,946,1015,907,901,865,739,642,567,489,392,300,312,477,179,63,47,25,25,25,25,25,25,25,25,25,1240,1026,1452,1537,1318,1043,1255,1215,1390,1162,898,1023,1101,996,1217,1174,1017,1158,944,1277,1136,1175,1055,857,1058,1168,1259,1167,1396,1079,1153,1190,1434,1350,1194,1091,938,816,1218,1221,1352,1145,1313,1186,947,1258,1278,1226,1322,1483,1494,1492,1343,1098,1055,1291,1340,1237,1264,635,926,1193,984,1350,1130,1487,1424,1100,1205,1364,1291,1160,1119,1339,1240,1212,1424,1133,1201,1171,710,664,1126,1035,1141,1336,1277,1410,1270,872,1302,1131,1268,793,1020,659,893,1217,1031,987,1230,1139,1201,1143,1227,1083,1176,1044,1241,985,1098,1086,1320,855,1198,1192,1174,1333,1019,925,1077,1262,1315,1163,1193,1032,931,1076,1048,1314,1219,1147,1094,938,1127,1129,896,918,1276,1053,1043,1161,1156,1167,1210,1126,1284,1034,908,1195,903,1155,1192,1243,1314,1200,1450,1100,1194,1278,1194,1260,1388,1093,1043,1377,1023,1330,933,1091,1256,1194,1339,1122,1250,1317,1277,1107,1326,1356,1395,1285,1351,1284,1123,1155,1299,1238,999,713,1145,1311,1306,963,1286,1347,1376,1288,1430,1378,1302,1302,1370,1305,1231,845,1115,1380,1343,1183,1118,881,1325,977,1329,1182,1173,1118,941,1186,1135,1008,1056,1148,1160,1208,905,1253,1327,775,1029,1106,861,1107,1070,1166,1153,930,796,810,1140,1045,962,1268,1303,1265,1081,1286,1250,1177,1201,1086,1239,940,1136,1077,1011,1319,1349,1297,1238,1165,1246,1180,1084,1061,1204,1415,952,1117,903,1134,1187,981,1241,1189,1043,1314,1170,1185,1083,1185,1157,1107,1272,1051,1121,1393,1340,1245,1030,747,1477,1141,1207,1203,946,1234,1240,1133,1163,1193,789,1297,1271,1250,1028,1143,1296,1220,1445,979,1254,1130,893,1156,900,1128,1097,1332,1422,1224,1141,1014,914,753,1125,775,811,1109,1216,1325,1082,1227,1440,1232,1172,1223,1081,927,1107,1091,1347,1297,1198,814,1091,971,1297,991,1111,773,969,833,753,802,856,832,724,821,663,1099,1276,932,733,773,510,536,686,613,604,1098,765,741,1049,946,1247,843,1287,1070,1117,1167,1025,904,966,890,1302,1287,1132,1360,1328,1101,1252,1401,1255,1301,1083,997,1071,829,1072,1101,1066,949,1069,902,1115,1174,858,868,753,704,812,1065,1145,1134,1012,1118,1070,1063,1074,1075,992,1033,1333,1048,1129,1006,1055,1055,1053,786,1055,967,1026,1069,1055,975,879,1022,1189,993,1030,1175,1412,927,1209,1035,1088,1196,1283,1354,1139,1337,1024,1286,1147,1214,870,666,833,824,705,1180,1059,1068,803,1005,833,1061,916,783,852,1056,1154,1385,1220,1276,973,1044,1083,1346,1166,842,1187,1144,1243,1184,1071,1035,1047,1044,1052,1178,1061,913,1091,1202,1091,1096,1084,926,945,1129,976,1059,867,928,1073,1078,1093,1006,1036,1122,1223,1035,1145,850,1068,1105,1219,1401,1136,1231,1031,1010,1003,1074,1002,1324,1042,1252,932,699,1073,1145,1025,1142,1221,1279,1411,1122,1102,1127,1162,988,1191,1261,1235,1233,1297,1287,1371,1278,1326,1109,1049,1226,1389,1388,1289,1162,1103,1019,1212,1264,1212,1140,1377,1392,1128,1036,1210,1252,1049,1013,970,836,1004,977,1044,943,1032,969,1214,1371,1236,1374,1267,1035,1099,1009,935,1166,1124,1073,1204,1233,1269,1182,1245,1179,835,1019,945,1087,1114,968,1042,1235,1221,1350,1149,1300,1177,1114,900,1203,1338,1167,1135,1268,1397,1322,1249,1186,1422,1228,1185,1144,1203,1107,1174,1076,1187,1218,1007,853,1150,1147,1185,1087,1009,938,1132,1144,1157,991,1155,1034,1181,1152,1037,1035,1270,1212,1154,1248,1176,1038,1205,954,844,1000,1028,1102,1149,1159,1186,1006,1100,1034,1224,1122,1130,1160,1063,1035,1304,1154,1254,1114,1199,1022,1202,1380,1008,1477,1337,1262,1404,1361,1276,1356,1193,1144,1282,1295,1082,1034,1127,1272,1369,1251,1209,1133,918,785,1067,972,1066,928,1148,1198,990,880,1430,1167,1199,1271,994,1407,1422,1333,1266,1352,1158,1151,1091,1128,975,1249,1263,1327,1205,1316,1388,1147,1285,629,657,843,1297,1166,1014,979,637,873,704,806,735,1429,992,1354,1341,863,1236,1115,984,1128,920,1148,737,1010,1235,776,1279,1189,1194,970,1032,796,1182,1080,1243,1375,1106,1217,1182,1053,1231,1323,1199,1275,893,1000,1146,1192,1090,943,1263,1051,975,1185,1157,1026,1058,1084,1056,1173,1182,1005,1154,1229,1127,1245,1276,1003,1277,1047,1180,1008,1045,1287,1227,1340,1141,1201,1254,1067,1479,1252,1165,1222,1309,1097,1356,1183,1444,1164,1067,1151,1213,1014,1313,1066,1281,1200,1095,1137,949,1042,1378,1177,1240,1131,1074,1180,1209,1332,1247,978,1011,1043,1020,1293,1457,998,834,1397,1406,1091,1068,1301,1196,1313,1160,1333,1256,1096,1338,1404,1268,1120,1123,1353,1216,1320,1085,1297,1405,1323,1315,1271,1239,1200,1192,1325,1389,1381,1468,1439,1352,1196,1415,1319,1337,1245,1339,1208,1265,1265,1089,1351,1358,1170,1237,1353,1012,1297,1307,1294,1343,1216,1156,1433,1286,1254,1267,693,1227,1048,1147,1275,1292,1189,1179,1242,1241,1123,1429,1260,1024,1371,1224,957,1214,1034,1105,949,1240,833,1179,1025,1241,1101,1141,1139,1287,1318,1003,877,1179,1397,1427,1276,1327,1538,1472,1487,1080,830,566,609,921,935,924,1311,1033,1090,1350,1198,1221,1356,1273,1197,1035,933,1180,1118,931,1077,743,1084,1027,997,1169,939,1030,1281,1017,940,950,1206,858,1098,1065,1105,1262,1011,974,1070,1079,923,1335,1237,1100,1215,1304,1194,1321,1429,1317,1283,1421,979,878,1056,1046,875,1380,1187,1363,1237,1240,1054,1067,1279,1460,1417,1008,1360,1282,1187,1118,1308,1016,1140,1023,1270,1234,1281,1342,1149,1206,1449,1449,1345,1180,1248,931,1120,1060,851,1018,1192,1329,1430,1147,1197,1278,1259,1216,1438,1019,1109,1324,1202,1256,1149,1167,1368,1320,1234,1090,971,954,897,1322,1299,1398,1332,1415,1100,1206,1203,1115,1130,981,1045,1203,1060,1208,1332,1021,1192,1126,1205,1323,1114,1211,1135,1006,1346,1145,1117,1249,1231,1436,1268,1341,1477,1219,1442,1216,1357,1546,1267,1234,1459,1413,1358,1252,1464,1308,1055,1203,758,750,797,716,674,991,852,970,798,641,895,1056,782,708,635,825,746,1092,974,670,873,677,850,847,1049,988,912,1009,913,1271,1040,1361,978,1112,1006,1273,1069,1091,1157,1217,958,1082,1225,1174,1111,1159,1272,1073,1154,974,948,1308,1039,1138,1217,1147,1133,939,1067,768,1066,1154,1083,923,958,1065,1042,1027,1000,768,1108,1475,1276,1132,1075,944,1503,1324,971,1441,1433,1215,1305,1159,922,932,1163,1163,1006,1114,1184,1032,1300,1015,1262,743,889,925,1148,1205,1177,950,492,1012,1171,1080,1222,1239,1248,1528,1222,1014,1110,1352,1278,1308,1215,886,1118,1014,1410,1433,1101,1090,1333,1250,1236,1486,1595,1173,1209,1137,951,1204,1147,888,1250,842,1134,1058,1123,950,1308,1143,1038,1065,1215,1271,1187,1209,1407,1049,1216,1041,1081,1253,1163,1313,1329,1310,1350,1004,1191,1394,1318,1550,1634,1420,1411,1502,1322,978,1165,1488,1099,1347,1064,1130,1225,1323,1299,1189,884,1053,1262,1209,1287,1208,1258,1133,1041,945,850,946,934,922,925,942,882,955,866,891,876,975,878,842,786,880,962,908,923,917,887,840,928,920,916,879,1367,1378,1290,782,777,970,1085,1192,1101,1303,1304,1337,1488,1184,1342,1410,1465,1392,1225,1203,1198,1155,1226,1053,1092,1026,1293,1400,1243,1204,1276,1149,1189,1223,1227,1140,989,1201,1212,1067,1063,1145,1280,1290,1078,1117,1126,1294,1187,1248,1124,1253,1329,1167,1150,1238,1325,1359,1367,1194,1112,1201,1042,1112,1323,1423,1322,1219,1071,1136,1272,908,1289,1239,1413,1028,1358,1384,1194,1260,1258,1157,1363,1286,1112,1064,864,1136,1068,1237,1152,1238,1340,1294,1021,1429,1077,1198,1271,1138,1156,1091,1093,1187,1283,1224,1025,1131,1184,1153,1193,1145,1189,1279,1345,1099,921,1192,1142,1019,1287,1259,985,1115,1114,811,1067,1089,1065,1107,1049,1141,903,1075,962,1244,878,986,961,911,1018,1134,1126,1200,1070,941,1246,1149,1012,1309,964,950,1131,1179,958,1021,1012,938,1129,994,1005,779,1196,1150,1258,883,1008,1046,1145,1092,1163,1067,1081,963,1172,1095,1194,858,860,994,897,1145,1174,1173,1313,1369,1329,1348,1067,1172,1246,1257,1290,1038,965,1151,1198,1014,1398,1218,1214,1050,916,801,957,887,1454,1168,1465,1367,1449,428,418,429,445,426,379,413,391,467,430,419,428,416,417,422,426,454,500,1152,1445,1116,899,877,984,840,1382,1150,959,507,532,687,644,576,489,487,485,494,479,469,482,486,499,479,486,489,479,490,495,478,496,492,481,495,494,493,490,498,488,492,468,701,1144,1084,1506,1183,1361,1294,1183,1354,1048,992,1002,961,1052,944,969,979,930,1036,978,933,990,907,1001,956,988,926,984,945,972,921,973,959,974,940,986,984,981,941,933,1049,1189,1566,1554,1573,1555,1553,1550,1549,1557,1552,1551,1556,1491,1237,1521,1632,1621,1570,1913,1351,1326,1197,1100,1397,1361,1394,1148,1091,1084,1083,1160,1104,1070,1052,1103,1086,1084,1093,1081,1091,1069,1093,1072,1095,1080,1080,1085,1091,1089,1090,1073,1110,1145,1260,1378,1564,1644,1568,1552,1411,1502,1154,1511,1303,1132,1369,1337,1101,1034,1093,1081,1563,1537,1241,1298,1181,1512,1572,1334,1203,1201,1018,1239,1373,1338,1254,1053,999,1420,1581,1449,1361,1469,1393,1428,1142,1337,1202,1260,1201,1429,1171,1253,1072,1239,1102,1101,1133,1374,1323,1055,766,1161,771,759,754,527,586,546,503,495,573,560,561,585,570,527,539,589,549,606,602,737,1249,1126,1251,1131,1184,1572,1199,1357,1452,1213,1386,1165,1180,998,1257,1185,1362,1232,1048,1184,1096,1337,1105,1319,1129,1279,1213,1208,1302,990,1317,784,1110,1268,1131,1107,1216,1305,779,1185,1243,970,1062,752,1339,1236,1473,1110,1320,1135,1047,1412,1146,1132,1213,1288,1217,1310,1191,1259,1402,1115,1172,1106,1200,1182,1137,1303,1093,1280,1200,1192,1205,1370,1206,1192,1413,1192,1063,1028,1298,1274,1367,1116,1390,1114,1133,1093,1141,1246,959,665,789,999,1379,1370,1079,945,1172,949,1120,1200,938,1032,1141,1094,1356,1053,1375,1369,1312,1172,1230,1003,1195,985,904,868,1253,1018,916,1324,1178,1014,992,1115,1183,1381,982,1265,1161,1134,1208,1325,1220,1083,1331,1273,1371,1545,688,1104,903,937,1162,961,969,1135,1137,969,1064,1298,1566,1125,1248,1071,1088,934,1209,1028,1327,1027,1065,743,974,1051,1187,1051,995,932,1280,1372,1110,1149,1140,1181,1190,1097,1127,980,1450,1423,970,1071,1256,1071,1086,1173,1052,1022,1178,1352,1011,1118,1415,1178,1127,733,1103,1013,1096,1227,1301,1105,598,1062,1192,1262,940,1196,998,966,1169,1312,942,962,1231,1399,1120,1273,1185,946,1045,1413,1214,1159,1040,1123,1096,1019,1027,949,1059,1011,1189,806,893,1018,1086,1314,1163,866,993,885,1048,910,1122,797,1056,1054,1431,1208,1103,1291,1511,1285,1489,1336,1581,1436,1636,1372,1144,1227,1242,1232,1287,1243,1225,1205,1367,1214,1258,1347,1169,1017,1263,1043,1006,1103,1311,1391,1487,1346,1054,978,1020,1108,1238,1167,876,1211,923,777,990,1247,1163,1292,1030,991,846,949,959,987,909,719,928,1217,1141,1420,1058,1362,1510,1029,1236,1159,1422,1340,1246,1265,1308,1203,1254,1260,1161,1074,1082,1225,1038,931,830,1067,1125,997,1226,1249,1294,908,937,1121,902,987,1110,1152,1116,1171,1306,1251,1069,1039,1306,1009,1191,1130,1181,1094,1304,1027,1302,1143,949,1130,1167,1209,1148,1405,1178,1139,982,1002,1176,1192,1389,1238,1165,1198,1439,1318,1202,1132,1227,1368,1292,1210,1241,1327,1406,1241,1191,1364,1315,1204,898,1385,1245,984,1450,1133,981,1067,1261,1249,1150,881,842,1237,748,954,906,896,1051,1372,1372,902,1205,1089,817,876,1397,1178,946,1269,1188,889,834,1013,881,877,1014,1167,912,860,934,913,756,819,907,1019,949,1271,1041,991,1123,944,1420,1386,1321,1110,1191,962,986,1075,1053,900,1387,1193,1021,898,768,744,1248,1410,1344,1423,1219,1148,1188,1269,1114,1195,1085,1431,1164,1240,1171,1339,1351,1112,1167,924,1144,1382,1198,1303,1241,1056,1428,1355,1272,1306,1160,1380,1265,1052,1172,1133,1259,1144,1065,1164,1015,1210,1207,1428,920,1415,1236,1325,1470,1532,1261,1313,1118,1094,1405,1283,1252,1230,990,1060,1121,919,1403,1326,1383,1122,1028,1288,1148,943,1145,809,1030,790,1066,1342,1221,1254,1300,818,1196,957,1236,1385,974,1119,1134,1504,1183,1153,1408,1267,1243,1264,1175,1380,1306,1124,1224,862,1169,877,1224,1176,1229,1063,995,913,658,1092,966,1076,1084,903,1034,627,942,938,1099,932,996,1093,976,895,940,1045,1114,982,1043,691,1337,1348,1281,1469,1183,1103,1279,1321,1373,1368,1611,1013,1207,1424,1034,1245,882,1126,1040,1182,979,911,1120,1159,1167,1049,972,1177,1194,1099,1250,1157,1174,1103,1209,1310,1002,934,942,1347,1036,1184,760,994,772,1111,1201,1091,1082,1054,1139,1228,1206,983,1291,976,1111,988,960,1064,1184,1277,972,1275,1406,1245,1348,1226,1204,1251,1393,1234,1303,1290,1145,1193,1085,973,1134,1341,1252,1218,1062,1285,1385,1101,984,1179,1345,1421,1007,1192,1166,1173,1188,1185,1181,1297,1255,1295,1411,1241,1050,1393,1244,1178,1296,1257,1097,1086,1005,1125,1203,1254,1237,1366,1425,1355,1438,1299,1249,923,950,1400,1155,1296,1273,1261,1365,1088,1295,1180,1202,1114,1228,965,1174,1150,1003,1256,1339,1484,1440,1145,1109,1127,1136,1226,1331,988,1061,994,698,1086,1151,1091,1300,1358,1212,1249,1210,1199,1117,1301,1134,1101,985,782,923,685,1107,1026,1158,1157,853,1349,1153,979,937,793,1284,1002,896,1110,863,1153,1146,1229,1155,1378,1243,1335,985,1136,1446,1187,1254,1410,1087,1236,1284,1338,1268,1143,1112,1316,1325,1361,1391,1452,1316,1293,1188,1336,1130,1305,1256,1251,1123,1218,980,1201,1049,1138,986,1349,1329,1251,1424,1109,1120,1235,1227,1183,1454,1403,1156,1081,1033,1311,1168,1263,1198,1129,854,1152,1092,1093,1180,1074,904,1240,1334,1014,1322,855,1241,1102,1265,1473,1472,1333,1197,1157,1132,1134,1047,1465,1194,1120,1165,969,858,1071,1074,1041,1212,1301,1021,1034,961,817,901,735,1112,1018,696,628,904,957,859,942,1174,1276,1115,1090,1233,1271,1011,1085,1091,1017,1151,1296,1103,912,930,878,1306,1007,1170,1275,1259,1056,638,970,1050,1053,1102,1150,1258,1101,879,828,707,1059,1210,1147,1182,1374,1468,1485,1183,933,1066,912,1224,1504,1354,998,1155,1418,1270,1107,1262,1465,1364,1446,1209,1101,907,980,1380,1449,1453,1437,1331,1217,1115,1036,1068,1220,1340,1422,1275,1274,1285,1073,1282,1185,1184,1337,1254,1241,1107,1231,1172,1242,1155,1191,1097,1244,1121,1011,1409,1413,1211,1161,1117,1278,1321,1397,1110,1235,826,1174,902,1188,1488,1248,1130,1333,1353,1220,1236,1174,1157,1084,853,1233,1191,1228,1189,1257,1123,1313,814,1417,1315,1234,1244,989,1158,1143,1080,1372,1033,1218,1158,1249,1061,1135,963,1032,1041,1158,1153,1113,873,1300,1349,1081,1295,1347,1297,986,1146,895,953,918,1087,1145,1018,839,1202,1076,1133,1007,1066,1133,870,1220,1121,1172,873,827,1039,1241,1036,1059,1011,1001,806,1061,1105,902,874,1170,1178,1187,729,897,1129,977,973,929,1145,1173,1090,1010,940,805,1114,1104,836,1162,1250,962,679,1113,1068,1133,1330,1493,1011,775,951,785,1131,1379,1483,1299,1166,1140,909,1203,1136,1031,1209,770,1199,1101,1036,991,958,1106,1214,1110,1281,1235,1276,1212,1139,1014,1167,1104,650,1120,1006,1261,958,1043,1045,1143,954,1323,1411,1412,1255,1292,1228,1200,1217,1126,1153,986,1175,1320,1206,1000,926,1146,1218,1071,985,950,1051,1064,1194,1275,1030,1148,1127,1208,1218,1222,1132,1343,1283,1177,1092,1111,1072,923,1079,954,850,706,994,1084,1184,1206,1322,1321,1017,1209,1109,1343,1251,1451,1281,1327,1129],"successes":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}
;
            compressedData['data'] = byteArray;
            assert(typeof Module['LZ4'] === 'object', 'LZ4 not present - was your app build with -sLZ4?');
            Module['LZ4'].loadPackage({ 'metadata': metadata, 'compressedData': compressedData }, true);
            Module['removeRunDependency']('datafile_/home/runner/work/pygbag/pygbag/build/web/archives/0.0/cpython314/main.data');
      };
      Module['addRunDependency']('datafile_/home/runner/work/pygbag/pygbag/build/web/archives/0.0/cpython314/main.data');

      Module['preloadResults'] ??= {};

      Module['preloadResults'][PACKAGE_NAME] = {fromCache: false};
      if (fetched) {
        processPackageData(fetched);
        fetched = null;
      } else {
        fetchedCallback = processPackageData;
      }

    }
    if (Module['calledRun']) {
      runWithFS(Module);
    } else {
      (Module['preRun'] ??= []).push(runWithFS); // FS is not initialized yet, wait for it
    }

    }
    loadPackage({"files": [{"filename": "/data/data/org.python/assets/beep.ogg", "start": 0, "end": 5248, "audio": 1}, {"filename": "/data/data/org.python/assets/cpython.six", "start": 5248, "end": 10384}, {"filename": "/data/data/org.python/assets/pygame.six", "start": 10384, "end": 39939}, {"filename": "/data/data/org.python/assets/pygbag_app.py", "start": 39939, "end": 41117}, {"filename": "/data/data/org.python/assets/pygbag_fsm.py", "start": 41117, "end": 44270}, {"filename": "/data/data/org.python/assets/pygbag_host.py", "start": 44270, "end": 45719}, {"filename": "/data/data/org.python/assets/pygbag_ui.py", "start": 45719, "end": 62204}, {"filename": "/data/data/org.python/assets/pygbag_ux.py", "start": 62204, "end": 64355}, {"filename": "/data/data/org.python/assets/pyodide.py", "start": 64355, "end": 65441}, {"filename": "/data/data/org.python/assets/readline.py", "start": 65441, "end": 90332}, {"filename": "/data/data/org.python/assets/site-packages/__EMSCRIPTEN__.py", "start": 90332, "end": 101715}, {"filename": "/data/data/org.python/assets/site-packages/__WASM__.py", "start": 101715, "end": 101715}, {"filename": "/data/data/org.python/assets/site-packages/_xterm_parser/__init__.py", "start": 101715, "end": 101754}, {"filename": "/data/data/org.python/assets/site-packages/_xterm_parser/_ansi_sequences.py", "start": 101754, "end": 115177}, {"filename": "/data/data/org.python/assets/site-packages/_xterm_parser/_context.py", "start": 115177, "end": 116146}, {"filename": "/data/data/org.python/assets/site-packages/_xterm_parser/_parser.py", "start": 116146, "end": 120866}, {"filename": "/data/data/org.python/assets/site-packages/_xterm_parser/_time.py", "start": 120866, "end": 122301}, {"filename": "/data/data/org.python/assets/site-packages/_xterm_parser/_types.py", "start": 122301, "end": 123604}, {"filename": "/data/data/org.python/assets/site-packages/_xterm_parser/_xterm_parser.py", "start": 123604, "end": 134441}, {"filename": "/data/data/org.python/assets/site-packages/_xterm_parser/case.py", "start": 134441, "end": 134959}, {"filename": "/data/data/org.python/assets/site-packages/_xterm_parser/events.py", "start": 134959, "end": 148535}, {"filename": "/data/data/org.python/assets/site-packages/_xterm_parser/geometry.py", "start": 148535, "end": 183365}, {"filename": "/data/data/org.python/assets/site-packages/_xterm_parser/keys.py", "start": 183365, "end": 192302}, {"filename": "/data/data/org.python/assets/site-packages/_xterm_parser/message.py", "start": 192302, "end": 196077}, {"filename": "/data/data/org.python/assets/site-packages/_xterm_parser/messages.py", "start": 196077, "end": 198191}, {"filename": "/data/data/org.python/assets/site-packages/aio/__init__.py", "start": 198191, "end": 211956}, {"filename": "/data/data/org.python/assets/site-packages/aio/atexit.py", "start": 211956, "end": 212510}, {"filename": "/data/data/org.python/assets/site-packages/aio/clock.py", "start": 212510, "end": 214067}, {"filename": "/data/data/org.python/assets/site-packages/aio/cross.py", "start": 214067, "end": 218324}, {"filename": "/data/data/org.python/assets/site-packages/aio/fetch.py", "start": 218324, "end": 227156}, {"filename": "/data/data/org.python/assets/site-packages/aio/filelike.py", "start": 227156, "end": 232346}, {"filename": "/data/data/org.python/assets/site-packages/aio/gthread.py", "start": 232346, "end": 238417}, {"filename": "/data/data/org.python/assets/site-packages/aio/pep0723.py", "start": 238417, "end": 253976}, {"filename": "/data/data/org.python/assets/site-packages/aio/prepro.py", "start": 253976, "end": 254877}, {"filename": "/data/data/org.python/assets/site-packages/aio/recycle.py", "start": 254877, "end": 255862}, {"filename": "/data/data/org.python/assets/site-packages/aio/repl.py", "start": 255862, "end": 256123}, {"filename": "/data/data/org.python/assets/site-packages/aio/toplevel.py", "start": 256123, "end": 264254}, {"filename": "/data/data/org.python/assets/site-packages/aio/tracer.py", "start": 264254, "end": 266132}, {"filename": "/data/data/org.python/assets/site-packages/installer/__init__.py", "start": 266132, "end": 266265}, {"filename": "/data/data/org.python/assets/site-packages/installer/__main__.py", "start": 266265, "end": 269973}, {"filename": "/data/data/org.python/assets/site-packages/installer/_core.py", "start": 269973, "end": 274631}, {"filename": "/data/data/org.python/assets/site-packages/installer/_scripts/__init__.py", "start": 274631, "end": 274712}, {"filename": "/data/data/org.python/assets/site-packages/installer/destinations.py", "start": 274712, "end": 284326}, {"filename": "/data/data/org.python/assets/site-packages/installer/exceptions.py", "start": 284326, "end": 284574}, {"filename": "/data/data/org.python/assets/site-packages/installer/py.typed", "start": 284574, "end": 284574}, {"filename": "/data/data/org.python/assets/site-packages/installer/records.py", "start": 284574, "end": 291792}, {"filename": "/data/data/org.python/assets/site-packages/installer/scripts.py", "start": 291792, "end": 297343}, {"filename": "/data/data/org.python/assets/site-packages/installer/sources.py", "start": 297343, "end": 309132}, {"filename": "/data/data/org.python/assets/site-packages/installer/utils.py", "start": 309132, "end": 317265}, {"filename": "/data/data/org.python/assets/site-packages/packaging/__init__.py", "start": 317265, "end": 317759}, {"filename": "/data/data/org.python/assets/site-packages/packaging/_elffile.py", "start": 317759, "end": 321065}, {"filename": "/data/data/org.python/assets/site-packages/packaging/_manylinux.py", "start": 321065, "end": 330677}, {"filename": "/data/data/org.python/assets/site-packages/packaging/_musllinux.py", "start": 330677, "end": 333371}, {"filename": "/data/data/org.python/assets/site-packages/packaging/_parser.py", "start": 333371, "end": 343607}, {"filename": "/data/data/org.python/assets/site-packages/packaging/_structures.py", "start": 343607, "end": 345038}, {"filename": "/data/data/org.python/assets/site-packages/packaging/_tokenizer.py", "start": 345038, "end": 350311}, {"filename": "/data/data/org.python/assets/site-packages/packaging/licenses/__init__.py", "start": 350311, "end": 356026}, {"filename": "/data/data/org.python/assets/site-packages/packaging/licenses/_spdx.py", "start": 356026, "end": 404424}, {"filename": "/data/data/org.python/assets/site-packages/packaging/markers.py", "start": 404424, "end": 414985}, {"filename": "/data/data/org.python/assets/site-packages/packaging/metadata.py", "start": 414985, "end": 449747}, {"filename": "/data/data/org.python/assets/site-packages/packaging/py.typed", "start": 449747, "end": 449747}, {"filename": "/data/data/org.python/assets/site-packages/packaging/requirements.py", "start": 449747, "end": 452694}, {"filename": "/data/data/org.python/assets/site-packages/packaging/specifiers.py", "start": 452694, "end": 492768}, {"filename": "/data/data/org.python/assets/site-packages/packaging/tags.py", "start": 492768, "end": 513782}, {"filename": "/data/data/org.python/assets/site-packages/packaging/utils.py", "start": 513782, "end": 518832}, {"filename": "/data/data/org.python/assets/site-packages/packaging/version.py", "start": 518832, "end": 535508}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/__init__.py", "start": 535508, "end": 661069}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/api_tests.txt", "start": 661069, "end": 673664}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/py.typed", "start": 673664, "end": 673664}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/tests/__init__.py", "start": 673664, "end": 673664}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/tests/data/my-test-package-source/setup.cfg", "start": 673664, "end": 673664}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/tests/data/my-test-package-source/setup.py", "start": 673664, "end": 673769}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/tests/data/my-test-package-zip/my-test-package.zip", "start": 673769, "end": 675578}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/tests/data/my-test-package_unpacked-egg/my_test_package-1.0-py3.7.egg/EGG-INFO/PKG-INFO", "start": 675578, "end": 675765}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/tests/data/my-test-package_unpacked-egg/my_test_package-1.0-py3.7.egg/EGG-INFO/SOURCES.txt", "start": 675765, "end": 675973}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/tests/data/my-test-package_unpacked-egg/my_test_package-1.0-py3.7.egg/EGG-INFO/dependency_links.txt", "start": 675973, "end": 675974}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/tests/data/my-test-package_unpacked-egg/my_test_package-1.0-py3.7.egg/EGG-INFO/top_level.txt", "start": 675974, "end": 675975}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/tests/data/my-test-package_unpacked-egg/my_test_package-1.0-py3.7.egg/EGG-INFO/zip-safe", "start": 675975, "end": 675976}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/tests/data/my-test-package_zipped-egg/my_test_package-1.0-py3.7.egg", "start": 675976, "end": 676819}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/tests/test_find_distributions.py", "start": 676819, "end": 678790}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/tests/test_integration_zope_interface.py", "start": 678790, "end": 680442}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/tests/test_markers.py", "start": 680442, "end": 680683}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/tests/test_pkg_resources.py", "start": 680683, "end": 695712}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/tests/test_resources.py", "start": 695712, "end": 726684}, {"filename": "/data/data/org.python/assets/site-packages/pkg_resources/tests/test_working_set.py", "start": 726684, "end": 735215}, {"filename": "/data/data/org.python/assets/site-packages/platform_wasm/__init__.py", "start": 735215, "end": 735255}, {"filename": "/data/data/org.python/assets/site-packages/platform_wasm/matplotlib.py", "start": 735255, "end": 735255}, {"filename": "/data/data/org.python/assets/site-packages/platform_wasm/matplotlib/__init__.py", "start": 735255, "end": 735305}, {"filename": "/data/data/org.python/assets/site-packages/platform_wasm/matplotlib/pyplot.py", "start": 735305, "end": 736230}, {"filename": "/data/data/org.python/assets/site-packages/platform_wasm/panda3d.py", "start": 736230, "end": 737610}, {"filename": "/data/data/org.python/assets/site-packages/platform_wasm/pygame/__init__.py", "start": 737610, "end": 740408}, {"filename": "/data/data/org.python/assets/site-packages/platform_wasm/pygame/mixer_music.py", "start": 740408, "end": 745977}, {"filename": "/data/data/org.python/assets/site-packages/platform_wasm/pygame/timer.py", "start": 745977, "end": 748935}, {"filename": "/data/data/org.python/assets/site-packages/platform_wasm/pygame/vidcap.py", "start": 748935, "end": 750615}, {"filename": "/data/data/org.python/assets/site-packages/platform_wasm/textual.py", "start": 750615, "end": 754479}, {"filename": "/data/data/org.python/assets/site-packages/platform_wasm/todo.py", "start": 754479, "end": 762796}, {"filename": "/data/data/org.python/assets/site-packages/platform_wasm/wcwidth.py", "start": 762796, "end": 762796}, {"filename": "/data/data/org.python/assets/site-packages/pygame/__briefcase/__init__.py", "start": 762796, "end": 762796}, {"filename": "/data/data/org.python/assets/site-packages/pygame/__briefcase/meson.build", "start": 762796, "end": 762946}, {"filename": "/data/data/org.python/assets/site-packages/pygame/__briefcase/pygame_ce.py", "start": 762946, "end": 765976}, {"filename": "/data/data/org.python/assets/site-packages/pygame/__init__.py", "start": 765976, "end": 777205}, {"filename": "/data/data/org.python/assets/site-packages/pygame/__pyinstaller/__init__.py", "start": 777205, "end": 777277}, {"filename": "/data/data/org.python/assets/site-packages/pygame/__pyinstaller/hook-pygame.py", "start": 777277, "end": 778646}, {"filename": "/data/data/org.python/assets/site-packages/pygame/__pyinstaller/meson.build", "start": 778646, "end": 778800}, {"filename": "/data/data/org.python/assets/site-packages/pygame/_camera_opencv.py", "start": 778800, "end": 783177}, {"filename": "/data/data/org.python/assets/site-packages/pygame/_data_classes.py", "start": 783177, "end": 783475}, {"filename": "/data/data/org.python/assets/site-packages/pygame/_debug.py", "start": 783475, "end": 789498}, {"filename": "/data/data/org.python/assets/site-packages/pygame/_sdl2/__init__.py", "start": 789498, "end": 789819}, {"filename": "/data/data/org.python/assets/site-packages/pygame/_sdl2/meson.build", "start": 789819, "end": 789960}, {"filename": "/data/data/org.python/assets/site-packages/pygame/_sdl2/window.py", "start": 789960, "end": 790021}, {"filename": "/data/data/org.python/assets/site-packages/pygame/_sprite.py", "start": 790021, "end": 790560}, {"filename": "/data/data/org.python/assets/site-packages/pygame/camera.py", "start": 790560, "end": 795262}, {"filename": "/data/data/org.python/assets/site-packages/pygame/colordict.py", "start": 795262, "end": 821030}, {"filename": "/data/data/org.python/assets/site-packages/pygame/cursors.py", "start": 821030, "end": 844986}, {"filename": "/data/data/org.python/assets/site-packages/pygame/freesansbold.ttf", "start": 844986, "end": 943586}, {"filename": "/data/data/org.python/assets/site-packages/pygame/freetype.py", "start": 943586, "end": 945813}, {"filename": "/data/data/org.python/assets/site-packages/pygame/ftfont.py", "start": 945813, "end": 952995}, {"filename": "/data/data/org.python/assets/site-packages/pygame/locals.py", "start": 952995, "end": 954216}, {"filename": "/data/data/org.python/assets/site-packages/pygame/macosx.py", "start": 954216, "end": 954545}, {"filename": "/data/data/org.python/assets/site-packages/pygame/meson.build", "start": 954545, "end": 955457}, {"filename": "/data/data/org.python/assets/site-packages/pygame/midi.py", "start": 955457, "end": 979798}, {"filename": "/data/data/org.python/assets/site-packages/pygame/pkgdata.py", "start": 979798, "end": 982658}, {"filename": "/data/data/org.python/assets/site-packages/pygame/pygame.ico", "start": 982658, "end": 1128174}, {"filename": "/data/data/org.python/assets/site-packages/pygame/pygame_icon.bmp", "start": 1128174, "end": 1128804}, {"filename": "/data/data/org.python/assets/site-packages/pygame/pygame_icon.icns", "start": 1128804, "end": 1392952}, {"filename": "/data/data/org.python/assets/site-packages/pygame/pygame_icon_mac.bmp", "start": 1392952, "end": 1655234}, {"filename": "/data/data/org.python/assets/site-packages/pygame/sndarray.py", "start": 1655234, "end": 1659320}, {"filename": "/data/data/org.python/assets/site-packages/pygame/sprite.py", "start": 1659320, "end": 1721182}, {"filename": "/data/data/org.python/assets/site-packages/pygame/surfarray.py", "start": 1721182, "end": 1735600}, {"filename": "/data/data/org.python/assets/site-packages/pygame/sysfont.py", "start": 1735600, "end": 1753804}, {"filename": "/data/data/org.python/assets/site-packages/pygame/typing.py", "start": 1753804, "end": 1755823}, {"filename": "/data/data/org.python/assets/site-packages/pygame/version.py", "start": 1755823, "end": 1758259}, {"filename": "/data/data/org.python/assets/site-packages/pyparsing/__init__.py", "start": 1758259, "end": 1767297}, {"filename": "/data/data/org.python/assets/site-packages/pyparsing/actions.py", "start": 1767297, "end": 1774554}, {"filename": "/data/data/org.python/assets/site-packages/pyparsing/common.py", "start": 1774554, "end": 1788227}, {"filename": "/data/data/org.python/assets/site-packages/pyparsing/core.py", "start": 1788227, "end": 2020209}, {"filename": "/data/data/org.python/assets/site-packages/pyparsing/diagram/__init__.py", "start": 2020209, "end": 2046772}, {"filename": "/data/data/org.python/assets/site-packages/pyparsing/exceptions.py", "start": 2046772, "end": 2056658}, {"filename": "/data/data/org.python/assets/site-packages/pyparsing/helpers.py", "start": 2056658, "end": 2096185}, {"filename": "/data/data/org.python/assets/site-packages/pyparsing/py.typed", "start": 2096185, "end": 2096185}, {"filename": "/data/data/org.python/assets/site-packages/pyparsing/results.py", "start": 2096185, "end": 2122431}, {"filename": "/data/data/org.python/assets/site-packages/pyparsing/testing.py", "start": 2122431, "end": 2137113}, {"filename": "/data/data/org.python/assets/site-packages/pyparsing/unicode.py", "start": 2137113, "end": 2147727}, {"filename": "/data/data/org.python/assets/site-packages/pyparsing/util.py", "start": 2147727, "end": 2160702}, {"filename": "/data/data/org.python/assets/site-packages/tomllib/__init__.py", "start": 2160702, "end": 2161010}, {"filename": "/data/data/org.python/assets/site-packages/tomllib/_parser.py", "start": 2161010, "end": 2183507}, {"filename": "/data/data/org.python/assets/site-packages/tomllib/_re.py", "start": 2183507, "end": 2186428}, {"filename": "/data/data/org.python/assets/site-packages/tomllib/_types.py", "start": 2186428, "end": 2186682}, {"filename": "/data/data/org.python/assets/site-packages/typing_extensions.py", "start": 2186682, "end": 2288433}, {"filename": "/usr/lib/python3.14/__future__.py", "start": 2288433, "end": 2293651}, {"filename": "/usr/lib/python3.14/_colorize.py", "start": 2293651, "end": 2295194}, {"filename": "/usr/lib/python3.14/_compat_pickle.py", "start": 2295194, "end": 2303929}, {"filename": "/usr/lib/python3.14/_compression.py", "start": 2303929, "end": 2309610}, {"filename": "/usr/lib/python3.14/_markupbase.py", "start": 2309610, "end": 2324263}, {"filename": "/usr/lib/python3.14/_opcode_metadata.py", "start": 2324263, "end": 2333905}, {"filename": "/usr/lib/python3.14/_pyrepl/__init__.py", "start": 2333905, "end": 2334830}, {"filename": "/usr/lib/python3.14/_pyrepl/pager.py", "start": 2334830, "end": 2340645}, {"filename": "/usr/lib/python3.14/_strptime.py", "start": 2340645, "end": 2370809}, {"filename": "/usr/lib/python3.14/_sysconfigdata__emscripten_wasm32-emscripten.py", "start": 2370809, "end": 2425683}, {"filename": "/usr/lib/python3.14/_weakrefset.py", "start": 2425683, "end": 2429645}, {"filename": "/usr/lib/python3.14/annotationlib.py", "start": 2429645, "end": 2460502}, {"filename": "/usr/lib/python3.14/argparse.py", "start": 2460502, "end": 2563424}, {"filename": "/usr/lib/python3.14/ast.py", "start": 2563424, "end": 2626007}, {"filename": "/usr/lib/python3.14/asyncio/__init__.py", "start": 2626007, "end": 2627305}, {"filename": "/usr/lib/python3.14/asyncio/base_events.py", "start": 2627305, "end": 2707340}, {"filename": "/usr/lib/python3.14/asyncio/base_futures.py", "start": 2707340, "end": 2709314}, {"filename": "/usr/lib/python3.14/asyncio/base_subprocess.py", "start": 2709314, "end": 2718734}, {"filename": "/usr/lib/python3.14/asyncio/base_tasks.py", "start": 2718734, "end": 2721406}, {"filename": "/usr/lib/python3.14/asyncio/constants.py", "start": 2721406, "end": 2722819}, {"filename": "/usr/lib/python3.14/asyncio/coroutines.py", "start": 2722819, "end": 2726476}, {"filename": "/usr/lib/python3.14/asyncio/events.py", "start": 2726476, "end": 2756119}, {"filename": "/usr/lib/python3.14/asyncio/exceptions.py", "start": 2756119, "end": 2757871}, {"filename": "/usr/lib/python3.14/asyncio/format_helpers.py", "start": 2757871, "end": 2760598}, {"filename": "/usr/lib/python3.14/asyncio/futures.py", "start": 2760598, "end": 2774682}, {"filename": "/usr/lib/python3.14/asyncio/locks.py", "start": 2774682, "end": 2795255}, {"filename": "/usr/lib/python3.14/asyncio/log.py", "start": 2795255, "end": 2795379}, {"filename": "/usr/lib/python3.14/asyncio/mixins.py", "start": 2795379, "end": 2795860}, {"filename": "/usr/lib/python3.14/asyncio/protocols.py", "start": 2795860, "end": 2802817}, {"filename": "/usr/lib/python3.14/asyncio/queues.py", "start": 2802817, "end": 2812995}, {"filename": "/usr/lib/python3.14/asyncio/runners.py", "start": 2812995, "end": 2820484}, {"filename": "/usr/lib/python3.14/asyncio/sslproto.py", "start": 2820484, "end": 2852353}, {"filename": "/usr/lib/python3.14/asyncio/staggered.py", "start": 2852353, "end": 2858640}, {"filename": "/usr/lib/python3.14/asyncio/streams.py", "start": 2858640, "end": 2887121}, {"filename": "/usr/lib/python3.14/asyncio/subprocess.py", "start": 2887121, "end": 2894858}, {"filename": "/usr/lib/python3.14/asyncio/taskgroups.py", "start": 2894858, "end": 2904907}, {"filename": "/usr/lib/python3.14/asyncio/tasks.py", "start": 2904907, "end": 2944158}, {"filename": "/usr/lib/python3.14/asyncio/threads.py", "start": 2944158, "end": 2944948}, {"filename": "/usr/lib/python3.14/asyncio/timeouts.py", "start": 2944948, "end": 2950929}, {"filename": "/usr/lib/python3.14/asyncio/transports.py", "start": 2950929, "end": 2961737}, {"filename": "/usr/lib/python3.14/asyncio/trsock.py", "start": 2961737, "end": 2964212}, {"filename": "/usr/lib/python3.14/asyncio/unix_events.py", "start": 2964212, "end": 2999763}, {"filename": "/usr/lib/python3.14/asyncio/wasm_events.py", "start": 2999763, "end": 3056864}, {"filename": "/usr/lib/python3.14/base64.py", "start": 3056864, "end": 3078469}, {"filename": "/usr/lib/python3.14/bisect.py", "start": 3078469, "end": 3081892}, {"filename": "/usr/lib/python3.14/bz2.py", "start": 3081892, "end": 3093861}, {"filename": "/usr/lib/python3.14/calendar.py", "start": 3093861, "end": 3121137}, {"filename": "/usr/lib/python3.14/code.py", "start": 3121137, "end": 3134292}, {"filename": "/usr/lib/python3.14/codeop.py", "start": 3134292, "end": 3140120}, {"filename": "/usr/lib/python3.14/collections/__init__.py", "start": 3140120, "end": 3192889}, {"filename": "/usr/lib/python3.14/colorsys.py", "start": 3192889, "end": 3196951}, {"filename": "/usr/lib/python3.14/compileall.py", "start": 3196951, "end": 3217616}, {"filename": "/usr/lib/python3.14/concurrent/__init__.py", "start": 3217616, "end": 3217654}, {"filename": "/usr/lib/python3.14/concurrent/futures/__init__.py", "start": 3217654, "end": 3219573}, {"filename": "/usr/lib/python3.14/concurrent/futures/_base.py", "start": 3219573, "end": 3242302}, {"filename": "/usr/lib/python3.14/concurrent/futures/thread.py", "start": 3242302, "end": 3252135}, {"filename": "/usr/lib/python3.14/configparser.py", "start": 3252135, "end": 3306503}, {"filename": "/usr/lib/python3.14/contextlib.py", "start": 3306503, "end": 3334304}, {"filename": "/usr/lib/python3.14/contextvars.py", "start": 3334304, "end": 3334502}, {"filename": "/usr/lib/python3.14/copy.py", "start": 3334502, "end": 3343084}, {"filename": "/usr/lib/python3.14/copyreg.py", "start": 3343084, "end": 3350803}, {"filename": "/usr/lib/python3.14/csv.py", "start": 3350803, "end": 3369981}, {"filename": "/usr/lib/python3.14/ctypes/__init__.py", "start": 3369981, "end": 3389443}, {"filename": "/usr/lib/python3.14/ctypes/_endian.py", "start": 3389443, "end": 3392000}, {"filename": "/usr/lib/python3.14/ctypes/util.py", "start": 3392000, "end": 3406252}, {"filename": "/usr/lib/python3.14/curses/__init__.py", "start": 3406252, "end": 3409635}, {"filename": "/usr/lib/python3.14/dataclasses.py", "start": 3409635, "end": 3476650}, {"filename": "/usr/lib/python3.14/datetime.py", "start": 3476650, "end": 3476981}, {"filename": "/usr/lib/python3.14/difflib.py", "start": 3476981, "end": 3560485}, {"filename": "/usr/lib/python3.14/dis.py", "start": 3560485, "end": 3605326}, {"filename": "/usr/lib/python3.14/email/__init__.py", "start": 3605326, "end": 3607085}, {"filename": "/usr/lib/python3.14/email/_encoded_words.py", "start": 3607085, "end": 3615626}, {"filename": "/usr/lib/python3.14/email/_header_value_parser.py", "start": 3615626, "end": 3726019}, {"filename": "/usr/lib/python3.14/email/_parseaddr.py", "start": 3726019, "end": 3743909}, {"filename": "/usr/lib/python3.14/email/_policybase.py", "start": 3743909, "end": 3759444}, {"filename": "/usr/lib/python3.14/email/base64mime.py", "start": 3759444, "end": 3762990}, {"filename": "/usr/lib/python3.14/email/charset.py", "start": 3762990, "end": 3780048}, {"filename": "/usr/lib/python3.14/email/contentmanager.py", "start": 3780048, "end": 3790636}, {"filename": "/usr/lib/python3.14/email/encoders.py", "start": 3790636, "end": 3792409}, {"filename": "/usr/lib/python3.14/email/errors.py", "start": 3792409, "end": 3796218}, {"filename": "/usr/lib/python3.14/email/feedparser.py", "start": 3796218, "end": 3819111}, {"filename": "/usr/lib/python3.14/email/header.py", "start": 3819111, "end": 3843198}, {"filename": "/usr/lib/python3.14/email/headerregistry.py", "start": 3843198, "end": 3864017}, {"filename": "/usr/lib/python3.14/email/iterators.py", "start": 3864017, "end": 3866141}, {"filename": "/usr/lib/python3.14/email/message.py", "start": 3866141, "end": 3914351}, {"filename": "/usr/lib/python3.14/email/parser.py", "start": 3914351, "end": 3919321}, {"filename": "/usr/lib/python3.14/email/policy.py", "start": 3919321, "end": 3929935}, {"filename": "/usr/lib/python3.14/email/quoprimime.py", "start": 3929935, "end": 3939794}, {"filename": "/usr/lib/python3.14/email/utils.py", "start": 3939794, "end": 3955723}, {"filename": "/usr/lib/python3.14/encodings/__init__.py", "start": 3955723, "end": 3961532}, {"filename": "/usr/lib/python3.14/encodings/aliases.py", "start": 3961532, "end": 3977245}, {"filename": "/usr/lib/python3.14/encodings/cp437.py", "start": 3977245, "end": 4011809}, {"filename": "/usr/lib/python3.14/encodings/unicode_escape.py", "start": 4011809, "end": 4013113}, {"filename": "/usr/lib/python3.14/encodings/utf_16.py", "start": 4013113, "end": 4018393}, {"filename": "/usr/lib/python3.14/encodings/utf_8.py", "start": 4018393, "end": 4019398}, {"filename": "/usr/lib/python3.14/encodings/utf_8_sig.py", "start": 4019398, "end": 4023531}, {"filename": "/usr/lib/python3.14/enum.py", "start": 4023531, "end": 4109098}, {"filename": "/usr/lib/python3.14/filecmp.py", "start": 4109098, "end": 4119750}, {"filename": "/usr/lib/python3.14/fnmatch.py", "start": 4119750, "end": 4126019}, {"filename": "/usr/lib/python3.14/fractions.py", "start": 4126019, "end": 4167023}, {"filename": "/usr/lib/python3.14/functools.py", "start": 4167023, "end": 4209913}, {"filename": "/usr/lib/python3.14/getopt.py", "start": 4209913, "end": 4218004}, {"filename": "/usr/lib/python3.14/getpass.py", "start": 4218004, "end": 4224237}, {"filename": "/usr/lib/python3.14/gettext.py", "start": 4224237, "end": 4245772}, {"filename": "/usr/lib/python3.14/glob.py", "start": 4245772, "end": 4265467}, {"filename": "/usr/lib/python3.14/gzip.py", "start": 4265467, "end": 4289560}, {"filename": "/usr/lib/python3.14/hashlib.py", "start": 4289560, "end": 4298922}, {"filename": "/usr/lib/python3.14/heapq.py", "start": 4298922, "end": 4321955}, {"filename": "/usr/lib/python3.14/hmac.py", "start": 4321955, "end": 4329671}, {"filename": "/usr/lib/python3.14/html/__init__.py", "start": 4329671, "end": 4334446}, {"filename": "/usr/lib/python3.14/html/entities.py", "start": 4334446, "end": 4409958}, {"filename": "/usr/lib/python3.14/html/parser.py", "start": 4409958, "end": 4427012}, {"filename": "/usr/lib/python3.14/http/__init__.py", "start": 4427012, "end": 4436271}, {"filename": "/usr/lib/python3.14/http/client.py", "start": 4436271, "end": 4493499}, {"filename": "/usr/lib/python3.14/importlib/__init__.py", "start": 4493499, "end": 4498266}, {"filename": "/usr/lib/python3.14/importlib/_abc.py", "start": 4498266, "end": 4499620}, {"filename": "/usr/lib/python3.14/importlib/abc.py", "start": 4499620, "end": 4506784}, {"filename": "/usr/lib/python3.14/importlib/metadata/__init__.py", "start": 4506784, "end": 4540875}, {"filename": "/usr/lib/python3.14/importlib/metadata/_adapters.py", "start": 4540875, "end": 4543282}, {"filename": "/usr/lib/python3.14/importlib/metadata/_collections.py", "start": 4543282, "end": 4544025}, {"filename": "/usr/lib/python3.14/importlib/metadata/_functools.py", "start": 4544025, "end": 4546920}, {"filename": "/usr/lib/python3.14/importlib/metadata/_itertools.py", "start": 4546920, "end": 4548988}, {"filename": "/usr/lib/python3.14/importlib/metadata/_meta.py", "start": 4548988, "end": 4550789}, {"filename": "/usr/lib/python3.14/importlib/metadata/_text.py", "start": 4550789, "end": 4552955}, {"filename": "/usr/lib/python3.14/importlib/readers.py", "start": 4552955, "end": 4553282}, {"filename": "/usr/lib/python3.14/importlib/resources/__init__.py", "start": 4553282, "end": 4553788}, {"filename": "/usr/lib/python3.14/importlib/resources/_adapters.py", "start": 4553788, "end": 4558270}, {"filename": "/usr/lib/python3.14/importlib/resources/_common.py", "start": 4558270, "end": 4563864}, {"filename": "/usr/lib/python3.14/importlib/resources/_functional.py", "start": 4563864, "end": 4566515}, {"filename": "/usr/lib/python3.14/importlib/resources/_itertools.py", "start": 4566515, "end": 4567792}, {"filename": "/usr/lib/python3.14/importlib/resources/abc.py", "start": 4567792, "end": 4572995}, {"filename": "/usr/lib/python3.14/importlib/resources/readers.py", "start": 4572995, "end": 4578917}, {"filename": "/usr/lib/python3.14/inspect.py", "start": 4578917, "end": 4704494}, {"filename": "/usr/lib/python3.14/ipaddress.py", "start": 4704494, "end": 4785141}, {"filename": "/usr/lib/python3.14/json/__init__.py", "start": 4785141, "end": 4799146}, {"filename": "/usr/lib/python3.14/json/decoder.py", "start": 4799146, "end": 4812018}, {"filename": "/usr/lib/python3.14/json/encoder.py", "start": 4812018, "end": 4828883}, {"filename": "/usr/lib/python3.14/json/scanner.py", "start": 4828883, "end": 4831317}, {"filename": "/usr/lib/python3.14/keyword.py", "start": 4831317, "end": 4832390}, {"filename": "/usr/lib/python3.14/lib-dynload/_ctypes_test.cpython-314-wasm32-emscripten.so", "start": 4832390, "end": 5162330}, {"filename": "/usr/lib/python3.14/lib-dynload/_testexternalinspection.cpython-314-wasm32-emscripten.so", "start": 5162330, "end": 5173927}, {"filename": "/usr/lib/python3.14/lib-dynload/_testimportmultiple.cpython-314-wasm32-emscripten.so", "start": 5173927, "end": 5177560}, {"filename": "/usr/lib/python3.14/lib-dynload/_testmultiphase.cpython-314-wasm32-emscripten.so", "start": 5177560, "end": 5220618}, {"filename": "/usr/lib/python3.14/lib-dynload/_testsinglephase.cpython-314-wasm32-emscripten.so", "start": 5220618, "end": 5246922}, {"filename": "/usr/lib/python3.14/linecache.py", "start": 5246922, "end": 5253340}, {"filename": "/usr/lib/python3.14/locale.py", "start": 5253340, "end": 5330809}, {"filename": "/usr/lib/python3.14/logging/__init__.py", "start": 5330809, "end": 5414523}, {"filename": "/usr/lib/python3.14/logging/handlers.py", "start": 5414523, "end": 5476286}, {"filename": "/usr/lib/python3.14/lzma.py", "start": 5476286, "end": 5489699}, {"filename": "/usr/lib/python3.14/mimetypes.py", "start": 5489699, "end": 5514404}, {"filename": "/usr/lib/python3.14/multiprocessing/__init__.py", "start": 5514404, "end": 5515320}, {"filename": "/usr/lib/python3.14/multiprocessing/connection.py", "start": 5515320, "end": 5557495}, {"filename": "/usr/lib/python3.14/multiprocessing/context.py", "start": 5557495, "end": 5569259}, {"filename": "/usr/lib/python3.14/multiprocessing/process.py", "start": 5569259, "end": 5581314}, {"filename": "/usr/lib/python3.14/multiprocessing/reduction.py", "start": 5581314, "end": 5590944}, {"filename": "/usr/lib/python3.14/multiprocessing/util.py", "start": 5590944, "end": 5604888}, {"filename": "/usr/lib/python3.14/numbers.py", "start": 5604888, "end": 5616355}, {"filename": "/usr/lib/python3.14/opcode.py", "start": 5616355, "end": 5619398}, {"filename": "/usr/lib/python3.14/operator.py", "start": 5619398, "end": 5630556}, {"filename": "/usr/lib/python3.14/optparse.py", "start": 5630556, "end": 5690725}, {"filename": "/usr/lib/python3.14/pathlib/__init__.py", "start": 5690725, "end": 5690980}, {"filename": "/usr/lib/python3.14/pathlib/_abc.py", "start": 5690980, "end": 5712078}, {"filename": "/usr/lib/python3.14/pathlib/_local.py", "start": 5712078, "end": 5757687}, {"filename": "/usr/lib/python3.14/pathlib/_os.py", "start": 5757687, "end": 5762698}, {"filename": "/usr/lib/python3.14/pickle.py", "start": 5762698, "end": 5833059}, {"filename": "/usr/lib/python3.14/pkgutil.py", "start": 5833059, "end": 5849159}, {"filename": "/usr/lib/python3.14/platform.py", "start": 5849159, "end": 5896805}, {"filename": "/usr/lib/python3.14/plistlib.py", "start": 5896805, "end": 5926599}, {"filename": "/usr/lib/python3.14/pprint.py", "start": 5926599, "end": 5951011}, {"filename": "/usr/lib/python3.14/py_compile.py", "start": 5951011, "end": 5958848}, {"filename": "/usr/lib/python3.14/pydoc.py", "start": 5958848, "end": 6069271}, {"filename": "/usr/lib/python3.14/queue.py", "start": 6069271, "end": 6082752}, {"filename": "/usr/lib/python3.14/quopri.py", "start": 6082752, "end": 6089911}, {"filename": "/usr/lib/python3.14/random.py", "start": 6089911, "end": 6126911}, {"filename": "/usr/lib/python3.14/re/__init__.py", "start": 6126911, "end": 6144787}, {"filename": "/usr/lib/python3.14/re/_casefix.py", "start": 6144787, "end": 6150231}, {"filename": "/usr/lib/python3.14/re/_compiler.py", "start": 6150231, "end": 6177086}, {"filename": "/usr/lib/python3.14/re/_constants.py", "start": 6177086, "end": 6183122}, {"filename": "/usr/lib/python3.14/re/_parser.py", "start": 6183122, "end": 6223416}, {"filename": "/usr/lib/python3.14/reprlib.py", "start": 6223416, "end": 6230608}, {"filename": "/usr/lib/python3.14/secrets.py", "start": 6230608, "end": 6232592}, {"filename": "/usr/lib/python3.14/selectors.py", "start": 6232592, "end": 6252049}, {"filename": "/usr/lib/python3.14/shlex.py", "start": 6252049, "end": 6265402}, {"filename": "/usr/lib/python3.14/shutil.py", "start": 6265402, "end": 6323160}, {"filename": "/usr/lib/python3.14/signal.py", "start": 6323160, "end": 6325655}, {"filename": "/usr/lib/python3.14/socket.py", "start": 6325655, "end": 6362779}, {"filename": "/usr/lib/python3.14/sqlite3/__init__.py", "start": 6362779, "end": 6364793}, {"filename": "/usr/lib/python3.14/sqlite3/dbapi2.py", "start": 6364793, "end": 6367913}, {"filename": "/usr/lib/python3.14/ssl.py", "start": 6367913, "end": 6420628}, {"filename": "/usr/lib/python3.14/string.py", "start": 6420628, "end": 6432414}, {"filename": "/usr/lib/python3.14/struct.py", "start": 6432414, "end": 6432699}, {"filename": "/usr/lib/python3.14/subprocess.py", "start": 6432699, "end": 6521801}, {"filename": "/usr/lib/python3.14/sysconfig/__init__.py", "start": 6521801, "end": 6549016}, {"filename": "/usr/lib/python3.14/tarfile.py", "start": 6549016, "end": 6659299}, {"filename": "/usr/lib/python3.14/tempfile.py", "start": 6659299, "end": 6691984}, {"filename": "/usr/lib/python3.14/textwrap.py", "start": 6691984, "end": 6711917}, {"filename": "/usr/lib/python3.14/threading.py", "start": 6711917, "end": 6767452}, {"filename": "/usr/lib/python3.14/token.py", "start": 6767452, "end": 6769941}, {"filename": "/usr/lib/python3.14/tokenize.py", "start": 6769941, "end": 6791007}, {"filename": "/usr/lib/python3.14/tomllib/__init__.py", "start": 6791007, "end": 6791315}, {"filename": "/usr/lib/python3.14/tomllib/_parser.py", "start": 6791315, "end": 6815755}, {"filename": "/usr/lib/python3.14/tomllib/_re.py", "start": 6815755, "end": 6818883}, {"filename": "/usr/lib/python3.14/tomllib/_types.py", "start": 6818883, "end": 6819137}, {"filename": "/usr/lib/python3.14/trace.py", "start": 6819137, "end": 6848804}, {"filename": "/usr/lib/python3.14/traceback.py", "start": 6848804, "end": 6914005}, {"filename": "/usr/lib/python3.14/tty.py", "start": 6914005, "end": 6916040}, {"filename": "/usr/lib/python3.14/types.py", "start": 6916040, "end": 6927247}, {"filename": "/usr/lib/python3.14/typing.py", "start": 6927247, "end": 7060791}, {"filename": "/usr/lib/python3.14/unittest/__init__.py", "start": 7060791, "end": 7064037}, {"filename": "/usr/lib/python3.14/unittest/case.py", "start": 7064037, "end": 7127715}, {"filename": "/usr/lib/python3.14/unittest/loader.py", "start": 7127715, "end": 7148535}, {"filename": "/usr/lib/python3.14/unittest/main.py", "start": 7148535, "end": 7160167}, {"filename": "/usr/lib/python3.14/unittest/result.py", "start": 7160167, "end": 7169364}, {"filename": "/usr/lib/python3.14/unittest/runner.py", "start": 7169364, "end": 7181059}, {"filename": "/usr/lib/python3.14/unittest/signals.py", "start": 7181059, "end": 7183462}, {"filename": "/usr/lib/python3.14/unittest/suite.py", "start": 7183462, "end": 7196974}, {"filename": "/usr/lib/python3.14/unittest/util.py", "start": 7196974, "end": 7202189}, {"filename": "/usr/lib/python3.14/urllib/__init__.py", "start": 7202189, "end": 7202189}, {"filename": "/usr/lib/python3.14/urllib/error.py", "start": 7202189, "end": 7204604}, {"filename": "/usr/lib/python3.14/urllib/parse.py", "start": 7204604, "end": 7250830}, {"filename": "/usr/lib/python3.14/urllib/request.py", "start": 7250830, "end": 7326011}, {"filename": "/usr/lib/python3.14/urllib/response.py", "start": 7326011, "end": 7328372}, {"filename": "/usr/lib/python3.14/uuid.py", "start": 7328372, "end": 7359869}, {"filename": "/usr/lib/python3.14/warnings.py", "start": 7359869, "end": 7386808}, {"filename": "/usr/lib/python3.14/weakref.py", "start": 7386808, "end": 7404579}, {"filename": "/usr/lib/python3.14/webbrowser.py", "start": 7404579, "end": 7428840}, {"filename": "/usr/lib/python3.14/xml/__init__.py", "start": 7428840, "end": 7429397}, {"filename": "/usr/lib/python3.14/xml/dom/NodeFilter.py", "start": 7429397, "end": 7430333}, {"filename": "/usr/lib/python3.14/xml/dom/__init__.py", "start": 7430333, "end": 7434366}, {"filename": "/usr/lib/python3.14/xml/dom/domreg.py", "start": 7434366, "end": 7437817}, {"filename": "/usr/lib/python3.14/xml/dom/expatbuilder.py", "start": 7437817, "end": 7473510}, {"filename": "/usr/lib/python3.14/xml/dom/minicompat.py", "start": 7473510, "end": 7476877}, {"filename": "/usr/lib/python3.14/xml/dom/minidom.py", "start": 7476877, "end": 7545491}, {"filename": "/usr/lib/python3.14/xml/dom/xmlbuilder.py", "start": 7545491, "end": 7557911}, {"filename": "/usr/lib/python3.14/xml/etree/ElementPath.py", "start": 7557911, "end": 7571908}, {"filename": "/usr/lib/python3.14/xml/etree/ElementTree.py", "start": 7571908, "end": 7646217}, {"filename": "/usr/lib/python3.14/xml/etree/__init__.py", "start": 7646217, "end": 7647822}, {"filename": "/usr/lib/python3.14/xml/parsers/__init__.py", "start": 7647822, "end": 7647989}, {"filename": "/usr/lib/python3.14/xml/parsers/expat.py", "start": 7647989, "end": 7648237}, {"filename": "/usr/lib/python3.14/zipfile/__init__.py", "start": 7648237, "end": 7737272}, {"filename": "/usr/lib/python3.14/zipfile/_path/__init__.py", "start": 7737272, "end": 7749058}, {"filename": "/usr/lib/python3.14/zipfile/_path/glob.py", "start": 7749058, "end": 7752373}, {"filename": "/usr/lib/python3.14/zoneinfo/__init__.py", "start": 7752373, "end": 7753076}, {"filename": "/usr/lib/python3.14/zoneinfo/_common.py", "start": 7753076, "end": 7758370}, {"filename": "/usr/lib/python3.14/zoneinfo/_tzpath.py", "start": 7758370, "end": 7763758}], "remote_package_size": 4389374});

  })();

// end include: /tmp/tmpaib0rxle.js


// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = Object.assign({}, Module);

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = (status, toThrow) => {
  throw toThrow;
};

// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var readAsync, readBinary;

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (typeof document != 'undefined' && document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
  // they are removed because they could contain a slash.
  if (scriptDirectory.startsWith('blob:')) {
    scriptDirectory = '';
  } else {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/')+1);
  }

  {
// include: web_or_worker_shell_read.js
readAsync = async (url) => {
    var response = await fetch(url, { credentials: 'same-origin' });
    if (response.ok) {
      return response.arrayBuffer();
    }
    throw new Error(response.status + ' : ' + response.url);
  };
// end include: web_or_worker_shell_read.js
  }
} else
{
}

var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.error.bind(console);

// Merge back in the overrides
Object.assign(Module, moduleOverrides);
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used.
moduleOverrides = null;

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.

if (Module['arguments']) arguments_ = Module['arguments'];

if (Module['thisProgram']) thisProgram = Module['thisProgram'];

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
// end include: shell.js

// include: preamble.js
// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var dynamicLibraries = Module['dynamicLibraries'] || [];

var wasmBinary = Module['wasmBinary'];

// include: base64Utils.js
// Converts a string of base64 into a byte array (Uint8Array).
function intArrayFromBase64(s) {

  var decoded = atob(s);
  var bytes = new Uint8Array(decoded.length);
  for (var i = 0 ; i < decoded.length ; ++i) {
    bytes[i] = decoded.charCodeAt(i);
  }
  return bytes;
}

// If filename is a base64 data URI, parses and returns data (Buffer on node,
// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
function tryParseAsDataURI(filename) {
  if (!isDataURI(filename)) {
    return;
  }

  return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}
// end include: base64Utils.js
// Wasm globals

var wasmMemory;

//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;

// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we
// don't define it at all in release modes.  This matches the behaviour of
// MINIMAL_RUNTIME.
// TODO(sbc): Make this the default even without STRICT enabled.
/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    // This build was created without ASSERTIONS defined.  `assert()` should not
    // ever be called in this configuration but in case there are callers in
    // the wild leave this simple abort() implementation here for now.
    abort(text);
  }
}

// Memory management

var HEAP,
/** @type {!Int8Array} */
  HEAP8,
/** @type {!Uint8Array} */
  HEAPU8,
/** @type {!Int16Array} */
  HEAP16,
/** @type {!Uint16Array} */
  HEAPU16,
/** @type {!Int32Array} */
  HEAP32,
/** @type {!Uint32Array} */
  HEAPU32,
/** @type {!Float32Array} */
  HEAPF32,
/* BigInt64Array type is not correctly defined in closure
/** not-@type {!BigInt64Array} */
  HEAP64,
/* BigUint64Array type is not correctly defined in closure
/** not-t@type {!BigUint64Array} */
  HEAPU64,
/** @type {!Float64Array} */
  HEAPF64;

// include: runtime_shared.js
function updateMemoryViews() {
  var b = wasmMemory.buffer;
  Module['HEAP8'] = HEAP8 = new Int8Array(b);
  Module['HEAP16'] = HEAP16 = new Int16Array(b);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);
  Module['HEAP32'] = HEAP32 = new Int32Array(b);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(b);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(b);
  Module['HEAP64'] = HEAP64 = new BigInt64Array(b);
  Module['HEAPU64'] = HEAPU64 = new BigUint64Array(b);
}

// end include: runtime_shared.js
// In non-standalone/normal mode, we create the memory here.
// include: runtime_init_memory.js
// Create the wasm memory. (Note: this only applies if IMPORTED_MEMORY is defined)

// check for full engine support (use string 'subarray' to avoid closure compiler confusion)

  if (Module['wasmMemory']) {
    wasmMemory = Module['wasmMemory'];
  } else
  {
    var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 268435456;

    /** @suppress {checkTypes} */
    wasmMemory = new WebAssembly.Memory({
      'initial': INITIAL_MEMORY / 65536,
      // In theory we should not need to emit the maximum if we want "unlimited"
      // or 4GB of memory, but VMs error on that atm, see
      // https://github.com/emscripten-core/emscripten/issues/14130
      // And in the pthreads case we definitely need to emit a maximum. So
      // always emit one.
      'maximum': 32768,
    });
  }

  updateMemoryViews();

// end include: runtime_init_memory.js

// include: runtime_stack_check.js
// end include: runtime_stack_check.js
var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var __RELOC_FUNCS__ = [];

var runtimeInitialized = false;

function preRun() {
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  runtimeInitialized = true;

  callRuntimeCallbacks(__RELOC_FUNCS__);
  
if (!Module['noFSInit'] && !FS.initialized)
  FS.init();
FS.ignorePermissions = false;

TTY.init();
SOCKFS.root = FS.mount(SOCKFS, {}, null);
PIPEFS.root = FS.mount(PIPEFS, {}, null);
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  
  callRuntimeCallbacks(__ATMAIN__);
}

function postRun() {

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

// include: runtime_math.js
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc

// end include: runtime_math.js
// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;

  Module['monitorRunDependencies']?.(runDependencies);

}

function removeRunDependency(id) {
  runDependencies--;

  Module['monitorRunDependencies']?.(runDependencies);

  if (runDependencies == 0) {
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

/** @param {string|number=} what */
function abort(what) {
  Module['onAbort']?.(what);

  what = 'Aborted(' + what + ')';
  // TODO(sbc): Should we remove printing and leave it up to whoever
  // catches the exception?
  err(what);

  ABORT = true;

  what += '. Build with -sASSERTIONS for more info.';

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  // FIXME This approach does not work in Wasm EH because it currently does not assume
  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
  // a trap or not based on a hidden field within the object. So at the moment
  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
  // allows this in the wasm spec.

  // Suppress closure compiler warning here. Closure compiler's builtin extern
  // definition for WebAssembly.RuntimeError claims it takes no arguments even
  // though it can.
  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
  /** @suppress {checkTypes} */
  var e = new WebAssembly.RuntimeError(what);

  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

// include: memoryprofiler.js
// end include: memoryprofiler.js
// include: URIUtils.js
// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

/**
 * Indicates whether filename is a base64 data URI.
 * @noinline
 */
var isDataURI = (filename) => filename.startsWith(dataURIPrefix);

/**
 * Indicates whether filename is delivered via file protocol (as opposed to http/https)
 * @noinline
 */
var isFileURI = (filename) => filename.startsWith('file://');
// end include: URIUtils.js
// include: runtime_exceptions.js
// end include: runtime_exceptions.js
function findWasmBinary() {
    var f = 'main.wasm';
    if (!isDataURI(f)) {
      return locateFile(f);
    }
    return f;
}

var wasmBinaryFile;

function getBinarySync(file) {
  if (file == wasmBinaryFile && wasmBinary) {
    return new Uint8Array(wasmBinary);
  }
  if (readBinary) {
    return readBinary(file);
  }
  throw 'both async and sync fetching of the wasm failed';
}

async function getWasmBinary(binaryFile) {
  // If we don't have the binary yet, load it asynchronously using readAsync.
  if (!wasmBinary
      ) {
    // Fetch the binary using readAsync
    try {
      var response = await readAsync(binaryFile);
      return new Uint8Array(response);
    } catch {
      // Fall back to getBinarySync below;
    }
  }

  // Otherwise, getBinarySync should be able to get it synchronously
  return getBinarySync(binaryFile);
}

async function instantiateArrayBuffer(binaryFile, imports) {
  try {
    var binary = await getWasmBinary(binaryFile);
    var instance = await WebAssembly.instantiate(binary, imports);
    return instance;
  } catch (reason) {
    err(`failed to asynchronously prepare wasm: ${reason}`);

    abort(reason);
  }
}

async function instantiateAsync(binary, binaryFile, imports) {
  if (!binary &&
      typeof WebAssembly.instantiateStreaming == 'function' &&
      !isDataURI(binaryFile) &&
      typeof fetch == 'function') {
    try {
      var response = fetch(binaryFile, { credentials: 'same-origin' });
      var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
      return instantiationResult;
    } catch (reason) {
      // We expect the most common failure cause to be a bad MIME type for the binary,
      // in which case falling back to ArrayBuffer instantiation should work.
      err(`wasm streaming compile failed: ${reason}`);
      err('falling back to ArrayBuffer instantiation');
      // fall back of instantiateArrayBuffer below
    };
  }
  return instantiateArrayBuffer(binaryFile, imports);
}

function getWasmImports() {
  // prepare imports
  return {
    'env': wasmImports,
    'wasi_snapshot_preview1': wasmImports,
    'GOT.mem': new Proxy(wasmImports, GOTHandler),
    'GOT.func': new Proxy(wasmImports, GOTHandler),
  }
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
async function createWasm() {
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    wasmExports = instance.exports;

    wasmExports = relocateExports(wasmExports, 1024);

    var metadata = getDylinkMetadata(module);
    if (metadata.neededDynlibs) {
      dynamicLibraries = metadata.neededDynlibs.concat(dynamicLibraries);
    }
    mergeLibSymbols(wasmExports, 'main')
    LDSO.init();
    loadDylibs();

    

    addOnInit(wasmExports['__wasm_call_ctors']);

    __RELOC_FUNCS__.push(wasmExports['__wasm_apply_data_relocs']);

    removeRunDependency('wasm-instantiate');
    return wasmExports;
  }
  // wait for the pthread pool (if any)
  addRunDependency('wasm-instantiate');

  // Prefer streaming instantiation if available.
  function receiveInstantiationResult(result) {
    // 'result' is a ResultObject object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    receiveInstance(result['instance'], result['module']);
  }

  var info = getWasmImports();

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to
  // run the instantiation parallel to any other async startup actions they are
  // performing.
  // Also pthreads and wasm workers initialize the wasm instance through this
  // path.
  if (Module['instantiateWasm']) {
    try {
      return Module['instantiateWasm'](info, receiveInstance);
    } catch(e) {
      err(`Module.instantiateWasm callback failed with error: ${e}`);
        return false;
    }
  }

  wasmBinaryFile ??= findWasmBinary();

    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    receiveInstantiationResult(result);
    return result;
}

// include: runtime_debug.js
// end include: runtime_debug.js
// === Body ===

var ASM_CONSTS = {
  4160845: ($0, $1, $2) => { setValue($0, Emval.toHandle(window), '*'); setValue($1, Emval.toHandle(console), '*'); setValue($2, Emval.toHandle(document), '*'); window.__py_alive = new Set(); },  
 4161012: ($0, $1, $2, $3) => { globalThis.FD_BUFFER_MAX = $0; globalThis.shm_stdin = $1; globalThis.shm_rawinput = $2; globalThis.shm_rcon = $3; Module.printErr = Module.print; globalThis.is_worker = (typeof WorkerGlobalScope !== 'undefined') && self instanceof WorkerGlobalScope; function jswasm_load(script, aio) { if (!aio) aio=false; const jswasmloader=document.createElement("script"); jswasmloader.setAttribute("type","text/javascript"); jswasmloader.setAttribute("src", script); jswasmloader.setAttribute("async", aio); document.getElementsByTagName("head")[0].appendChild(jswasmloader); }; if (is_worker) { console.log("PyMain: running in a worker, setting onCustomMessage"); function onCustomMessage(event) { console.log("onCustomMessage:", event); stringToUTF8( utf8encode(data), shm_rcon, $0); }; Module['onCustomMessage'] = onCustomMessage; } else { console.log("PyMain: running in main thread, faking onCustomMessage"); Module.postMessage = function custom_postMessage(event) { switch (event.type) { case "raw" : { stringToUTF8( event.data, shm_rawinput, FD_BUFFER_MAX); break; } case "stdin" : { stringToUTF8( event.data, shm_stdin, FD_BUFFER_MAX); break; } case "rcon" : { stringToUTF8( event.data, shm_rcon, FD_BUFFER_MAX); break; } default : console.warn("custom_postMessage?", event); } }; } if (!is_worker) { if (typeof window === 'undefined') { if (FS) console.warn("PyMain: Running in Node ?"); else console.error("PyMain: not Node"); } else { if (window.BrowserFS) { console.log("PyMain: found BrowserFS"); } else { console.error("PyMain: BrowserFS not found"); } } } },  
 4162575: ($0, $1, $2, $3) => { var _url = UTF8ToString($0); var _file = UTF8ToString($1); _file = PATH_FS.resolve(_file); function doCallback(callback, other) { var stack = stackSave(); __wget_callback(callback, other, allocate(intArrayFromString(_file), ALLOC_STACK)); stackRestore(stack); } var destinationDirectory = PATH.dirname(_file); FS.createPreloadedFile( destinationDirectory, PATH.basename(_file), _url, true, true, function() { doCallback($2, $3); }, function() { doCallback($3, $2); }, false, false, function() { try { FS.unlink(_file); } catch (e) {} FS.mkdirTree(destinationDirectory); } ); },  
 4163154: ($0, $1, $2, $3) => { var http = (Browser.wgetRequests || wget.wgetRequests)[$0]; http.__py_onload = $1; http.__py_onerror = $2; http.__py_onprogress = $3; },  
 4163292: ($0, $1, $2, $3) => { var http = (Browser.wgetRequests || wget.wgetRequests)[$0]; if (http) { setValue($1, http.__py_onload, 'i32'); setValue($2, http.__py_onerror, 'i32'); setValue($3, http.__py_onprogress, 'i32'); http.__py_onload = 0; http.__py_onerror = 0; http.__py_onprogress = 0; } },  
 4163563: ($0) => { var http = (Browser.wgetRequests || wget.wgetRequests)[$0]; return http ? http.__py_onprogress : 0; },  
 4163667: ($0, $1, $2, $3) => { var http = (Browser.wgetRequests || wget.wgetRequests)[$0]; http.__py_onload = $1; http.__py_onerror = $2; http.__py_onprogress = $3; },  
 4163805: ($0) => { var http = (Browser.wgetRequests || wget.wgetRequests)[$0]; return http ? http.__py_onprogress : 0; },  
 4163909: ($0) => { return Emval.toHandle($0) },  
 4163935: ($0) => { return Emval.toHandle($0) },  
 4163961: function($0, $1, $2, $3) { __py_alive.add($0); return Emval.toHandle(function() { if (__py_alive.has($0)) { var argc = arguments.length; if ($3 >= 0 && argc > $3) { argc = $3; } var argv = _malloc(argc * 4); for (var i = 0; i < argc; ++i) { setValue(argv+i*4, Emval.toHandle(arguments[i]), 'i32'); } var result = __py_call($1, $2, Emval.toHandle(this), argc, argv); return Emval.toValue(result); } }); },  
 4164340: ($0) => { __py_alive.delete($0) },  
 4164362: ($0, $1) => { var exc = Emval.toValue($0); try { if (exc.message) { stringToUTF8(exc.message, $1, 512); } if (exc instanceof TypeError) { return 1; } if (exc instanceof SyntaxError) { return 2; } return 0; } finally { __emval_decref($0); } },  
 4164592: ($0, $1) => { var value = Emval.toValue($0); var type = typeof value; if (type === "number") { if ((value | 0) === value) { setValue($1, value, "i32"); __emval_decref($0); return 1; } else { setValue($1, value, "double"); __emval_decref($0); return 2; } } else if (type === "string") { var len = lengthBytesUTF8(value) + 1; var buffer = _malloc(len); stringToUTF8(value, buffer, len); __emval_decref($0); setValue($1, buffer, "*"); return 3; } else if (type === "function") { return 4; } else if (type === "symbol") { return 5; } else { return 6; } },  
 4165133: ($0, $1) => { var value = Emval.toValue($0); if (value && typeof value.then === "function") { value.then(function (result) { __py_notify_done($1, Emval.toHandle(result)); }, function (error) { __py_notify_done($1, -Emval.toHandle(error)); }); return 0; } else { __emval_incref($0); return $0; } },  
 4165418: ($0) => { var value = Emval.toValue($0); var str = value.constructor ? value.constructor.name : 'Object'; var len = lengthBytesUTF8(str) + 1; var buffer = _malloc(len); stringToUTF8(str, buffer, len); return buffer; },  
 4165628: ($0) => { var val = Emval.toValue($0); if (val[Symbol.iterator] && val.length !== undefined) { return val.length; } else { return -1; } },  
 4165758: ($0) => { var str = Emval.toValue($0).toString(); var len = lengthBytesUTF8(str) + 1; var buffer = _malloc(len); stringToUTF8(str, buffer, len); return buffer; },  
 4165912: ($0, $1) => { try { return Emval.toHandle(Emval.toValue($0)[Emval.toValue($1)]); } catch (ex) { return -Emval.toHandle(ex); } finally { __emval_decref($1); } },  
 4166060: ($0) => { var val = Emval.toValue($0); if (val[Symbol.iterator]) { return Emval.toHandle(val[Symbol.iterator]()); } else { return 0; } },  
 4166189: ($0) => { var val = Emval.toValue($0); if (!val.next) { return 0; } var result = val.next(); if (result && !result.done) { return Emval.toHandle(result.value); } else { return 0; } },  
 4166364: ($0) => { var props = []; for (var prop in Emval.toValue($0)) { props.push(prop); } return Emval.toHandle(props); },  
 4166472: ($0, $1) => { try { return Emval.toHandle(Emval.toValue($0).call(Emval.toValue($1))); } catch (ex) { return -Emval.toHandle(ex); } },  
 4166592: ($0, $1, $2) => { try { return Emval.toHandle(Emval.toValue($0).call(Emval.toValue($1), Emval.toValue($2))); } catch (ex) { return -Emval.toHandle(ex); } finally { __emval_decref($2); } },  
 4166764: ($0, $1, $2, $3) => { var arg_handles = []; try { var arg_values = []; for (var i = 0; i < $2; ++i) { var arg_handle = getValue($3+i*4, '*'); arg_handles.push(arg_handle); arg_values.push(Emval.toValue(arg_handle)); } return Emval.toHandle(Emval.toValue($0).apply(Emval.toValue($1), arg_values)); } catch (ex) { return -Emval.toHandle(ex); } finally { for (var i = 0; i < $2; ++i) { __emval_decref(arg_handles[i]); } } },  
 4167165: ($0) => { var str = Emval.toValue($0).description; var len = lengthBytesUTF8(str) + 1; var buffer = _malloc(len); stringToUTF8(str, buffer, len); return buffer; },  
 4167320: ($0) => { try { return Emval.toHandle(window[Emval.toValue($0)]); } catch (ex) { return -Emval.toHandle(ex); } finally { __emval_decref($0); } },  
 4167457: ($0) => { alert(UTF8ToString($0)) },  
 4167481: ($0) => { try { return Emval.toHandle(eval(Emval.toValue($0))); } catch (ex) { return -Emval.toHandle(ex); } finally { __emval_decref($0); } },  
 4167616: ($0) => { return confirm(UTF8ToString($0)); },  
 4167654: ($0, $1) => { var str = prompt(UTF8ToString($0), $1 ? UTF8ToString($1) : undefined); if (str === null) { return 0; } var len = lengthBytesUTF8(str) + 1; var buffer = _malloc(len); stringToUTF8(str, buffer, len); return buffer; },  
 4167871: ($0, $1) => { FS.symlink( UTF8ToString($0), UTF8ToString($1)); },  
 4167924: ($0) => { eval(UTF8ToString($0)); },  
 4167952: ($0) => { console.warn(UTF8ToString($0)); },  
 4167988: ($0) => { console.error(UTF8ToString($0)); },  
 4168025: ($0) => { if (!$0) { AL.alcErr = 0xA004 ; return 1; } },  
 4168073: ($0) => { if (!AL.currentCtx) { err("alGetProcAddress() called without a valid context"); return 1; } if (!$0) { AL.currentCtx.err = 0xA003 ; return 1; } }
};
function _Py_emscripten_runtime() { var info; if (typeof navigator == 'object') { info = navigator.userAgent; } else if (typeof process == 'object') { info = "Node.js ".concat(process.version) } else { info = "UNKNOWN" } var len = lengthBytesUTF8(info) + 1; var res = _malloc(len); stringToUTF8(info, res, len); return res; }
_Py_emscripten_runtime.sig = 'i';
function unbox_small_structs(type_ptr) { var type_id = HEAPU16[(type_ptr + 6 >> 1) + 0]; while (type_id === 13) { if (HEAPU32[(type_ptr >> 2) + 0] > 16) { break; } var elements = HEAPU32[(type_ptr + 8 >> 2) + 0]; var first_element = HEAPU32[(elements >> 2) + 0]; if (first_element === 0) { type_id = 0; break; } else if (HEAPU32[(elements >> 2) + 1] === 0) { type_ptr = first_element; type_id = HEAPU16[(first_element + 6 >> 1) + 0]; } else { break; } } return [type_ptr, type_id]; }
function ffi_call_js(cif,fn,rvalue,avalue) { var abi = HEAPU32[(cif >> 2) + 0]; var nargs = HEAPU32[(cif >> 2) + 1]; var nfixedargs = HEAPU32[(cif >> 2) + 6]; var arg_types_ptr = HEAPU32[(cif >> 2) + 2]; var rtype_unboxed = unbox_small_structs(HEAPU32[(cif >> 2) + 3]); var rtype_ptr = rtype_unboxed[0]; var rtype_id = rtype_unboxed[1]; var orig_stack_ptr = stackSave(); var cur_stack_ptr = orig_stack_ptr; var args = []; var ret_by_arg = 0; if (rtype_id === 15) { throw new Error('complex ret marshalling nyi'); } if (rtype_id < 0 || rtype_id > 15) { throw new Error('Unexpected rtype ' + rtype_id); } if (rtype_id === 4 || rtype_id === 13) { args.push(rvalue); ret_by_arg = 1; } for (var i = 0; i < nfixedargs; i++) { var arg_ptr = HEAPU32[(avalue >> 2) + i]; var arg_unboxed = unbox_small_structs(HEAPU32[(arg_types_ptr >> 2) + i]); var arg_type_ptr = arg_unboxed[0]; var arg_type_id = arg_unboxed[1]; switch (arg_type_id) { case 1: case 10: case 9: case 14: args.push(HEAPU32[(arg_ptr >> 2) + 0]); break; case 2: args.push(HEAPF32[(arg_ptr >> 2) + 0]); break; case 3: args.push(HEAPF64[(arg_ptr >> 3) + 0]); break; case 5: args.push(HEAPU8[arg_ptr + 0]); break; case 6: args.push(HEAP8[arg_ptr + 0]); break; case 7: args.push(HEAPU16[(arg_ptr >> 1) + 0]); break; case 8: args.push(HEAP16[(arg_ptr >> 1) + 0]); break; case 11: case 12: args.push(HEAPU64[(arg_ptr >> 3) + 0]); break; case 4: args.push(HEAPU64[(arg_ptr >> 3) + 0]); args.push(HEAPU64[(arg_ptr >> 3) + 1]); break; case 13: var size = HEAPU32[(arg_type_ptr >> 2) + 0]; var align = HEAPU16[(arg_type_ptr + 4 >> 1) + 0]; ((cur_stack_ptr -= (size)), (cur_stack_ptr &= (~((align) - 1)))); HEAP8.subarray(cur_stack_ptr, cur_stack_ptr+size).set(HEAP8.subarray(arg_ptr, arg_ptr + size)); args.push(cur_stack_ptr); break; case 15: throw new Error('complex marshalling nyi'); default: throw new Error('Unexpected type ' + arg_type_id); } } if (nfixedargs != nargs) { var struct_arg_info = []; for (var i = nargs - 1; i >= nfixedargs; i--) { var arg_ptr = HEAPU32[(avalue >> 2) + i]; var arg_unboxed = unbox_small_structs(HEAPU32[(arg_types_ptr >> 2) + i]); var arg_type_ptr = arg_unboxed[0]; var arg_type_id = arg_unboxed[1]; switch (arg_type_id) { case 5: case 6: ((cur_stack_ptr -= (1)), (cur_stack_ptr &= (~((1) - 1)))); HEAPU8[cur_stack_ptr + 0] = HEAPU8[arg_ptr + 0]; break; case 7: case 8: ((cur_stack_ptr -= (2)), (cur_stack_ptr &= (~((2) - 1)))); HEAPU16[(cur_stack_ptr >> 1) + 0] = HEAPU16[(arg_ptr >> 1) + 0]; break; case 1: case 9: case 10: case 14: case 2: ((cur_stack_ptr -= (4)), (cur_stack_ptr &= (~((4) - 1)))); HEAPU32[(cur_stack_ptr >> 2) + 0] = HEAPU32[(arg_ptr >> 2) + 0]; break; case 3: case 11: case 12: ((cur_stack_ptr -= (8)), (cur_stack_ptr &= (~((8) - 1)))); HEAPU32[(cur_stack_ptr >> 2) + 0] = HEAPU32[(arg_ptr >> 2) + 0]; HEAPU32[(cur_stack_ptr >> 2) + 1] = HEAPU32[(arg_ptr >> 2) + 1]; break; case 4: ((cur_stack_ptr -= (16)), (cur_stack_ptr &= (~((8) - 1)))); HEAPU32[(cur_stack_ptr >> 2) + 0] = HEAPU32[(arg_ptr >> 2) + 0]; HEAPU32[(cur_stack_ptr >> 2) + 1] = HEAPU32[(arg_ptr >> 2) + 1]; HEAPU32[(cur_stack_ptr >> 2) + 2] = HEAPU32[(arg_ptr >> 2) + 2]; HEAPU32[(cur_stack_ptr >> 2) + 3] = HEAPU32[(arg_ptr >> 2) + 3]; break; case 13: ((cur_stack_ptr -= (4)), (cur_stack_ptr &= (~((4) - 1)))); struct_arg_info.push([cur_stack_ptr, arg_ptr, HEAPU32[(arg_type_ptr >> 2) + 0], HEAPU16[(arg_type_ptr + 4 >> 1) + 0]]); break; case 15: throw new Error('complex arg marshalling nyi'); default: throw new Error('Unexpected argtype ' + arg_type_id); } } args.push(cur_stack_ptr); for (var i = 0; i < struct_arg_info.length; i++) { var struct_info = struct_arg_info[i]; var arg_target = struct_info[0]; var arg_ptr = struct_info[1]; var size = struct_info[2]; var align = struct_info[3]; ((cur_stack_ptr -= (size)), (cur_stack_ptr &= (~((align) - 1)))); HEAP8.subarray(cur_stack_ptr, cur_stack_ptr+size).set(HEAP8.subarray(arg_ptr, arg_ptr + size)); HEAPU32[(arg_target >> 2) + 0] = cur_stack_ptr; } } stackRestore(cur_stack_ptr); stackAlloc(0); 0; var result = getWasmTableEntry(fn).apply(null, args); stackRestore(orig_stack_ptr); if (ret_by_arg) { return; } switch (rtype_id) { case 0: break; case 1: case 9: case 10: case 14: HEAPU32[(rvalue >> 2) + 0] = result; break; case 2: HEAPF32[(rvalue >> 2) + 0] = result; break; case 3: HEAPF64[(rvalue >> 3) + 0] = result; break; case 5: case 6: HEAPU8[rvalue + 0] = result; break; case 7: case 8: HEAPU16[(rvalue >> 1) + 0] = result; break; case 11: case 12: HEAPU64[(rvalue >> 3) + 0] = result; break; case 15: throw new Error('complex ret marshalling nyi'); default: throw new Error('Unexpected rtype ' + rtype_id); } }
ffi_call_js.sig = 'viiii';
function ffi_closure_alloc_js(size,code) { var closure = _malloc(size); var index = getEmptyTableSlot(); HEAPU32[(code >> 2) + 0] = index; HEAPU32[(closure >> 2) + 0] = index; return closure; }
ffi_closure_alloc_js.sig = 'iii';
function ffi_closure_free_js(closure) { var index = HEAPU32[(closure >> 2) + 0]; freeTableIndexes.push(index); _free(closure); }
ffi_closure_free_js.sig = 'vi';
function ffi_prep_closure_loc_js(closure,cif,fun,user_data,codeloc) { var abi = HEAPU32[(cif >> 2) + 0]; var nargs = HEAPU32[(cif >> 2) + 1]; var nfixedargs = HEAPU32[(cif >> 2) + 6]; var arg_types_ptr = HEAPU32[(cif >> 2) + 2]; var rtype_unboxed = unbox_small_structs(HEAPU32[(cif >> 2) + 3]); var rtype_ptr = rtype_unboxed[0]; var rtype_id = rtype_unboxed[1]; var sig; var ret_by_arg = 0; switch (rtype_id) { case 0: sig = 'v'; break; case 13: case 4: sig = 'vi'; ret_by_arg = 1; break; case 1: case 5: case 6: case 7: case 8: case 9: case 10: case 14: sig = 'i'; break; case 2: sig = 'f'; break; case 3: sig = 'd'; break; case 11: case 12: sig = 'j'; break; case 15: throw new Error('complex ret marshalling nyi'); default: throw new Error('Unexpected rtype ' + rtype_id); } var unboxed_arg_type_id_list = []; var unboxed_arg_type_info_list = []; for (var i = 0; i < nargs; i++) { var arg_unboxed = unbox_small_structs(HEAPU32[(arg_types_ptr >> 2) + i]); var arg_type_ptr = arg_unboxed[0]; var arg_type_id = arg_unboxed[1]; unboxed_arg_type_id_list.push(arg_type_id); unboxed_arg_type_info_list.push([HEAPU32[(arg_type_ptr >> 2) + 0], HEAPU16[(arg_type_ptr + 4 >> 1) + 0]]); } for (var i = 0; i < nfixedargs; i++) { switch (unboxed_arg_type_id_list[i]) { case 1: case 5: case 6: case 7: case 8: case 9: case 10: case 14: case 13: sig += 'i'; break; case 2: sig += 'f'; break; case 3: sig += 'd'; break; case 4: sig += 'jj'; break; case 11: case 12: sig += 'j'; break; case 15: throw new Error('complex marshalling nyi'); default: throw new Error('Unexpected argtype ' + arg_type_id); } } if (nfixedargs < nargs) { sig += 'i'; } 0; function trampoline() { var args = Array.prototype.slice.call(arguments); var size = 0; var orig_stack_ptr = stackSave(); var cur_ptr = orig_stack_ptr; var ret_ptr; var jsarg_idx = 0; if (ret_by_arg) { ret_ptr = args[jsarg_idx++]; } else { ((cur_ptr -= (8)), (cur_ptr &= (~((8) - 1)))); ret_ptr = cur_ptr; } cur_ptr -= 4 * nargs; var args_ptr = cur_ptr; var carg_idx = 0; for (; carg_idx < nfixedargs; carg_idx++) { var cur_arg = args[jsarg_idx++]; var arg_type_info = unboxed_arg_type_info_list[carg_idx]; var arg_size = arg_type_info[0]; var arg_align = arg_type_info[1]; var arg_type_id = unboxed_arg_type_id_list[carg_idx]; switch (arg_type_id) { case 5: case 6: ((cur_ptr -= (1)), (cur_ptr &= (~((4) - 1)))); HEAPU32[(args_ptr >> 2) + carg_idx] = cur_ptr; HEAPU8[cur_ptr + 0] = cur_arg; break; case 7: case 8: ((cur_ptr -= (2)), (cur_ptr &= (~((4) - 1)))); HEAPU32[(args_ptr >> 2) + carg_idx] = cur_ptr; HEAPU16[(cur_ptr >> 1) + 0] = cur_arg; break; case 1: case 9: case 10: case 14: ((cur_ptr -= (4)), (cur_ptr &= (~((4) - 1)))); HEAPU32[(args_ptr >> 2) + carg_idx] = cur_ptr; HEAPU32[(cur_ptr >> 2) + 0] = cur_arg; break; case 13: ((cur_ptr -= (arg_size)), (cur_ptr &= (~((arg_align) - 1)))); HEAP8.subarray(cur_ptr, cur_ptr + arg_size).set(HEAP8.subarray(cur_arg, cur_arg + arg_size)); HEAPU32[(args_ptr >> 2) + carg_idx] = cur_ptr; break; case 2: ((cur_ptr -= (4)), (cur_ptr &= (~((4) - 1)))); HEAPU32[(args_ptr >> 2) + carg_idx] = cur_ptr; HEAPF32[(cur_ptr >> 2) + 0] = cur_arg; break; case 3: ((cur_ptr -= (8)), (cur_ptr &= (~((8) - 1)))); HEAPU32[(args_ptr >> 2) + carg_idx] = cur_ptr; HEAPF64[(cur_ptr >> 3) + 0] = cur_arg; break; case 11: case 12: ((cur_ptr -= (8)), (cur_ptr &= (~((8) - 1)))); HEAPU32[(args_ptr >> 2) + carg_idx] = cur_ptr; HEAPU64[(cur_ptr >> 3) + 0] = cur_arg; break; case 4: ((cur_ptr -= (16)), (cur_ptr &= (~((8) - 1)))); HEAPU32[(args_ptr >> 2) + carg_idx] = cur_ptr; HEAPU64[(cur_ptr >> 3) + 0] = cur_arg; cur_arg = args[jsarg_idx++]; HEAPU64[(cur_ptr >> 3) + 1] = cur_arg; break; } } var varargs = args[args.length - 1]; for (; carg_idx < nargs; carg_idx++) { var arg_type_id = unboxed_arg_type_id_list[carg_idx]; var arg_type_info = unboxed_arg_type_info_list[carg_idx]; var arg_size = arg_type_info[0]; var arg_align = arg_type_info[1]; if (arg_type_id === 13) { var struct_ptr = HEAPU32[(varargs >> 2) + 0]; ((cur_ptr -= (arg_size)), (cur_ptr &= (~((arg_align) - 1)))); HEAP8.subarray(cur_ptr, cur_ptr + arg_size).set(HEAP8.subarray(struct_ptr, struct_ptr + arg_size)); HEAPU32[(args_ptr >> 2) + carg_idx] = cur_ptr; } else { HEAPU32[(args_ptr >> 2) + carg_idx] = varargs; } varargs += 4; } stackRestore(cur_ptr); stackAlloc(0); 0; getWasmTableEntry(HEAPU32[(closure >> 2) + 2])( HEAPU32[(closure >> 2) + 1], ret_ptr, args_ptr, HEAPU32[(closure >> 2) + 3] ); stackRestore(orig_stack_ptr); if (!ret_by_arg) { switch (sig[0]) { case 'i': return HEAPU32[(ret_ptr >> 2) + 0]; case 'j': return HEAPU64[(ret_ptr >> 3) + 0]; case 'd': return HEAPF64[(ret_ptr >> 3) + 0]; case 'f': return HEAPF32[(ret_ptr >> 2) + 0]; } } } try { var wasm_trampoline = convertJsFunctionToWasm(trampoline, sig); } catch(e) { return 1; } setWasmTableEntry(codeloc, wasm_trampoline); HEAPU32[(closure >> 2) + 1] = cif; HEAPU32[(closure >> 2) + 2] = fun; HEAPU32[(closure >> 2) + 3] = user_data; return 0; }
ffi_prep_closure_loc_js.sig = 'iiiiii';
function _Py_CheckEmscriptenSignals_Helper() { if (!Module.Py_EmscriptenSignalBuffer) { return 0; } try { let result = Module.Py_EmscriptenSignalBuffer[0]; Module.Py_EmscriptenSignalBuffer[0] = 0; return result; } catch(e) { return 0; } }
_Py_CheckEmscriptenSignals_Helper.sig = 'i';

// end include: preamble.js


  var handleException = (e) => {
      // Certain exception types we do not treat as errors since they are used for
      // internal control flow.
      // 1. ExitStatus, which is thrown by exit()
      // 2. "unwind", which is thrown by emscripten_unwind_to_js_event_loop() and others
      //    that wish to return to JS event loop.
      if (e instanceof ExitStatus || e == 'unwind') {
        return EXITSTATUS;
      }
      quit_(1, e);
    };
  
  class ExitStatus {
      name = 'ExitStatus';
      constructor(status) {
        this.message = `Program terminated with exit(${status})`;
        this.status = status;
      }
    }
  
  var runtimeKeepaliveCounter = 0;
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
      EXITSTATUS = code;
      if (!keepRuntimeAlive()) {
        Module['onExit']?.(code);
        ABORT = true;
      }
      quit_(code, new ExitStatus(code));
    };
  _proc_exit.sig = 'vi';
  /** @suppress {duplicate } */
  /** @param {boolean|number=} implicit */
  var exitJS = (status, implicit) => {
      EXITSTATUS = status;
  
      _proc_exit(status);
    };
  var _exit = exitJS;
  _exit.sig = 'vi';
  
  
  var maybeExit = () => {
      if (!keepRuntimeAlive()) {
        try {
          _exit(EXITSTATUS);
        } catch (e) {
          handleException(e);
        }
      }
    };
  var callUserCallback = (func) => {
      if (ABORT) {
        return;
      }
      try {
        func();
        maybeExit();
      } catch (e) {
        handleException(e);
      }
    };
  
  /** @param {number=} timeout */
  var safeSetTimeout = (func, timeout) => {
      
      return setTimeout(() => {
        
        callUserCallback(func);
      }, timeout);
    };
  
  var warnOnce = (text) => {
      warnOnce.shown ||= {};
      if (!warnOnce.shown[text]) {
        warnOnce.shown[text] = 1;
        err(text);
      }
    };
  
  var preloadPlugins = Module['preloadPlugins'] || [];
  
  var registerWasmPlugin = () => {
      // Use string keys here to avoid minification since the plugin consumer
      // also uses string keys.
      var wasmPlugin = {
        'promiseChainEnd': Promise.resolve(),
        'canHandle': (name) => {
          return !Module['noWasmDecoding'] && name.endsWith('.so')
        },
        'handle': (byteArray, name, onload, onerror) => {
          // loadWebAssemblyModule can not load modules out-of-order, so rather
          // than just running the promises in parallel, this makes a chain of
          // promises to run in series.
          wasmPlugin['promiseChainEnd'] = wasmPlugin['promiseChainEnd'].then(
            () => loadWebAssemblyModule(byteArray, {loadAsync: true, nodelete: true}, name, {})).then(
              (exports) => {
                preloadedWasm[name] = exports;
                onload(byteArray);
              },
              (error) => {
                err(`failed to instantiate wasm: ${name}: ${error}`);
                onerror();
              });
        }
      };
      preloadPlugins.push(wasmPlugin);
    };
  var preloadedWasm = {
  };
  
  var Browser = {
  useWebGL:false,
  isFullscreen:false,
  pointerLock:false,
  moduleContextCreatedCallbacks:[],
  workers:[],
  preloadedImages:{
  },
  preloadedAudios:{
  },
  init() {
        if (Browser.initted) return;
        Browser.initted = true;
  
        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).
  
        var imagePlugin = {};
        imagePlugin['canHandle'] = function imagePlugin_canHandle(name) {
          return !Module['noImageDecoding'] && /\.(jpg|jpeg|png|bmp|webp)$/i.test(name);
        };
        imagePlugin['handle'] = function imagePlugin_handle(byteArray, name, onload, onerror) {
          var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
          if (b.size !== byteArray.length) { // Safari bug #118630
            // Safari's Blob can only take an ArrayBuffer
            b = new Blob([(new Uint8Array(byteArray)).buffer], { type: Browser.getMimetype(name) });
          }
          var url = URL.createObjectURL(b);
          var img = new Image();
          img.onload = () => {
            var canvas = /** @type {!HTMLCanvasElement} */ (document.createElement('canvas'));
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            Browser.preloadedImages[name] = canvas;
            URL.revokeObjectURL(url);
            onload?.(byteArray);
          };
          img.onerror = (event) => {
            err(`Image ${url} could not be decoded`);
            onerror?.();
          };
          img.src = url;
        };
        preloadPlugins.push(imagePlugin);
  
        var audioPlugin = {};
        audioPlugin['canHandle'] = function audioPlugin_canHandle(name) {
          return !Module['noAudioDecoding'] && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function audioPlugin_handle(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            Browser.preloadedAudios[name] = audio;
            onload?.(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            Browser.preloadedAudios[name] = new Audio(); // empty shim
            onerror?.();
          }
          var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
          var url = URL.createObjectURL(b); // XXX we never revoke this!
          var audio = new Audio();
          audio.addEventListener('canplaythrough', () => finish(audio), false); // use addEventListener due to chromium bug 124926
          audio.onerror = function audio_onerror(event) {
            if (done) return;
            err(`warning: browser could not fully decode audio ${name}, trying slower base64 approach`);
            function encode64(data) {
              var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
              var PAD = '=';
              var ret = '';
              var leftchar = 0;
              var leftbits = 0;
              for (var i = 0; i < data.length; i++) {
                leftchar = (leftchar << 8) | data[i];
                leftbits += 8;
                while (leftbits >= 6) {
                  var curr = (leftchar >> (leftbits-6)) & 0x3f;
                  leftbits -= 6;
                  ret += BASE[curr];
                }
              }
              if (leftbits == 2) {
                ret += BASE[(leftchar&3) << 4];
                ret += PAD + PAD;
              } else if (leftbits == 4) {
                ret += BASE[(leftchar&0xf) << 2];
                ret += PAD;
              }
              return ret;
            }
            audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
            finish(audio); // we don't wait for confirmation this worked - but it's worth trying
          };
          audio.src = url;
          // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
          safeSetTimeout(() => {
            finish(audio); // try to use it even though it is not necessarily ready to play
          }, 10000);
        };
        preloadPlugins.push(audioPlugin);
  
        // Canvas event setup
  
        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === Module['canvas'] ||
                                document['mozPointerLockElement'] === Module['canvas'] ||
                                document['webkitPointerLockElement'] === Module['canvas'] ||
                                document['msPointerLockElement'] === Module['canvas'];
        }
        var canvas = Module['canvas'];
        if (canvas) {
          // forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module
          // Module['forcedAspectRatio'] = 4 / 3;
  
          canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                      canvas['mozRequestPointerLock'] ||
                                      canvas['webkitRequestPointerLock'] ||
                                      canvas['msRequestPointerLock'] ||
                                      (() => {});
          canvas.exitPointerLock = document['exitPointerLock'] ||
                                   document['mozExitPointerLock'] ||
                                   document['webkitExitPointerLock'] ||
                                   document['msExitPointerLock'] ||
                                   (() => {}); // no-op if function does not exist
          canvas.exitPointerLock = canvas.exitPointerLock.bind(document);
  
          document.addEventListener('pointerlockchange', pointerLockChange, false);
          document.addEventListener('mozpointerlockchange', pointerLockChange, false);
          document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
          document.addEventListener('mspointerlockchange', pointerLockChange, false);
  
          if (Module['elementPointerLock']) {
            canvas.addEventListener("click", (ev) => {
              if (!Browser.pointerLock && Module['canvas'].requestPointerLock) {
                Module['canvas'].requestPointerLock();
                ev.preventDefault();
              }
            }, false);
          }
        }
      },
  createContext(/** @type {HTMLCanvasElement} */ canvas, useWebGL, setInModule, webGLContextAttributes) {
        if (useWebGL && Module['ctx'] && canvas == Module['canvas']) return Module['ctx']; // no need to recreate GL context if it's already been created for this canvas.
  
        var ctx;
        var contextHandle;
        if (useWebGL) {
          // For GLES2/desktop GL compatibility, adjust a few defaults to be different to WebGL defaults, so that they align better with the desktop defaults.
          var contextAttributes = {
            antialias: false,
            alpha: false,
            majorVersion: 2,
          };
  
          if (webGLContextAttributes) {
            for (var attribute in webGLContextAttributes) {
              contextAttributes[attribute] = webGLContextAttributes[attribute];
            }
          }
  
          // This check of existence of GL is here to satisfy Closure compiler, which yells if variable GL is referenced below but GL object is not
          // actually compiled in because application is not doing any GL operations. TODO: Ideally if GL is not being used, this function
          // Browser.createContext() should not even be emitted.
          if (typeof GL != 'undefined') {
            contextHandle = GL.createContext(canvas, contextAttributes);
            if (contextHandle) {
              ctx = GL.getContext(contextHandle).GLctx;
            }
          }
        } else {
          ctx = canvas.getContext('2d');
        }
  
        if (!ctx) return null;
  
        if (setInModule) {
          Module['ctx'] = ctx;
          if (useWebGL) GL.makeContextCurrent(contextHandle);
          Browser.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach((callback) => callback());
          Browser.init();
        }
        return ctx;
      },
  fullscreenHandlersInstalled:false,
  lockPointer:undefined,
  resizeCanvas:undefined,
  requestFullscreen(lockPointer, resizeCanvas) {
        Browser.lockPointer = lockPointer;
        Browser.resizeCanvas = resizeCanvas;
        if (typeof Browser.lockPointer == 'undefined') Browser.lockPointer = true;
        if (typeof Browser.resizeCanvas == 'undefined') Browser.resizeCanvas = false;
  
        var canvas = Module['canvas'];
        function fullscreenChange() {
          Browser.isFullscreen = false;
          var canvasContainer = canvas.parentNode;
          if ((document['fullscreenElement'] || document['mozFullScreenElement'] ||
               document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
               document['webkitCurrentFullScreenElement']) === canvasContainer) {
            canvas.exitFullscreen = Browser.exitFullscreen;
            if (Browser.lockPointer) canvas.requestPointerLock();
            Browser.isFullscreen = true;
            if (Browser.resizeCanvas) {
              Browser.setFullscreenCanvasSize();
            } else {
              Browser.updateCanvasDimensions(canvas);
            }
          } else {
            // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen
            canvasContainer.parentNode.insertBefore(canvas, canvasContainer);
            canvasContainer.parentNode.removeChild(canvasContainer);
  
            if (Browser.resizeCanvas) {
              Browser.setWindowedCanvasSize();
            } else {
              Browser.updateCanvasDimensions(canvas);
            }
          }
          Module['onFullScreen']?.(Browser.isFullscreen);
          Module['onFullscreen']?.(Browser.isFullscreen);
        }
  
        if (!Browser.fullscreenHandlersInstalled) {
          Browser.fullscreenHandlersInstalled = true;
          document.addEventListener('fullscreenchange', fullscreenChange, false);
          document.addEventListener('mozfullscreenchange', fullscreenChange, false);
          document.addEventListener('webkitfullscreenchange', fullscreenChange, false);
          document.addEventListener('MSFullscreenChange', fullscreenChange, false);
        }
  
        // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
        var canvasContainer = document.createElement("div");
        canvas.parentNode.insertBefore(canvasContainer, canvas);
        canvasContainer.appendChild(canvas);
  
        // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)
        canvasContainer.requestFullscreen = canvasContainer['requestFullscreen'] ||
                                            canvasContainer['mozRequestFullScreen'] ||
                                            canvasContainer['msRequestFullscreen'] ||
                                           (canvasContainer['webkitRequestFullscreen'] ? () => canvasContainer['webkitRequestFullscreen'](Element['ALLOW_KEYBOARD_INPUT']) : null) ||
                                           (canvasContainer['webkitRequestFullScreen'] ? () => canvasContainer['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) : null);
  
        canvasContainer.requestFullscreen();
      },
  exitFullscreen() {
        // This is workaround for chrome. Trying to exit from fullscreen
        // not in fullscreen state will cause "TypeError: Document not active"
        // in chrome. See https://github.com/emscripten-core/emscripten/pull/8236
        if (!Browser.isFullscreen) {
          return false;
        }
  
        var CFS = document['exitFullscreen'] ||
                  document['cancelFullScreen'] ||
                  document['mozCancelFullScreen'] ||
                  document['msExitFullscreen'] ||
                  document['webkitCancelFullScreen'] ||
            (() => {});
        CFS.apply(document, []);
        return true;
      },
  safeSetTimeout(func, timeout) {
        // Legacy function, this is used by the SDL2 port so we need to keep it
        // around at least until that is updated.
        // See https://github.com/libsdl-org/SDL/pull/6304
        return safeSetTimeout(func, timeout);
      },
  getMimetype(name) {
        return {
          'jpg': 'image/jpeg',
          'jpeg': 'image/jpeg',
          'png': 'image/png',
          'bmp': 'image/bmp',
          'ogg': 'audio/ogg',
          'wav': 'audio/wav',
          'mp3': 'audio/mpeg'
        }[name.substr(name.lastIndexOf('.')+1)];
      },
  getUserMedia(func) {
        window.getUserMedia ||= navigator['getUserMedia'] ||
                                navigator['mozGetUserMedia'];
        window.getUserMedia(func);
      },
  getMovementX(event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },
  getMovementY(event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },
  getMouseWheelDelta(event) {
        var delta = 0;
        switch (event.type) {
          case 'DOMMouseScroll':
            // 3 lines make up a step
            delta = event.detail / 3;
            break;
          case 'mousewheel':
            // 120 units make up a step
            delta = event.wheelDelta / 120;
            break;
          case 'wheel':
            delta = event.deltaY
            switch (event.deltaMode) {
              case 0:
                // DOM_DELTA_PIXEL: 100 pixels make up a step
                delta /= 100;
                break;
              case 1:
                // DOM_DELTA_LINE: 3 lines make up a step
                delta /= 3;
                break;
              case 2:
                // DOM_DELTA_PAGE: A page makes up 80 steps
                delta *= 80;
                break;
              default:
                throw 'unrecognized mouse wheel delta mode: ' + event.deltaMode;
            }
            break;
          default:
            throw 'unrecognized mouse wheel event: ' + event.type;
        }
        return delta;
      },
  mouseX:0,
  mouseY:0,
  mouseMovementX:0,
  mouseMovementY:0,
  touches:{
  },
  lastTouches:{
  },
  calculateMouseCoords(pageX, pageY) {
        // Calculate the movement based on the changes
        // in the coordinates.
        var rect = Module["canvas"].getBoundingClientRect();
        var cw = Module["canvas"].width;
        var ch = Module["canvas"].height;
  
        // Neither .scrollX or .pageXOffset are defined in a spec, but
        // we prefer .scrollX because it is currently in a spec draft.
        // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
        var scrollX = ((typeof window.scrollX != 'undefined') ? window.scrollX : window.pageXOffset);
        var scrollY = ((typeof window.scrollY != 'undefined') ? window.scrollY : window.pageYOffset);
        var adjustedX = pageX - (scrollX + rect.left);
        var adjustedY = pageY - (scrollY + rect.top);
  
        // the canvas might be CSS-scaled compared to its backbuffer;
        // SDL-using content will want mouse coordinates in terms
        // of backbuffer units.
        adjustedX = adjustedX * (cw / rect.width);
        adjustedY = adjustedY * (ch / rect.height);
  
        return { x: adjustedX, y: adjustedY };
      },
  setMouseCoords(pageX, pageY) {
        const {x, y} = Browser.calculateMouseCoords(pageX, pageY);
        Browser.mouseMovementX = x - Browser.mouseX;
        Browser.mouseMovementY = y - Browser.mouseY;
        Browser.mouseX = x;
        Browser.mouseY = y;
      },
  calculateMouseEvent(event) { // event should be mousemove, mousedown or mouseup
        if (Browser.pointerLock) {
          // When the pointer is locked, calculate the coordinates
          // based on the movement of the mouse.
          // Workaround for Firefox bug 764498
          if (event.type != 'mousemove' &&
              ('mozMovementX' in event)) {
            Browser.mouseMovementX = Browser.mouseMovementY = 0;
          } else {
            Browser.mouseMovementX = Browser.getMovementX(event);
            Browser.mouseMovementY = Browser.getMovementY(event);
          }
  
          // add the mouse delta to the current absolute mouse position
          Browser.mouseX += Browser.mouseMovementX;
          Browser.mouseY += Browser.mouseMovementY;
        } else {
          if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {
            var touch = event.touch;
            if (touch === undefined) {
              return; // the "touch" property is only defined in SDL
  
            }
            var coords = Browser.calculateMouseCoords(touch.pageX, touch.pageY);
  
            if (event.type === 'touchstart') {
              Browser.lastTouches[touch.identifier] = coords;
              Browser.touches[touch.identifier] = coords;
            } else if (event.type === 'touchend' || event.type === 'touchmove') {
              var last = Browser.touches[touch.identifier];
              last ||= coords;
              Browser.lastTouches[touch.identifier] = last;
              Browser.touches[touch.identifier] = coords;
            }
            return;
          }
  
          Browser.setMouseCoords(event.pageX, event.pageY);
        }
      },
  resizeListeners:[],
  updateResizeListeners() {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach((listener) => listener(canvas.width, canvas.height));
      },
  setCanvasSize(width, height, noUpdates) {
        var canvas = Module['canvas'];
        Browser.updateCanvasDimensions(canvas, width, height);
        if (!noUpdates) Browser.updateResizeListeners();
      },
  windowedWidth:0,
  windowedHeight:0,
  setFullscreenCanvasSize() {
        // check if SDL is available
        if (typeof SDL != "undefined") {
          var flags = HEAPU32[((SDL.screen)>>2)];
          flags = flags | 0x00800000; // set SDL_FULLSCREEN flag
          HEAP32[((SDL.screen)>>2)] = flags;
        }
        Browser.updateCanvasDimensions(Module['canvas']);
        Browser.updateResizeListeners();
      },
  setWindowedCanvasSize() {
        // check if SDL is available
        if (typeof SDL != "undefined") {
          var flags = HEAPU32[((SDL.screen)>>2)];
          flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag
          HEAP32[((SDL.screen)>>2)] = flags;
        }
        Browser.updateCanvasDimensions(Module['canvas']);
        Browser.updateResizeListeners();
      },
  updateCanvasDimensions(canvas, wNative, hNative) {
        if (wNative && hNative) {
          canvas.widthNative = wNative;
          canvas.heightNative = hNative;
        } else {
          wNative = canvas.widthNative;
          hNative = canvas.heightNative;
        }
        var w = wNative;
        var h = hNative;
        if (Module['forcedAspectRatio'] && Module['forcedAspectRatio'] > 0) {
          if (w/h < Module['forcedAspectRatio']) {
            w = Math.round(h * Module['forcedAspectRatio']);
          } else {
            h = Math.round(w / Module['forcedAspectRatio']);
          }
        }
        if (((document['fullscreenElement'] || document['mozFullScreenElement'] ||
             document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
             document['webkitCurrentFullScreenElement']) === canvas.parentNode) && (typeof screen != 'undefined')) {
           var factor = Math.min(screen.width / w, screen.height / h);
           w = Math.round(w * factor);
           h = Math.round(h * factor);
        }
        if (Browser.resizeCanvas) {
          if (canvas.width  != w) canvas.width  = w;
          if (canvas.height != h) canvas.height = h;
          if (typeof canvas.style != 'undefined') {
            canvas.style.removeProperty( "width");
            canvas.style.removeProperty("height");
          }
        } else {
          if (canvas.width  != wNative) canvas.width  = wNative;
          if (canvas.height != hNative) canvas.height = hNative;
          if (typeof canvas.style != 'undefined') {
            if (w != wNative || h != hNative) {
              canvas.style.setProperty( "width", w + "px", "important");
              canvas.style.setProperty("height", h + "px", "important");
            } else {
              canvas.style.removeProperty( "width");
              canvas.style.removeProperty("height");
            }
          }
        }
      },
  };


  var GOT = {
  };
  
  var currentModuleWeakSymbols = new Set([]);
  var GOTHandler = {
  get(obj, symName) {
        var rtn = GOT[symName];
        if (!rtn) {
          rtn = GOT[symName] = new WebAssembly.Global({'value': 'i32', 'mutable': true});
        }
        if (!currentModuleWeakSymbols.has(symName)) {
          // Any non-weak reference to a symbol marks it as `required`, which
          // enabled `reportUndefinedSymbols` to report undefeind symbol errors
          // correctly.
          rtn.required = true;
        }
        return rtn;
      },
  };

  var callRuntimeCallbacks = (callbacks) => {
      while (callbacks.length > 0) {
        // Pass the module as the first argument.
        callbacks.shift()(Module);
      }
    };

  var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;
  
    /**
     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
     * array that contains uint8 values, returns a copy of that string as a
     * Javascript String object.
     * heapOrArray is either a regular array, or a JavaScript typed array view.
     * @param {number=} idx
     * @param {number=} maxBytesToRead
     * @return {string}
     */
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      // TextDecoder needs to know the byte length in advance, it doesn't stop on
      // null terminator by itself.  Also, use the length info to avoid running tiny
      // strings through TextDecoder, since .subarray() allocates garbage.
      // (As a tiny code save trick, compare endPtr against endIdx using a negation,
      // so that undefined/NaN means Infinity)
      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
  
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = '';
      // If building with TextDecoder, we have already computed the string length
      // above, so test loop end condition against that
      while (idx < endPtr) {
        // For UTF8 byte structure, see:
        // http://en.wikipedia.org/wiki/UTF-8#Description
        // https://www.ietf.org/rfc/rfc2279.txt
        // https://tools.ietf.org/html/rfc3629
        var u0 = heapOrArray[idx++];
        if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 0xF0) == 0xE0) {
          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
        } else {
          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
        }
  
        if (u0 < 0x10000) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 0x10000;
          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
        }
      }
      return str;
    };
  var getDylinkMetadata = (binary) => {
      var offset = 0;
      var end = 0;
  
      function getU8() {
        return binary[offset++];
      }
  
      function getLEB() {
        var ret = 0;
        var mul = 1;
        while (1) {
          var byte = binary[offset++];
          ret += ((byte & 0x7f) * mul);
          mul *= 0x80;
          if (!(byte & 0x80)) break;
        }
        return ret;
      }
  
      function getString() {
        var len = getLEB();
        offset += len;
        return UTF8ArrayToString(binary, offset - len, len);
      }
  
      /** @param {string=} message */
      function failIf(condition, message) {
        if (condition) throw new Error(message);
      }
  
      var name = 'dylink.0';
      if (binary instanceof WebAssembly.Module) {
        var dylinkSection = WebAssembly.Module.customSections(binary, name);
        if (dylinkSection.length === 0) {
          name = 'dylink'
          dylinkSection = WebAssembly.Module.customSections(binary, name);
        }
        failIf(dylinkSection.length === 0, 'need dylink section');
        binary = new Uint8Array(dylinkSection[0]);
        end = binary.length
      } else {
        var int32View = new Uint32Array(new Uint8Array(binary.subarray(0, 24)).buffer);
        var magicNumberFound = int32View[0] == 0x6d736100;
        failIf(!magicNumberFound, 'need to see wasm magic number'); // \0asm
        // we should see the dylink custom section right after the magic number and wasm version
        failIf(binary[8] !== 0, 'need the dylink section to be first')
        offset = 9;
        var section_size = getLEB(); //section size
        end = offset + section_size;
        name = getString();
      }
  
      var customSection = { neededDynlibs: [], tlsExports: new Set(), weakImports: new Set() };
      if (name == 'dylink') {
        customSection.memorySize = getLEB();
        customSection.memoryAlign = getLEB();
        customSection.tableSize = getLEB();
        customSection.tableAlign = getLEB();
        // shared libraries this module needs. We need to load them first, so that
        // current module could resolve its imports. (see tools/shared.py
        // WebAssembly.make_shared_library() for "dylink" section extension format)
        var neededDynlibsCount = getLEB();
        for (var i = 0; i < neededDynlibsCount; ++i) {
          var libname = getString();
          customSection.neededDynlibs.push(libname);
        }
      } else {
        failIf(name !== 'dylink.0');
        var WASM_DYLINK_MEM_INFO = 0x1;
        var WASM_DYLINK_NEEDED = 0x2;
        var WASM_DYLINK_EXPORT_INFO = 0x3;
        var WASM_DYLINK_IMPORT_INFO = 0x4;
        var WASM_SYMBOL_TLS = 0x100;
        var WASM_SYMBOL_BINDING_MASK = 0x3;
        var WASM_SYMBOL_BINDING_WEAK = 0x1;
        while (offset < end) {
          var subsectionType = getU8();
          var subsectionSize = getLEB();
          if (subsectionType === WASM_DYLINK_MEM_INFO) {
            customSection.memorySize = getLEB();
            customSection.memoryAlign = getLEB();
            customSection.tableSize = getLEB();
            customSection.tableAlign = getLEB();
          } else if (subsectionType === WASM_DYLINK_NEEDED) {
            var neededDynlibsCount = getLEB();
            for (var i = 0; i < neededDynlibsCount; ++i) {
              libname = getString();
              customSection.neededDynlibs.push(libname);
            }
          } else if (subsectionType === WASM_DYLINK_EXPORT_INFO) {
            var count = getLEB();
            while (count--) {
              var symname = getString();
              var flags = getLEB();
              if (flags & WASM_SYMBOL_TLS) {
                customSection.tlsExports.add(symname);
              }
            }
          } else if (subsectionType === WASM_DYLINK_IMPORT_INFO) {
            var count = getLEB();
            while (count--) {
              var modname = getString();
              var symname = getString();
              var flags = getLEB();
              if ((flags & WASM_SYMBOL_BINDING_MASK) == WASM_SYMBOL_BINDING_WEAK) {
                customSection.weakImports.add(symname);
              }
            }
          } else {
            // unknown subsection
            offset += subsectionSize;
          }
        }
      }
  
      return customSection;
    };

  
    /**
     * @param {number} ptr
     * @param {string} type
     */
  function getValue(ptr, type = 'i8') {
    if (type.endsWith('*')) type = '*';
    switch (type) {
      case 'i1': return HEAP8[ptr];
      case 'i8': return HEAP8[ptr];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP64[((ptr)>>3)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      case '*': return HEAPU32[((ptr)>>2)];
      default: abort(`invalid type for getValue: ${type}`);
    }
  }

  var newDSO = (name, handle, syms) => {
      var dso = {
        refcount: Infinity,
        name,
        exports: syms,
        global: true,
      };
      LDSO.loadedLibsByName[name] = dso;
      if (handle != undefined) {
        LDSO.loadedLibsByHandle[handle] = dso;
      }
      return dso;
    };
  var LDSO = {
  loadedLibsByName:{
  },
  loadedLibsByHandle:{
  },
  init() {
        newDSO('__main__', 0, wasmImports);
      },
  };
  
  
  
  var ___heap_base = 12673888;
  
  var alignMemory = (size, alignment) => {
      return Math.ceil(size / alignment) * alignment;
    };
  
  var getMemory = (size) => {
      // After the runtime is initialized, we must only use sbrk() normally.
      if (runtimeInitialized) {
        // Currently we don't support freeing of static data when modules are
        // unloaded via dlclose.  This function is tagged as `noleakcheck` to
        // avoid having this reported as leak.
        return _calloc(size, 1);
      }
      var ret = ___heap_base;
      // Keep __heap_base stack aligned.
      var end = ret + alignMemory(size, 16);
      ___heap_base = end;
      GOT['__heap_base'].value = end;
      return ret;
    };
  
  
  var isInternalSym = (symName) => {
      // TODO: find a way to mark these in the binary or avoid exporting them.
      return [
        '__cpp_exception',
        '__c_longjmp',
        '__wasm_apply_data_relocs',
        '__dso_handle',
        '__tls_size',
        '__tls_align',
        '__set_stack_limits',
        '_emscripten_tls_init',
        '__wasm_init_tls',
        '__wasm_call_ctors',
        '__start_em_asm',
        '__stop_em_asm',
        '__start_em_js',
        '__stop_em_js',
      ].includes(symName) || symName.startsWith('__em_js__')
      ;
    };
  
  var uleb128Encode = (n, target) => {
      if (n < 128) {
        target.push(n);
      } else {
        target.push((n % 128) | 128, n >> 7);
      }
    };
  
  var sigToWasmTypes = (sig) => {
      var typeNames = {
        'i': 'i32',
        'j': 'i64',
        'f': 'f32',
        'd': 'f64',
        'e': 'externref',
        'p': 'i32',
      };
      var type = {
        parameters: [],
        results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]
      };
      for (var i = 1; i < sig.length; ++i) {
        type.parameters.push(typeNames[sig[i]]);
      }
      return type;
    };
  
  var generateFuncType = (sig, target) => {
      var sigRet = sig.slice(0, 1);
      var sigParam = sig.slice(1);
      var typeCodes = {
        'i': 0x7f, // i32
        'p': 0x7f, // i32
        'j': 0x7e, // i64
        'f': 0x7d, // f32
        'd': 0x7c, // f64
        'e': 0x6f, // externref
      };
  
      // Parameters, length + signatures
      target.push(0x60 /* form: func */);
      uleb128Encode(sigParam.length, target);
      for (var i = 0; i < sigParam.length; ++i) {
        target.push(typeCodes[sigParam[i]]);
      }
  
      // Return values, length + signatures
      // With no multi-return in MVP, either 0 (void) or 1 (anything else)
      if (sigRet == 'v') {
        target.push(0x00);
      } else {
        target.push(0x01, typeCodes[sigRet]);
      }
    };
  var convertJsFunctionToWasm = (func, sig) => {
  
      // If the type reflection proposal is available, use the new
      // "WebAssembly.Function" constructor.
      // Otherwise, construct a minimal wasm module importing the JS function and
      // re-exporting it.
      if (typeof WebAssembly.Function == "function") {
        return new WebAssembly.Function(sigToWasmTypes(sig), func);
      }
  
      // The module is static, with the exception of the type section, which is
      // generated based on the signature passed in.
      var typeSectionBody = [
        0x01, // count: 1
      ];
      generateFuncType(sig, typeSectionBody);
  
      // Rest of the module is static
      var bytes = [
        0x00, 0x61, 0x73, 0x6d, // magic ("\0asm")
        0x01, 0x00, 0x00, 0x00, // version: 1
        0x01, // Type section code
      ];
      // Write the overall length of the type section followed by the body
      uleb128Encode(typeSectionBody.length, bytes);
      bytes.push(...typeSectionBody);
  
      // The rest of the module is static
      bytes.push(
        0x02, 0x07, // import section
          // (import "e" "f" (func 0 (type 0)))
          0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
        0x07, 0x05, // export section
          // (export "f" (func 0 (type 0)))
          0x01, 0x01, 0x66, 0x00, 0x00,
      );
  
      // We can compile this wasm module synchronously because it is very small.
      // This accepts an import (at "e.f"), that it reroutes to an export (at "f")
      var module = new WebAssembly.Module(new Uint8Array(bytes));
      var instance = new WebAssembly.Instance(module, { 'e': { 'f': func } });
      var wrappedFunc = instance.exports['f'];
      return wrappedFunc;
    };
  
  var wasmTableMirror = [];
  
  /** @type {WebAssembly.Table} */
  var wasmTable = new WebAssembly.Table({
    'initial': 9546,
    'element': 'anyfunc'
  });
  ;
  var getWasmTableEntry = (funcPtr) => {
      var func = wasmTableMirror[funcPtr];
      if (!func) {
        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
        /** @suppress {checkTypes} */
        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      }
      return func;
    };
  
  var updateTableMap = (offset, count) => {
      if (functionsInTableMap) {
        for (var i = offset; i < offset + count; i++) {
          var item = getWasmTableEntry(i);
          // Ignore null values.
          if (item) {
            functionsInTableMap.set(item, i);
          }
        }
      }
    };
  
  var functionsInTableMap;
  
  var getFunctionAddress = (func) => {
      // First, create the map if this is the first use.
      if (!functionsInTableMap) {
        functionsInTableMap = new WeakMap();
        updateTableMap(0, wasmTable.length);
      }
      return functionsInTableMap.get(func) || 0;
    };
  
  
  var freeTableIndexes = [];
  
  var getEmptyTableSlot = () => {
      // Reuse a free index if there is one, otherwise grow.
      if (freeTableIndexes.length) {
        return freeTableIndexes.pop();
      }
      // Grow the table
      try {
        /** @suppress {checkTypes} */
        wasmTable.grow(1);
      } catch (err) {
        if (!(err instanceof RangeError)) {
          throw err;
        }
        throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
      }
      return wasmTable.length - 1;
    };
  
  
  
  var setWasmTableEntry = (idx, func) => {
      /** @suppress {checkTypes} */
      wasmTable.set(idx, func);
      // With ABORT_ON_WASM_EXCEPTIONS wasmTable.get is overridden to return wrapped
      // functions so we need to call it here to retrieve the potential wrapper correctly
      // instead of just storing 'func' directly into wasmTableMirror
      /** @suppress {checkTypes} */
      wasmTableMirror[idx] = wasmTable.get(idx);
    };
  
  /** @param {string=} sig */
  var addFunction = (func, sig) => {
      // Check if the function is already in the table, to ensure each function
      // gets a unique index.
      var rtn = getFunctionAddress(func);
      if (rtn) {
        return rtn;
      }
  
      // It's not in the table, add it now.
  
      var ret = getEmptyTableSlot();
  
      // Set the new value.
      try {
        // Attempting to call this with JS function will cause of table.set() to fail
        setWasmTableEntry(ret, func);
      } catch (err) {
        if (!(err instanceof TypeError)) {
          throw err;
        }
        var wrapped = convertJsFunctionToWasm(func, sig);
        setWasmTableEntry(ret, wrapped);
      }
  
      functionsInTableMap.set(func, ret);
  
      return ret;
    };
  
  var updateGOT = (exports, replace) => {
      for (var symName in exports) {
        if (isInternalSym(symName)) {
          continue;
        }
  
        var value = exports[symName];
  
        GOT[symName] ||= new WebAssembly.Global({'value': 'i32', 'mutable': true});
        if (replace || GOT[symName].value == 0) {
          if (typeof value == 'function') {
            GOT[symName].value = addFunction(value);
          } else if (typeof value == 'number') {
            GOT[symName].value = value;
          } else {
            err(`unhandled export type for '${symName}': ${typeof value}`);
          }
        }
      }
    };
  /** @param {boolean=} replace */
  var relocateExports = (exports, memoryBase, replace) => {
      var relocated = {};
  
      for (var e in exports) {
        var value = exports[e];
        if (typeof value == 'object') {
          // a breaking change in the wasm spec, globals are now objects
          // https://github.com/WebAssembly/mutable-global/issues/1
          value = value.value;
        }
        if (typeof value == 'number') {
          value += memoryBase;
        }
        relocated[e] = value;
      }
      updateGOT(relocated, replace);
      return relocated;
    };
  
  var isSymbolDefined = (symName) => {
      // Ignore 'stub' symbols that are auto-generated as part of the original
      // `wasmImports` used to instantiate the main module.
      var existing = wasmImports[symName];
      if (!existing || existing.stub) {
        return false;
      }
      return true;
    };
  
  var dynCall = (sig, ptr, args = []) => {
      var rtn = getWasmTableEntry(ptr)(...args);
      return rtn;
    };
  
  
  var stackSave = () => _emscripten_stack_get_current();
  
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var createInvokeFunction = (sig) => (ptr, ...args) => {
      var sp = stackSave();
      try {
        return dynCall(sig, ptr, args);
      } catch(e) {
        stackRestore(sp);
        // Create a try-catch guard that rethrows the Emscripten EH exception.
        // Exceptions thrown from C++ will be a pointer (number) and longjmp
        // will throw the number Infinity. Use the compact and fast "e !== e+0"
        // test to check if e was not a Number.
        if (e !== e+0) throw e;
        _setThrew(1, 0);
        // In theory this if statement could be done on
        // creating the function, but I just added this to
        // save wasting code space as it only happens on exception.
        if (sig[0] == "j") return 0n;
      }
    };
  var resolveGlobalSymbol = (symName, direct = false) => {
      var sym;
      if (isSymbolDefined(symName)) {
        sym = wasmImports[symName];
      }
      // Asm.js-style exception handling: invoke wrapper generation
      else if (symName.startsWith('invoke_')) {
        // Create (and cache) new invoke_ functions on demand.
        sym = wasmImports[symName] = createInvokeFunction(symName.split('_')[1]);
      }
      return {sym, name: symName};
    };
  
  
  
  
  
  
  
  
    /**
     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
     * emscripten HEAP, returns a copy of that string as a Javascript String object.
     *
     * @param {number} ptr
     * @param {number=} maxBytesToRead - An optional length that specifies the
     *   maximum number of bytes to read. You can omit this parameter to scan the
     *   string until the first 0 byte. If maxBytesToRead is passed, and the string
     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
     *   string will cut short at that byte index (i.e. maxBytesToRead will not
     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing
     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw
     *   JS JIT optimizations off, so it is worth to consider consistently using one
     * @return {string}
     */
  var UTF8ToString = (ptr, maxBytesToRead) => {
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
    };
  
     /**
      * @param {string=} libName
      * @param {Object=} localScope
      * @param {number=} handle
      */
  var loadWebAssemblyModule = (binary, flags, libName, localScope, handle) => {
      var metadata = getDylinkMetadata(binary);
      currentModuleWeakSymbols = metadata.weakImports;
  
      // loadModule loads the wasm module after all its dependencies have been loaded.
      // can be called both sync/async.
      function loadModule() {
        // The first thread to load a given module needs to allocate the static
        // table and memory regions.  Later threads re-use the same table region
        // and can ignore the memory region (since memory is shared between
        // threads already).
        // If `handle` is specified than it is assumed that the calling thread has
        // exclusive access to it for the duration of this function.  See the
        // locking in `dynlink.c`.
        var firstLoad = !handle || !HEAP8[(handle)+(8)];
        if (firstLoad) {
          // alignments are powers of 2
          var memAlign = Math.pow(2, metadata.memoryAlign);
          // prepare memory
          var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0; // TODO: add to cleanups
          var tableBase = metadata.tableSize ? wasmTable.length : 0;
          if (handle) {
            HEAP8[(handle)+(8)] = 1;
            HEAPU32[(((handle)+(12))>>2)] = memoryBase;
            HEAP32[(((handle)+(16))>>2)] = metadata.memorySize;
            HEAPU32[(((handle)+(20))>>2)] = tableBase;
            HEAP32[(((handle)+(24))>>2)] = metadata.tableSize;
          }
        } else {
          memoryBase = HEAPU32[(((handle)+(12))>>2)];
          tableBase = HEAPU32[(((handle)+(20))>>2)];
        }
  
        var tableGrowthNeeded = tableBase + metadata.tableSize - wasmTable.length;
        if (tableGrowthNeeded > 0) {
          wasmTable.grow(tableGrowthNeeded);
        }
  
        // This is the export map that we ultimately return.  We declare it here
        // so it can be used within resolveSymbol.  We resolve symbols against
        // this local symbol map in the case there they are not present on the
        // global Module object.  We need this fallback because Modules sometime
        // need to import their own symbols
        var moduleExports;
  
        function resolveSymbol(sym) {
          var resolved = resolveGlobalSymbol(sym).sym;
          if (!resolved && localScope) {
            resolved = localScope[sym];
          }
          if (!resolved) {
            resolved = moduleExports[sym];
          }
          return resolved;
        }
  
        // TODO kill  (except "symbols local to this module", it will likely be
        // not needed if we require that if A wants symbols from B it has to link
        // to B explicitly: similarly to -Wl,--no-undefined)
        //
        // wasm dynamic libraries are pure wasm, so they cannot assist in
        // their own loading. When side module A wants to import something
        // provided by a side module B that is loaded later, we need to
        // add a layer of indirection, but worse, we can't even tell what
        // to add the indirection for, without inspecting what A's imports
        // are. To do that here, we use a JS proxy (another option would
        // be to inspect the binary directly).
        var proxyHandler = {
          get(stubs, prop) {
            // symbols that should be local to this module
            switch (prop) {
              case '__memory_base':
                return memoryBase;
              case '__table_base':
                return tableBase;
            }
            if (prop in wasmImports && !wasmImports[prop].stub) {
              // No stub needed, symbol already exists in symbol table
              return wasmImports[prop];
            }
            // Return a stub function that will resolve the symbol
            // when first called.
            if (!(prop in stubs)) {
              var resolved;
              stubs[prop] = (...args) => {
                resolved ||= resolveSymbol(prop);
                if (!resolved) {
                  throw new Error(`Dynamic linking error: cannot resolve symbol ${prop}`);
                }
                return resolved(...args);
              };
            }
            return stubs[prop];
          }
        };
        var proxy = new Proxy({}, proxyHandler);
        var info = {
          'GOT.mem': new Proxy({}, GOTHandler),
          'GOT.func': new Proxy({}, GOTHandler),
          'env': proxy,
          'wasi_snapshot_preview1': proxy,
        };
  
        function postInstantiation(module, instance) {
          // add new entries to functionsInTableMap
          updateTableMap(tableBase, metadata.tableSize);
          moduleExports = relocateExports(instance.exports, memoryBase);
          if (!flags.allowUndefined) {
            reportUndefinedSymbols();
          }
  
          function addEmAsm(addr, body) {
            var args = [];
            var arity = 0;
            for (; arity < 16; arity++) {
              if (body.indexOf('$' + arity) != -1) {
                args.push('$' + arity);
              } else {
                break;
              }
            }
            args = args.join(',');
            var func = `(${args}) => { ${body} };`;
            ASM_CONSTS[start] = eval(func);
          }
  
          // Add any EM_ASM function that exist in the side module
          if ('__start_em_asm' in moduleExports) {
            var start = moduleExports['__start_em_asm'];
            var stop = moduleExports['__stop_em_asm'];
            
            
            while (start < stop) {
              var jsString = UTF8ToString(start);
              addEmAsm(start, jsString);
              start = HEAPU8.indexOf(0, start) + 1;
            }
          }
  
          function addEmJs(name, cSig, body) {
            // The signature here is a C signature (e.g. "(int foo, char* bar)").
            // See `create_em_js` in emcc.py` for the build-time version of this
            // code.
            var jsArgs = [];
            cSig = cSig.slice(1, -1)
            if (cSig != 'void') {
              cSig = cSig.split(',');
              for (var i in cSig) {
                var jsArg = cSig[i].split(' ').pop();
                jsArgs.push(jsArg.replaceAll('*', ''));
              }
            }
            var func = `(${jsArgs}) => ${body};`;
            moduleExports[name] = eval(func);
          }
  
          for (var name in moduleExports) {
            if (name.startsWith('__em_js__')) {
              var start = moduleExports[name]
              var jsString = UTF8ToString(start);
              // EM_JS strings are stored in the data section in the form
              // SIG<::>BODY.
              var parts = jsString.split('<::>');
              addEmJs(name.replace('__em_js__', ''), parts[0], parts[1]);
              delete moduleExports[name];
            }
          }
  
          // initialize the module
            var applyRelocs = moduleExports['__wasm_apply_data_relocs'];
            if (applyRelocs) {
              if (runtimeInitialized) {
                applyRelocs();
              } else {
                __RELOC_FUNCS__.push(applyRelocs);
              }
            }
            var init = moduleExports['__wasm_call_ctors'];
            if (init) {
              if (runtimeInitialized) {
                init();
              } else {
                // we aren't ready to run compiled code yet
                __ATINIT__.push(init);
              }
            }
          return moduleExports;
        }
  
        if (flags.loadAsync) {
          if (binary instanceof WebAssembly.Module) {
            var instance = new WebAssembly.Instance(binary, info);
            return Promise.resolve(postInstantiation(binary, instance));
          }
          return WebAssembly.instantiate(binary, info).then(
            (result) => postInstantiation(result.module, result.instance)
          );
        }
  
        var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary);
        var instance = new WebAssembly.Instance(module, info);
        return postInstantiation(module, instance);
      }
  
      // now load needed libraries and the module itself.
      if (flags.loadAsync) {
        return metadata.neededDynlibs
          .reduce((chain, dynNeeded) => chain.then(() =>
            loadDynamicLibrary(dynNeeded, flags, localScope)
          ), Promise.resolve())
          .then(loadModule);
      }
  
      metadata.neededDynlibs.forEach((needed) => loadDynamicLibrary(needed, flags, localScope));
      return loadModule();
    };
  
  
  var mergeLibSymbols = (exports, libName) => {
      // add symbols into global namespace TODO: weak linking etc.
      for (var [sym, exp] of Object.entries(exports)) {
  
        // When RTLD_GLOBAL is enabled, the symbols defined by this shared object
        // will be made available for symbol resolution of subsequently loaded
        // shared objects.
        //
        // We should copy the symbols (which include methods and variables) from
        // SIDE_MODULE to MAIN_MODULE.
        const setImport = (target) => {
          if (!isSymbolDefined(target)) {
            wasmImports[target] = exp;
          }
        }
        setImport(sym);
  
        // Special case for handling of main symbol:  If a side module exports
        // `main` that also acts a definition for `__main_argc_argv` and vice
        // versa.
        const main_alias = '__main_argc_argv';
        if (sym == 'main') {
          setImport(main_alias)
        }
        if (sym == main_alias) {
          setImport('main')
        }
      }
    };
  
  
  var asyncLoad = async (url) => {
      var arrayBuffer = await readAsync(url);
      return new Uint8Array(arrayBuffer);
    };
  
  
      /**
       * @param {number=} handle
       * @param {Object=} localScope
       */
  function loadDynamicLibrary(libName, flags = {global: true, nodelete: true}, localScope, handle) {
      // when loadDynamicLibrary did not have flags, libraries were loaded
      // globally & permanently
  
      var dso = LDSO.loadedLibsByName[libName];
      if (dso) {
        // the library is being loaded or has been loaded already.
        if (!flags.global) {
          if (localScope) {
            Object.assign(localScope, dso.exports);
          }
        } else if (!dso.global) {
          // The library was previously loaded only locally but not
          // we have a request with global=true.
          dso.global = true;
          mergeLibSymbols(dso.exports, libName)
        }
        // same for "nodelete"
        if (flags.nodelete && dso.refcount !== Infinity) {
          dso.refcount = Infinity;
        }
        dso.refcount++
        if (handle) {
          LDSO.loadedLibsByHandle[handle] = dso;
        }
        return flags.loadAsync ? Promise.resolve(true) : true;
      }
  
      // allocate new DSO
      dso = newDSO(libName, handle, 'loading');
      dso.refcount = flags.nodelete ? Infinity : 1;
      dso.global = flags.global;
  
      // libName -> libData
      function loadLibData() {
  
        // for wasm, we can use fetch for async, but for fs mode we can only imitate it
        if (handle) {
          var data = HEAPU32[(((handle)+(28))>>2)];
          var dataSize = HEAPU32[(((handle)+(32))>>2)];
          if (data && dataSize) {
            var libData = HEAP8.slice(data, data + dataSize);
            return flags.loadAsync ? Promise.resolve(libData) : libData;
          }
        }
  
        var libFile = locateFile(libName);
        if (flags.loadAsync) {
          return asyncLoad(libFile);
        }
  
        // load the binary synchronously
        if (!readBinary) {
          throw new Error(`${libFile}: file not found, and synchronous loading of external files is not available`);
        }
        return readBinary(libFile);
      }
  
      // libName -> exports
      function getExports() {
        // lookup preloaded cache first
        var preloaded = preloadedWasm[libName];
        if (preloaded) {
          return flags.loadAsync ? Promise.resolve(preloaded) : preloaded;
        }
  
        // module not preloaded - load lib data and create new module from it
        if (flags.loadAsync) {
          return loadLibData().then((libData) => loadWebAssemblyModule(libData, flags, libName, localScope, handle));
        }
  
        return loadWebAssemblyModule(loadLibData(), flags, libName, localScope, handle);
      }
  
      // module for lib is loaded - update the dso & global namespace
      function moduleLoaded(exports) {
        if (dso.global) {
          mergeLibSymbols(exports, libName);
        } else if (localScope) {
          Object.assign(localScope, exports);
        }
        dso.exports = exports;
      }
  
      if (flags.loadAsync) {
        return getExports().then((exports) => {
          moduleLoaded(exports);
          return true;
        });
      }
  
      moduleLoaded(getExports());
      return true;
    }
  
  
  var reportUndefinedSymbols = () => {
      for (var [symName, entry] of Object.entries(GOT)) {
        if (entry.value == 0) {
          var value = resolveGlobalSymbol(symName, true).sym;
          if (!value && !entry.required) {
            // Ignore undefined symbols that are imported as weak.
            continue;
          }
          if (typeof value == 'function') {
            /** @suppress {checkTypes} */
            entry.value = addFunction(value, value.sig);
          } else if (typeof value == 'number') {
            entry.value = value;
          } else {
            throw new Error(`bad export type for '${symName}': ${typeof value}`);
          }
        }
      }
    };
  var loadDylibs = () => {
      if (!dynamicLibraries.length) {
        reportUndefinedSymbols();
        return;
      }
  
      // Load binaries asynchronously
      addRunDependency('loadDylibs');
      dynamicLibraries
        .reduce((chain, lib) => chain.then(() =>
          loadDynamicLibrary(lib, {loadAsync: true, global: true, nodelete: true, allowUndefined: true})
        ), Promise.resolve())
        .then(() => {
          // we got them all, wonderful
          reportUndefinedSymbols();
          removeRunDependency('loadDylibs');
        });
    };


  var noExitRuntime = Module['noExitRuntime'] || true;



  
    /**
     * @param {number} ptr
     * @param {number} value
     * @param {string} type
     */
  function setValue(ptr, value, type = 'i8') {
    if (type.endsWith('*')) type = '*';
    switch (type) {
      case 'i1': HEAP8[ptr] = value; break;
      case 'i8': HEAP8[ptr] = value; break;
      case 'i16': HEAP16[((ptr)>>1)] = value; break;
      case 'i32': HEAP32[((ptr)>>2)] = value; break;
      case 'i64': HEAP64[((ptr)>>3)] = BigInt(value); break;
      case 'float': HEAPF32[((ptr)>>2)] = value; break;
      case 'double': HEAPF64[((ptr)>>3)] = value; break;
      case '*': HEAPU32[((ptr)>>2)] = value; break;
      default: abort(`invalid type for setValue: ${type}`);
    }
  }



  var ___assert_fail = (condition, filename, line, func) =>
      abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);
  ___assert_fail.sig = 'vppip';

  var ___call_sighandler = (fp, sig) => getWasmTableEntry(fp)(sig);
  ___call_sighandler.sig = 'vpi';

  class ExceptionInfo {
      // excPtr - Thrown object pointer to wrap. Metadata pointer is calculated from it.
      constructor(excPtr) {
        this.excPtr = excPtr;
        this.ptr = excPtr - 24;
      }
  
      set_type(type) {
        HEAPU32[(((this.ptr)+(4))>>2)] = type;
      }
  
      get_type() {
        return HEAPU32[(((this.ptr)+(4))>>2)];
      }
  
      set_destructor(destructor) {
        HEAPU32[(((this.ptr)+(8))>>2)] = destructor;
      }
  
      get_destructor() {
        return HEAPU32[(((this.ptr)+(8))>>2)];
      }
  
      set_caught(caught) {
        caught = caught ? 1 : 0;
        HEAP8[(this.ptr)+(12)] = caught;
      }
  
      get_caught() {
        return HEAP8[(this.ptr)+(12)] != 0;
      }
  
      set_rethrown(rethrown) {
        rethrown = rethrown ? 1 : 0;
        HEAP8[(this.ptr)+(13)] = rethrown;
      }
  
      get_rethrown() {
        return HEAP8[(this.ptr)+(13)] != 0;
      }
  
      // Initialize native structure fields. Should be called once after allocated.
      init(type, destructor) {
        this.set_adjusted_ptr(0);
        this.set_type(type);
        this.set_destructor(destructor);
      }
  
      set_adjusted_ptr(adjustedPtr) {
        HEAPU32[(((this.ptr)+(16))>>2)] = adjustedPtr;
      }
  
      get_adjusted_ptr() {
        return HEAPU32[(((this.ptr)+(16))>>2)];
      }
    }
  
  var exceptionLast = 0;
  
  var uncaughtExceptionCount = 0;
  var ___cxa_throw = (ptr, type, destructor) => {
      var info = new ExceptionInfo(ptr);
      // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.
      info.init(type, destructor);
      exceptionLast = ptr;
      uncaughtExceptionCount++;
      throw exceptionLast;
    };
  ___cxa_throw.sig = 'vppp';


  var ___memory_base = new WebAssembly.Global({'value': 'i32', 'mutable': false}, 1024);

  var ___stack_high = 12673888;

  var ___stack_low = 4285280;

  var ___stack_pointer = new WebAssembly.Global({'value': 'i32', 'mutable': true}, 12673888);

  var PATH = {
  isAbs:(path) => path.charAt(0) === '/',
  splitPath:(filename) => {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },
  normalizeArray:(parts, allowAboveRoot) => {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },
  normalize:(path) => {
        var isAbsolute = PATH.isAbs(path),
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },
  dirname:(path) => {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },
  basename:(path) => {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },
  join:(...paths) => PATH.normalize(paths.join('/')),
  join2:(l, r) => PATH.normalize(l + '/' + r),
  };
  
  var initRandomFill = () => {
      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {
        // for modern web browsers
        return (view) => crypto.getRandomValues(view);
      } else
      // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096
      abort('initRandomDevice');
    };
  var randomFill = (view) => {
      // Lazily init on the first invocation.
      return (randomFill = initRandomFill())(view);
    };
  
  
  
  var PATH_FS = {
  resolve:(...args) => {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? args[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path != 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path);
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },
  relative:(from, to) => {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      },
  };
  
  
  
  var FS_stdin_getChar_buffer = [];
  
  var lengthBytesUTF8 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
        // unit, not a Unicode code point of the character! So decode
        // UTF16->UTF32->UTF8.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        var c = str.charCodeAt(i); // possibly a lead surrogate
        if (c <= 0x7F) {
          len++;
        } else if (c <= 0x7FF) {
          len += 2;
        } else if (c >= 0xD800 && c <= 0xDFFF) {
          len += 4; ++i;
        } else {
          len += 3;
        }
      }
      return len;
    };
  
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,
      // undefined and false each don't write out any bytes.
      if (!(maxBytesToWrite > 0))
        return 0;
  
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
      for (var i = 0; i < str.length; ++i) {
        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
        // unit, not a Unicode code point of the character! So decode
        // UTF16->UTF32->UTF8.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description
        // and https://www.ietf.org/rfc/rfc2279.txt
        // and https://tools.ietf.org/html/rfc3629
        var u = str.charCodeAt(i); // possibly a lead surrogate
        if (u >= 0xD800 && u <= 0xDFFF) {
          var u1 = str.charCodeAt(++i);
          u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
        }
        if (u <= 0x7F) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 0x7FF) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 0xC0 | (u >> 6);
          heap[outIdx++] = 0x80 | (u & 63);
        } else if (u <= 0xFFFF) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 0xE0 | (u >> 12);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
        } else {
          if (outIdx + 3 >= endIdx) break;
          heap[outIdx++] = 0xF0 | (u >> 18);
          heap[outIdx++] = 0x80 | ((u >> 12) & 63);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
        }
      }
      // Null-terminate the pointer to the buffer.
      heap[outIdx] = 0;
      return outIdx - startIdx;
    };
  /** @type {function(string, boolean=, number=)} */
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull) u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
      if (!FS_stdin_getChar_buffer.length) {
        var result = null;
        if (typeof window != 'undefined' &&
          typeof window.prompt == 'function') {
          // Browser.
          result = window.prompt('Input: ');  // returns null on cancel
          if (result !== null) {
            result += '\n';
          }
        } else
        {}
        if (!result) {
          return null;
        }
        FS_stdin_getChar_buffer = intArrayFromString(result, true);
      }
      return FS_stdin_getChar_buffer.shift();
    };
  var TTY = {
  ttys:[],
  init() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process.stdin.setEncoding('utf8');
        // }
      },
  shutdown() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process.stdin.pause();
        // }
      },
  register(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },
  stream_ops:{
  open(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },
  close(stream) {
          // flush any pending line data
          stream.tty.ops.fsync(stream.tty);
        },
  fsync(stream) {
          stream.tty.ops.fsync(stream.tty);
        },
  read(stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.atime = Date.now();
          }
          return bytesRead;
        },
  write(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.mtime = stream.node.ctime = Date.now();
          }
          return i;
        },
  },
  default_tty_ops:{
  get_char(tty) {
          return FS_stdin_getChar();
        },
  put_char(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },
  fsync(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output));
            tty.output = [];
          }
        },
  ioctl_tcgets(tty) {
          // typical setting
          return {
            c_iflag: 25856,
            c_oflag: 5,
            c_cflag: 191,
            c_lflag: 35387,
            c_cc: [
              0x03, 0x1c, 0x7f, 0x15, 0x04, 0x00, 0x01, 0x00, 0x11, 0x13, 0x1a, 0x00,
              0x12, 0x0f, 0x17, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            ]
          };
        },
  ioctl_tcsets(tty, optional_actions, data) {
          // currently just ignore
          return 0;
        },
  ioctl_tiocgwinsz(tty) {
          return [24, 80];
        },
  },
  default_tty1_ops:{
  put_char(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },
  fsync(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output));
            tty.output = [];
          }
        },
  },
  };
  
  
  var zeroMemory = (address, size) => {
      HEAPU8.fill(0, address, address + size);
    };
  
  var mmapAlloc = (size) => {
      size = alignMemory(size, 65536);
      var ptr = _emscripten_builtin_memalign(65536, size);
      if (ptr) zeroMemory(ptr, size);
      return ptr;
    };
  var MEMFS = {
  ops_table:null,
  mount(mount) {
        return MEMFS.createNode(null, '/', 16895, 0);
      },
  createNode(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(63);
        }
        MEMFS.ops_table ||= {
          dir: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              lookup: MEMFS.node_ops.lookup,
              mknod: MEMFS.node_ops.mknod,
              rename: MEMFS.node_ops.rename,
              unlink: MEMFS.node_ops.unlink,
              rmdir: MEMFS.node_ops.rmdir,
              readdir: MEMFS.node_ops.readdir,
              symlink: MEMFS.node_ops.symlink
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek
            }
          },
          file: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek,
              read: MEMFS.stream_ops.read,
              write: MEMFS.stream_ops.write,
              allocate: MEMFS.stream_ops.allocate,
              mmap: MEMFS.stream_ops.mmap,
              msync: MEMFS.stream_ops.msync
            }
          },
          link: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              readlink: MEMFS.node_ops.readlink
            },
            stream: {}
          },
          chrdev: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: FS.chrdev_stream_ops
          }
        };
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.atime = node.mtime = node.ctime = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
          parent.atime = parent.mtime = parent.ctime = node.atime;
        }
        return node;
      },
  getFileDataAsTypedArray(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },
  expandFileStorage(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
        // avoid overshooting the allocation cap by a very large margin.
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); // Allocate new storage.
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
      },
  resizeFileStorage(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
        }
      },
  node_ops:{
  getattr(node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.atime);
          attr.mtime = new Date(node.mtime);
          attr.ctime = new Date(node.ctime);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },
  setattr(node, attr) {
          for (const key of ["mode", "atime", "mtime", "ctime"]) {
            if (attr[key]) {
              node[key] = attr[key];
            }
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },
  lookup(parent, name) {
          throw MEMFS.doesNotExistError;
        },
  mknod(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },
  rename(old_node, new_dir, new_name) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {}
          if (new_node) {
            if (FS.isDir(old_node.mode)) {
              // if we're overwriting a directory at new_name, make sure it's empty.
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
            FS.hashRemoveNode(new_node);
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          new_dir.contents[new_name] = old_node;
          old_node.name = new_name;
          new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
        },
  unlink(parent, name) {
          delete parent.contents[name];
          parent.ctime = parent.mtime = Date.now();
        },
  rmdir(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.ctime = parent.mtime = Date.now();
        },
  readdir(node) {
          return ['.', '..', ...Object.keys(node.contents)];
        },
  symlink(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 0o777 | 40960, 0);
          node.link = oldpath;
          return node;
        },
  readlink(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        },
  },
  stream_ops:{
  read(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },
  write(stream, buffer, offset, length, position, canOwn) {
          // If the buffer is located in main memory (HEAP), and if
          // memory can grow, we can't hold on to references of the
          // memory buffer, as they may get invalidated. That means we
          // need to do copy its contents.
          if (buffer.buffer === HEAP8.buffer) {
            canOwn = false;
          }
  
          if (!length) return 0;
          var node = stream.node;
          node.mtime = node.ctime = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) {
            // Use typed array write which is available.
            node.contents.set(buffer.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },
  llseek(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },
  allocate(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },
  mmap(stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
            // We can't emulate MAP_SHARED when the file is not backed by the
            // buffer we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            if (contents) {
              // Try to avoid unnecessary slices.
              if (position > 0 || position + length < contents.length) {
                if (contents.subarray) {
                  contents = contents.subarray(position, position + length);
                } else {
                  contents = Array.prototype.slice.call(contents, position, position + length);
                }
              }
              HEAP8.set(contents, ptr);
            }
          }
          return { ptr, allocated };
        },
  msync(stream, buffer, offset, length, mmapFlags) {
          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        },
  },
  };
  
  
  
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
      FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
    };
  
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
      // Ensure plugins are ready.
      if (typeof Browser != 'undefined') Browser.init();
  
      var handled = false;
      preloadPlugins.forEach((plugin) => {
        if (handled) return;
        if (plugin['canHandle'](fullname)) {
          plugin['handle'](byteArray, fullname, finish, onerror);
          handled = true;
        }
      });
      return handled;
    };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
      // TODO we should allow people to just pass in a complete filename instead
      // of parent and name being that we just join them anyways
      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
      var dep = getUniqueRunDependency(`cp ${fullname}`); // might have several active requests for the same fullname
      function processData(byteArray) {
        function finish(byteArray) {
          preFinish?.();
          if (!dontCreateFile) {
            FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
          }
          onload?.();
          removeRunDependency(dep);
        }
        if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
          onerror?.();
          removeRunDependency(dep);
        })) {
          return;
        }
        finish(byteArray);
      }
      addRunDependency(dep);
      if (typeof url == 'string') {
        asyncLoad(url).then(processData, onerror);
      } else {
        processData(url);
      }
    };
  
  var FS_modeStringToFlags = (str) => {
      var flagModes = {
        'r': 0,
        'r+': 2,
        'w': 512 | 64 | 1,
        'w+': 512 | 64 | 2,
        'a': 1024 | 64 | 1,
        'a+': 1024 | 64 | 2,
      };
      var flags = flagModes[str];
      if (typeof flags == 'undefined') {
        throw new Error(`Unknown file open mode: ${str}`);
      }
      return flags;
    };
  
  var FS_getMode = (canRead, canWrite) => {
      var mode = 0;
      if (canRead) mode |= 292 | 73;
      if (canWrite) mode |= 146;
      return mode;
    };
  
  
  
  
  
  var LZ4 = {
  DIR_MODE:16895,
  FILE_MODE:33279,
  CHUNK_SIZE:-1,
  codec:null,
  init() {
        if (LZ4.codec) return;
        LZ4.codec = (() => {
          /*
  MiniLZ4: Minimal LZ4 block decoding and encoding.
  
  based off of node-lz4, https://github.com/pierrec/node-lz4
  
  ====
  Copyright (c) 2012 Pierre Curto
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
  ====
  
  changes have the same license
  */
  
  var MiniLZ4 = (function() {
  
  var exports = {};
  
  /**
   * Decode a block. Assumptions: input contains all sequences of a 
   * chunk, output is large enough to receive the decoded data.
   * If the output buffer is too small, an error will be thrown.
   * If the returned value is negative, an error occured at the returned offset.
   *
   * @param {ArrayBufferView} input input data
   * @param {ArrayBufferView} output output data
   * @param {number=} sIdx
   * @param {number=} eIdx
   * @return {number} number of decoded bytes
   * @private
   */
  exports.uncompress = function (input, output, sIdx, eIdx) {
  	sIdx = sIdx || 0
  	eIdx = eIdx || (input.length - sIdx)
  	// Process each sequence in the incoming data
  	for (var i = sIdx, n = eIdx, j = 0; i < n;) {
  		var token = input[i++]
  
  		// Literals
  		var literals_length = (token >> 4)
  		if (literals_length > 0) {
  			// length of literals
  			var l = literals_length + 240
  			while (l === 255) {
  				l = input[i++]
  				literals_length += l
  			}
  
  			// Copy the literals
  			var end = i + literals_length
  			while (i < end) output[j++] = input[i++]
  
  			// End of buffer?
  			if (i === n) return j
  		}
  
  		// Match copy
  		// 2 bytes offset (little endian)
  		var offset = input[i++] | (input[i++] << 8)
  
  		// XXX 0 is an invalid offset value
  		if (offset === 0) return j
  		if (offset > j) return -(i-2)
  
  		// length of match copy
  		var match_length = (token & 0xf)
  		var l = match_length + 240
  		while (l === 255) {
  			l = input[i++]
  			match_length += l
  		}
  
  		// Copy the match
  		var pos = j - offset // position of the match copy in the current output
  		var end = j + match_length + 4 // minmatch = 4
  		while (j < end) output[j++] = output[pos++]
  	}
  
  	return j
  }
  
  var
  	maxInputSize	= 0x7E000000
  ,	minMatch		= 4
  // uint32() optimization
  ,	hashLog			= 16
  ,	hashShift		= (minMatch * 8) - hashLog
  ,	hashSize		= 1 << hashLog
  
  ,	copyLength		= 8
  ,	lastLiterals	= 5
  ,	mfLimit			= copyLength + minMatch
  ,	skipStrength	= 6
  
  ,	mlBits  		= 4
  ,	mlMask  		= (1 << mlBits) - 1
  ,	runBits 		= 8 - mlBits
  ,	runMask 		= (1 << runBits) - 1
  
  ,	hasher 			= /* XXX uint32( */ 2654435761 /* ) */
  
  assert(hashShift === 16);
  var hashTable = new Int16Array(1<<16);
  var empty = new Int16Array(hashTable.length);
  
  // CompressBound returns the maximum length of a lz4 block, given it's uncompressed length
  exports.compressBound = function (isize) {
  	return isize > maxInputSize
  		? 0
  		: (isize + (isize/255) + 16) | 0
  }
  
  /** @param {number=} sIdx
  	@param {number=} eIdx */
  exports.compress = function (src, dst, sIdx, eIdx) {
  	hashTable.set(empty);
  	return compressBlock(src, dst, 0, sIdx || 0, eIdx || dst.length)
  }
  
  function compressBlock (src, dst, pos, sIdx, eIdx) {
  	// XXX var Hash = uint32() // Reusable unsigned 32 bits integer
  	var dpos = sIdx
  	var dlen = eIdx - sIdx
  	var anchor = 0
  
  	if (src.length >= maxInputSize) throw new Error("input too large")
  
  	// Minimum of input bytes for compression (LZ4 specs)
  	if (src.length > mfLimit) {
  		var n = exports.compressBound(src.length)
  		if ( dlen < n ) throw Error("output too small: " + dlen + " < " + n)
  
  		var 
  			step  = 1
  		,	findMatchAttempts = (1 << skipStrength) + 3
  		// Keep last few bytes incompressible (LZ4 specs):
  		// last 5 bytes must be literals
  		,	srcLength = src.length - mfLimit
  
  		while (pos + minMatch < srcLength) {
  			// Find a match
  			// min match of 4 bytes aka sequence
  			var sequenceLowBits = src[pos+1]<<8 | src[pos]
  			var sequenceHighBits = src[pos+3]<<8 | src[pos+2]
  			// compute hash for the current sequence
  			var hash = Math.imul(sequenceLowBits | (sequenceHighBits << 16), hasher) >>> hashShift;
  			/* XXX Hash.fromBits(sequenceLowBits, sequenceHighBits)
  							.multiply(hasher)
  							.shiftr(hashShift)
  							.toNumber() */
  			// get the position of the sequence matching the hash
  			// NB. since 2 different sequences may have the same hash
  			// it is double-checked below
  			// do -1 to distinguish between initialized and uninitialized values
  			var ref = hashTable[hash] - 1
  			// save position of current sequence in hash table
  			hashTable[hash] = pos + 1
  
  			// first reference or within 64k limit or current sequence !== hashed one: no match
  			if ( ref < 0 ||
  				((pos - ref) >>> 16) > 0 ||
  				(
  					((src[ref+3]<<8 | src[ref+2]) != sequenceHighBits) ||
  					((src[ref+1]<<8 | src[ref]) != sequenceLowBits )
  				)
  			) {
  				// increase step if nothing found within limit
  				step = findMatchAttempts++ >> skipStrength
  				pos += step
  				continue
  			}
  
  			findMatchAttempts = (1 << skipStrength) + 3
  
  			// got a match
  			var literals_length = pos - anchor
  			var offset = pos - ref
  
  			// minMatch already verified
  			pos += minMatch
  			ref += minMatch
  
  			// move to the end of the match (>=minMatch)
  			var match_length = pos
  			while (pos < srcLength && src[pos] == src[ref]) {
  				pos++
  				ref++
  			}
  
  			// match length
  			match_length = pos - match_length
  
  			// token
  			var token = match_length < mlMask ? match_length : mlMask
  
  			// encode literals length
  			if (literals_length >= runMask) {
  				// add match length to the token
  				dst[dpos++] = (runMask << mlBits) + token
  				for (var len = literals_length - runMask; len > 254; len -= 255) {
  					dst[dpos++] = 255
  				}
  				dst[dpos++] = len
  			} else {
  				// add match length to the token
  				dst[dpos++] = (literals_length << mlBits) + token
  			}
  
  			// write literals
  			for (var i = 0; i < literals_length; i++) {
  				dst[dpos++] = src[anchor+i]
  			}
  
  			// encode offset
  			dst[dpos++] = offset
  			dst[dpos++] = (offset >> 8)
  
  			// encode match length
  			if (match_length >= mlMask) {
  				match_length -= mlMask
  				while (match_length >= 255) {
  					match_length -= 255
  					dst[dpos++] = 255
  				}
  
  				dst[dpos++] = match_length
  			}
  
  			anchor = pos
  		}
  	}
  
  	// cannot compress input
  	if (anchor == 0) return 0
  
  	// Write last literals
  	// encode literals length
  	literals_length = src.length - anchor
  	if (literals_length >= runMask) {
  		// add match length to the token
  		dst[dpos++] = (runMask << mlBits)
  		for (var ln = literals_length - runMask; ln > 254; ln -= 255) {
  			dst[dpos++] = 255
  		}
  		dst[dpos++] = ln
  	} else {
  		// add match length to the token
  		dst[dpos++] = (literals_length << mlBits)
  	}
  
  	// write literals
  	pos = anchor
  	while (pos < src.length) {
  		dst[dpos++] = src[pos++]
  	}
  
  	return dpos
  }
  
  exports.CHUNK_SIZE = 2048; // musl libc does readaheads of 1024 bytes, so a multiple of that is a good idea
  
  exports.compressPackage = function(data, verify) {
    if (verify) {
      var temp = new Uint8Array(exports.CHUNK_SIZE);
    }
    // compress the data in chunks
    assert(data instanceof ArrayBuffer);
    data = new Uint8Array(data);
    console.log('compressing package of size ' + data.length);
    var compressedChunks = [];
    var successes = [];
    var offset = 0;
    var total = 0;
    while (offset < data.length) {
      var chunk = data.subarray(offset, offset + exports.CHUNK_SIZE);
      //console.log('compress a chunk ' + [offset, total, data.length]);
      offset += exports.CHUNK_SIZE;
      var bound = exports.compressBound(chunk.length);
      var compressed = new Uint8Array(bound);
      var compressedSize = exports.compress(chunk, compressed);
      if (compressedSize > 0) {
        assert(compressedSize <= bound);
        compressed = compressed.subarray(0, compressedSize);
        compressedChunks.push(compressed);
        total += compressedSize;
        successes.push(1);
        if (verify) {
          var back = exports.uncompress(compressed, temp);
          assert(back === chunk.length, [back, chunk.length]);
          for (var i = 0; i < chunk.length; i++) {
            assert(chunk[i] === temp[i]);
          }
        }
      } else {
        assert(compressedSize === 0);
        // failure to compress :(
        compressedChunks.push(chunk);
        total += chunk.length; // last chunk may not be the full exports.CHUNK_SIZE size
        successes.push(0);
      }
    }
    data = null; // XXX null out pack['data'] too?
    var compressedData = {
      'data': new Uint8Array(total + exports.CHUNK_SIZE*2), // store all the compressed data, plus room for two cached decompressed chunk, in one fast array
      'cachedOffset': total,
      'cachedIndexes': [-1, -1], // cache last two blocks, so that reading 1,2,3 + preloading another block won't trigger decompress thrashing
      'cachedChunks': [null, null],
      'offsets': [], // chunk# => start in compressed data
      'sizes': [],
      'successes': successes, // 1 if chunk is compressed
    };
    offset = 0;
    for (var i = 0; i < compressedChunks.length; i++) {
      compressedData['data'].set(compressedChunks[i], offset);
      compressedData['offsets'][i] = offset;
      compressedData['sizes'][i] = compressedChunks[i].length
      offset += compressedChunks[i].length;
    }
    console.log('compressed package into ' + [compressedData['data'].length]);
    assert(offset === total);
    return compressedData;
  };
  
  assert(exports.CHUNK_SIZE < (1 << 15)); // we use 16-bit ints as the type of the hash table, chunk size must be smaller
  
  return exports;
  
  })();
  
  if (typeof module != 'undefined') {
    module.exports = MiniLZ4;
  }
  ;
          return MiniLZ4;
        })();
        LZ4.CHUNK_SIZE = LZ4.codec.CHUNK_SIZE;
      },
  loadPackage(pack, preloadPlugin) {
        LZ4.init();
        var compressedData = pack['compressedData'] || LZ4.codec.compressPackage(pack['data']);
        assert(compressedData['cachedIndexes'].length === compressedData['cachedChunks'].length);
        for (var i = 0; i < compressedData['cachedIndexes'].length; i++) {
          compressedData['cachedIndexes'][i] = -1;
          compressedData['cachedChunks'][i] = compressedData['data'].subarray(compressedData['cachedOffset'] + i*LZ4.CHUNK_SIZE,
                                                                        compressedData['cachedOffset'] + (i+1)*LZ4.CHUNK_SIZE);
          assert(compressedData['cachedChunks'][i].length === LZ4.CHUNK_SIZE);
        }
        pack['metadata'].files.forEach((file) => {
          var dir = PATH.dirname(file.filename);
          var name = PATH.basename(file.filename);
          FS.createPath('', dir, true, true);
          var parent = FS.analyzePath(dir).object;
          LZ4.createNode(parent, name, LZ4.FILE_MODE, 0, {
            compressedData,
            start: file.start,
            end: file.end,
          });
        });
        // Preload files if necessary. This code is largely similar to
        // createPreloadedFile in library_fs.js. However, a main difference here
        // is that we only decompress the file if it can be preloaded.
        // Abstracting out the common parts seems to be more effort than it is
        // worth.
        if (preloadPlugin) {
          Browser.init();
          pack['metadata'].files.forEach((file) => {
            var handled = false;
            var fullname = file.filename;
            preloadPlugins.forEach((plugin) => {
              if (handled) return;
              if (plugin['canHandle'](fullname)) {
                var dep = getUniqueRunDependency('fp ' + fullname);
                addRunDependency(dep);
                var finish = () => removeRunDependency(dep);
                var byteArray = FS.readFile(fullname);
                plugin['handle'](byteArray, fullname, finish, finish);
                handled = true;
              }
            });
          });
        }
      },
  createNode(parent, name, mode, dev, contents, mtime) {
        var node = FS.createNode(parent, name, mode);
        node.mode = mode;
        node.node_ops = LZ4.node_ops;
        node.stream_ops = LZ4.stream_ops;
        this.atime = this.mtime = this.ctime = (mtime || new Date).getTime();
        assert(LZ4.FILE_MODE !== LZ4.DIR_MODE);
        if (mode === LZ4.FILE_MODE) {
          node.size = contents.end - contents.start;
          node.contents = contents;
        } else {
          node.size = 4096;
          node.contents = {};
        }
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },
  node_ops:{
  getattr(node) {
          return {
            dev: 1,
            ino: node.id,
            mode: node.mode,
            nlink: 1,
            uid: 0,
            gid: 0,
            rdev: 0,
            size: node.size,
            atime: new Date(node.atime),
            mtime: new Date(node.mtime),
            ctime: new Date(node.ctime),
            blksize: 4096,
            blocks: Math.ceil(node.size / 4096),
          };
        },
  setattr(node, attr) {
          for (const key of ['mode', 'atime', 'mtime', 'ctime']) {
            if (attr[key]) {
              node[key] = attr[key];
            }
          }
        },
  lookup(parent, name) {
          throw new FS.ErrnoError(44);
        },
  mknod(parent, name, mode, dev) {
          throw new FS.ErrnoError(63);
        },
  rename(oldNode, newDir, newName) {
          throw new FS.ErrnoError(63);
        },
  unlink(parent, name) {
          throw new FS.ErrnoError(63);
        },
  rmdir(parent, name) {
          throw new FS.ErrnoError(63);
        },
  readdir(node) {
          throw new FS.ErrnoError(63);
        },
  symlink(parent, newName, oldPath) {
          throw new FS.ErrnoError(63);
        },
  },
  stream_ops:{
  read(stream, buffer, offset, length, position) {
          //out('LZ4 read ' + [offset, length, position]);
          length = Math.min(length, stream.node.size - position);
          if (length <= 0) return 0;
          var contents = stream.node.contents;
          var compressedData = contents.compressedData;
          var written = 0;
          while (written < length) {
            var start = contents.start + position + written; // start index in uncompressed data
            var desired = length - written;
            //out('current read: ' + ['start', start, 'desired', desired]);
            var chunkIndex = Math.floor(start / LZ4.CHUNK_SIZE);
            var compressedStart = compressedData['offsets'][chunkIndex];
            var compressedSize = compressedData['sizes'][chunkIndex];
            var currChunk;
            if (compressedData['successes'][chunkIndex]) {
              var found = compressedData['cachedIndexes'].indexOf(chunkIndex);
              if (found >= 0) {
                currChunk = compressedData['cachedChunks'][found];
              } else {
                // decompress the chunk
                compressedData['cachedIndexes'].pop();
                compressedData['cachedIndexes'].unshift(chunkIndex);
                currChunk = compressedData['cachedChunks'].pop();
                compressedData['cachedChunks'].unshift(currChunk);
                if (compressedData['debug']) {
                  out('decompressing chunk ' + chunkIndex);
                  Module['decompressedChunks'] = (Module['decompressedChunks'] || 0) + 1;
                }
                var compressed = compressedData['data'].subarray(compressedStart, compressedStart + compressedSize);
                //var t = Date.now();
                var originalSize = LZ4.codec.uncompress(compressed, currChunk);
                //out('decompress time: ' + (Date.now() - t));
                if (chunkIndex < compressedData['successes'].length-1) assert(originalSize === LZ4.CHUNK_SIZE); // all but the last chunk must be full-size
              }
            } else {
              // uncompressed
              currChunk = compressedData['data'].subarray(compressedStart, compressedStart + LZ4.CHUNK_SIZE);
            }
            var startInChunk = start % LZ4.CHUNK_SIZE;
            var endInChunk = Math.min(startInChunk + desired, LZ4.CHUNK_SIZE);
            buffer.set(currChunk.subarray(startInChunk, endInChunk), offset + written);
            var currWritten = endInChunk - startInChunk;
            written += currWritten;
          }
          return written;
        },
  write(stream, buffer, offset, length, position) {
          throw new FS.ErrnoError(29);
        },
  llseek(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.size;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },
  },
  };
  var FS = {
  root:null,
  mounts:[],
  devices:{
  },
  streams:[],
  nextInode:1,
  nameTable:null,
  currentPath:"/",
  initialized:false,
  ignorePermissions:true,
  ErrnoError:class {
        name = 'ErrnoError';
        // We set the `name` property to be able to identify `FS.ErrnoError`
        // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
        // - when using PROXYFS, an error can come from an underlying FS
        // as different FS objects have their own FS.ErrnoError each,
        // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
        // we'll use the reliable test `err.name == "ErrnoError"` instead
        constructor(errno) {
          this.errno = errno;
        }
      },
  filesystems:null,
  syncFSRequests:0,
  readFiles:{
  },
  FSStream:class {
        shared = {};
        get object() {
          return this.node;
        }
        set object(val) {
          this.node = val;
        }
        get isRead() {
          return (this.flags & 2097155) !== 1;
        }
        get isWrite() {
          return (this.flags & 2097155) !== 0;
        }
        get isAppend() {
          return (this.flags & 1024);
        }
        get flags() {
          return this.shared.flags;
        }
        set flags(val) {
          this.shared.flags = val;
        }
        get position() {
          return this.shared.position;
        }
        set position(val) {
          this.shared.position = val;
        }
      },
  FSNode:class {
        node_ops = {};
        stream_ops = {};
        readMode = 292 | 73;
        writeMode = 146;
        mounted = null;
        constructor(parent, name, mode, rdev) {
          if (!parent) {
            parent = this;  // root node sets parent to itself
          }
          this.parent = parent;
          this.mount = parent.mount;
          this.id = FS.nextInode++;
          this.name = name;
          this.mode = mode;
          this.rdev = rdev;
          this.atime = this.mtime = this.ctime = Date.now();
        }
        get read() {
          return (this.mode & this.readMode) === this.readMode;
        }
        set read(val) {
          val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
        }
        get write() {
          return (this.mode & this.writeMode) === this.writeMode;
        }
        set write(val) {
          val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
        }
        get isFolder() {
          return FS.isDir(this.mode);
        }
        get isDevice() {
          return FS.isChrdev(this.mode);
        }
      },
  lookupPath(path, opts = {}) {
        if (!path) return { path: '', node: null };
        opts.follow_mount ??= true
  
        if (!PATH.isAbs(path)) {
          path = FS.cwd() + '/' + path;
        }
  
        // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
        linkloop: for (var nlinks = 0; nlinks < 40; nlinks++) {
          // split the absolute path
          var parts = path.split('/').filter((p) => !!p && (p !== '.'));
  
          // start at the root
          var current = FS.root;
          var current_path = '/';
  
          for (var i = 0; i < parts.length; i++) {
            var islast = (i === parts.length-1);
            if (islast && opts.parent) {
              // stop resolving
              break;
            }
  
            if (parts[i] === '..') {
              current_path = PATH.dirname(current_path);
              current = current.parent;
              continue;
            }
  
            current_path = PATH.join2(current_path, parts[i]);
            try {
              current = FS.lookupNode(current, parts[i]);
            } catch (e) {
              // if noent_okay is true, suppress a ENOENT in the last component
              // and return an object with an undefined node. This is needed for
              // resolving symlinks in the path when creating a file.
              if ((e?.errno === 44) && islast && opts.noent_okay) {
                return { path: current_path };
              }
              throw e;
            }
  
            // jump to the mount's root node if this is a mountpoint
            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
              current = current.mounted.root;
            }
  
            // by default, lookupPath will not follow a symlink if it is the final path component.
            // setting opts.follow = true will override this behavior.
            if (FS.isLink(current.mode) && (!islast || opts.follow)) {
              if (!current.node_ops.readlink) {
                throw new FS.ErrnoError(52);
              }
              var link = current.node_ops.readlink(current);
              if (!PATH.isAbs(link)) {
                link = PATH.dirname(current_path) + '/' + link;
              }
              path = link + '/' + parts.slice(i + 1).join('/');
              continue linkloop;
            }
          }
          return { path: current_path, node: current };
        }
        throw new FS.ErrnoError(32);
      },
  getPath(node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? `${mount}/${path}` : mount + path;
          }
          path = path ? `${node.name}/${path}` : node.name;
          node = node.parent;
        }
      },
  hashName(parentid, name) {
        var hash = 0;
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },
  hashAddNode(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },
  hashRemoveNode(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },
  lookupNode(parent, name) {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },
  createNode(parent, name, mode, rdev) {
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },
  destroyNode(node) {
        FS.hashRemoveNode(node);
      },
  isRoot(node) {
        return node === node.parent;
      },
  isMountpoint(node) {
        return !!node.mounted;
      },
  isFile(mode) {
        return (mode & 61440) === 32768;
      },
  isDir(mode) {
        return (mode & 61440) === 16384;
      },
  isLink(mode) {
        return (mode & 61440) === 40960;
      },
  isChrdev(mode) {
        return (mode & 61440) === 8192;
      },
  isBlkdev(mode) {
        return (mode & 61440) === 24576;
      },
  isFIFO(mode) {
        return (mode & 61440) === 4096;
      },
  isSocket(mode) {
        return (mode & 49152) === 49152;
      },
  flagsToPermissionString(flag) {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },
  nodePermissions(node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.includes('r') && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes('w') && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes('x') && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },
  mayLookup(dir) {
        if (!FS.isDir(dir.mode)) return 54;
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },
  mayCreate(dir, name) {
        if (!FS.isDir(dir.mode)) {
          return 54;
        }
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },
  mayDelete(dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },
  mayOpen(node, flags) {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write
              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },
  MAX_OPEN_FDS:4096,
  nextfd() {
        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },
  getStreamChecked(fd) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        return stream;
      },
  getStream:(fd) => FS.streams[fd],
  createStream(stream, fd = -1) {
  
        // clone it, so we can return an instance of FSStream
        stream = Object.assign(new FS.FSStream(), stream);
        if (fd == -1) {
          fd = FS.nextfd();
        }
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },
  closeStream(fd) {
        FS.streams[fd] = null;
      },
  dupStream(origStream, fd = -1) {
        var stream = FS.createStream(origStream, fd);
        stream.stream_ops?.dup?.(stream);
        return stream;
      },
  chrdev_stream_ops:{
  open(stream) {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          stream.stream_ops.open?.(stream);
        },
  llseek() {
          throw new FS.ErrnoError(70);
        },
  },
  major:(dev) => ((dev) >> 8),
  minor:(dev) => ((dev) & 0xff),
  makedev:(ma, mi) => ((ma) << 8 | (mi)),
  registerDevice(dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },
  getDevice:(dev) => FS.devices[dev],
  getMounts(mount) {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push(...m.mounts);
        }
  
        return mounts;
      },
  syncfs(populate, callback) {
        if (typeof populate == 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
  
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },
  mount(type, opts, mountpoint) {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
  
        var mount = {
          type,
          opts,
          mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },
  unmount(mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },
  lookup(parent, name) {
        return parent.node_ops.lookup(parent, name);
      },
  mknod(path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },
  statfs(path) {
  
        // NOTE: None of the defaults here are true. We're just returning safe and
        //       sane values.
        var rtn = {
          bsize: 4096,
          frsize: 4096,
          blocks: 1e6,
          bfree: 5e5,
          bavail: 5e5,
          files: FS.nextInode,
          ffree: FS.nextInode - 1,
          fsid: 42,
          flags: 2,
          namelen: 255,
        };
  
        var parent = FS.lookupPath(path, {follow: true}).node;
        if (parent?.node_ops.statfs) {
          Object.assign(rtn, parent.node_ops.statfs(parent.mount.opts.root));
        }
        return rtn;
      },
  create(path, mode = 0o666) {
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },
  mkdir(path, mode = 0o777) {
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },
  mkdirTree(path, mode) {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },
  mkdev(path, mode, dev) {
        if (typeof dev == 'undefined') {
          dev = mode;
          mode = 0o666;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },
  symlink(oldpath, newpath) {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },
  rename(old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
  
        // let the errors from non existent directories percolate up
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
  
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        // new path should not be an ancestor of the old path
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
          // update old node (we do this here to avoid each backend
          // needing to)
          old_node.parent = new_dir;
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
      },
  rmdir(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },
  readdir(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },
  unlink(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          // According to POSIX, we should map EISDIR to EPERM, but
          // we instead do what Linux does (and we must, as we use
          // the musl linux libc).
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },
  readlink(path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return link.node_ops.readlink(link);
      },
  stat(path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },
  lstat(path) {
        return FS.stat(path, true);
      },
  chmod(path, mode, dontFollow) {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          ctime: Date.now()
        });
      },
  lchmod(path, mode) {
        FS.chmod(path, mode, true);
      },
  fchmod(fd, mode) {
        var stream = FS.getStreamChecked(fd);
        FS.chmod(stream.node, mode);
      },
  chown(path, uid, gid, dontFollow) {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },
  lchown(path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },
  fchown(fd, uid, gid) {
        var stream = FS.getStreamChecked(fd);
        FS.chown(stream.node, uid, gid);
      },
  truncate(path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },
  ftruncate(fd, len) {
        var stream = FS.getStreamChecked(fd);
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },
  utime(path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          atime: atime,
          mtime: mtime
        });
      },
  open(path, flags, mode = 0o666) {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == 'string' ? FS_modeStringToFlags(flags) : flags;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path == 'object') {
          node = path;
        } else {
          // noent_okay makes it so that if the final component of the path
          // doesn't exist, lookupPath returns `node: undefined`. `path` will be
          // updated to point to the target of all symlinks.
          var lookup = FS.lookupPath(path, {
            follow: !(flags & 131072),
            noent_okay: true
          });
          node = lookup.node;
          path = lookup.path;
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // do truncation if necessary
        if ((flags & 512) && !created) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512 | 131072);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        });
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
          }
        }
        return stream;
      },
  close(stream) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },
  isClosed(stream) {
        return stream.fd === null;
      },
  llseek(stream, offset, whence) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },
  read(stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },
  write(stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },
  allocate(stream, offset, length) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },
  mmap(stream, length, position, prot, flags) {
        // User requests writing to file (prot & PROT_WRITE != 0).
        // Checking if we have permissions to write to the file unless
        // MAP_PRIVATE flag is set. According to POSIX spec it is possible
        // to write to file opened in read-only mode with MAP_PRIVATE flag,
        // as all modifications will be visible only in the memory of
        // the current process.
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        if (!length) {
          throw new FS.ErrnoError(28);
        }
        return stream.stream_ops.mmap(stream, length, position, prot, flags);
      },
  msync(stream, buffer, offset, length, mmapFlags) {
        if (!stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },
  ioctl(stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },
  readFile(path, opts = {}) {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error(`Invalid encoding type "${opts.encoding}"`);
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },
  writeFile(path, data, opts = {}) {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data == 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },
  cwd:() => FS.currentPath,
  chdir(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },
  createDefaultDirectories() {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },
  createDefaultDevices() {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset, length, pos) => length,
          llseek: () => 0,
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using err() rather than out()
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        // use a buffer to avoid overhead of individual crypto calls per byte
        var randomBuffer = new Uint8Array(1024), randomLeft = 0;
        var randomByte = () => {
          if (randomLeft === 0) {
            randomLeft = randomFill(randomBuffer).byteLength;
          }
          return randomBuffer[--randomLeft];
        };
        FS.createDevice('/dev', 'random', randomByte);
        FS.createDevice('/dev', 'urandom', randomByte);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },
  createSpecialDirectories() {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the
        // name of the stream for fd 6 (see test_unistd_ttyname)
        FS.mkdir('/proc');
        var proc_self = FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount() {
            var node = FS.createNode(proc_self, 'fd', 16895, 73);
            node.stream_ops = {
              llseek: MEMFS.stream_ops.llseek,
            };
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: () => stream.path },
                  id: fd + 1,
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              },
              readdir() {
                return Array.from(FS.streams.entries())
                  .filter(([k, v]) => v)
                  .map(([k, v]) => k.toString());
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },
  createStandardStreams(input, output, error) {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (input) {
          FS.createDevice('/dev', 'stdin', input);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (output) {
          FS.createDevice('/dev', 'stdout', null, output);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (error) {
          FS.createDevice('/dev', 'stderr', null, error);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 0);
        var stdout = FS.open('/dev/stdout', 1);
        var stderr = FS.open('/dev/stderr', 1);
      },
  staticInit() {
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
        };
      },
  init(input, output, error) {
        FS.initialized = true;
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        input ??= Module['stdin'];
        output ??= Module['stdout'];
        error ??= Module['stderr'];
  
        FS.createStandardStreams(input, output, error);
      },
  quit() {
        FS.initialized = false;
        // force-flush all streams, so we get musl std streams printed out
        // close all of our streams
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },
  findObject(path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (!ret.exists) {
          return null;
        }
        return ret.object;
      },
  analyzePath(path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },
  createPath(parent, path, canRead, canWrite) {
        parent = typeof parent == 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },
  createFile(parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS_getMode(canRead, canWrite);
        return FS.create(path, mode);
      },
  createDataFile(parent, name, data, canRead, canWrite, canOwn) {
        var path = name;
        if (parent) {
          parent = typeof parent == 'string' ? parent : FS.getPath(parent);
          path = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS_getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data == 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
      },
  createDevice(parent, name, input, output) {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS_getMode(!!input, !!output);
        FS.createDevice.major ??= 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open(stream) {
            stream.seekable = false;
          },
          close(stream) {
            // flush any pending line data
            if (output?.buffer?.length) {
              output(10);
            }
          },
          read(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.atime = Date.now();
            }
            return bytesRead;
          },
          write(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.mtime = stream.node.ctime = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },
  forceLoadFile(obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        if (typeof XMLHttpRequest != 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else { // Command-line.
          try {
            obj.contents = readBinary(obj.url);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        }
      },
  createLazyFile(parent, name, url, canRead, canWrite) {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array).
        // Actual getting is abstracted away for eventual reuse.
        class LazyUint8Array {
          lengthKnown = false;
          chunks = []; // Loaded chunks. Index is the chunk number
          get(idx) {
            if (idx > this.length-1 || idx < 0) {
              return undefined;
            }
            var chunkOffset = idx % this.chunkSize;
            var chunkNum = (idx / this.chunkSize)|0;
            return this.getter(chunkNum)[chunkOffset];
          }
          setDataGetter(getter) {
            this.getter = getter;
          }
          cacheLength() {
            // Find length
            var xhr = new XMLHttpRequest();
            xhr.open('HEAD', url, false);
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
            var chunkSize = 1024*1024; // Chunk size in bytes
  
            if (!hasByteServing) chunkSize = datalength;
  
            // Function to get a range from the remote URL.
            var doXHR = (from, to) => {
              if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
              if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
              // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
              var xhr = new XMLHttpRequest();
              xhr.open('GET', url, false);
              if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
              // Some hints to the browser that we want binary data.
              xhr.responseType = 'arraybuffer';
              if (xhr.overrideMimeType) {
                xhr.overrideMimeType('text/plain; charset=x-user-defined');
              }
  
              xhr.send(null);
              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
              if (xhr.response !== undefined) {
                return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));
              }
              return intArrayFromString(xhr.responseText || '', true);
            };
            var lazyArray = this;
            lazyArray.setDataGetter((chunkNum) => {
              var start = chunkNum * chunkSize;
              var end = (chunkNum+1) * chunkSize - 1; // including this byte
              end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
              if (typeof lazyArray.chunks[chunkNum] == 'undefined') {
                lazyArray.chunks[chunkNum] = doXHR(start, end);
              }
              if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');
              return lazyArray.chunks[chunkNum];
            });
  
            if (usesGzip || !datalength) {
              // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
              chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
              datalength = this.getter(0).length;
              chunkSize = datalength;
              out("LazyFiles on gzip forces download of the whole file when length is accessed");
            }
  
            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
          }
          get length() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._length;
          }
          get chunkSize() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._chunkSize;
          }
        }
  
        if (typeof XMLHttpRequest != 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperties(node, {
          usedBytes: {
            get: function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = (...args) => {
            FS.forceLoadFile(node);
            return fn(...args);
          };
        });
        function writeChunks(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        }
        // use a custom read function
        stream_ops.read = (stream, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          return writeChunks(stream, buffer, offset, length, position)
        };
        // use a custom mmap function
        stream_ops.mmap = (stream, length, position, prot, flags) => {
          FS.forceLoadFile(node);
          var ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          writeChunks(stream, HEAP8, ptr, length, position);
          return { ptr, allocated: true };
        };
        node.stream_ops = stream_ops;
        return node;
      },
  };
  
  var SYSCALLS = {
  DEFAULT_POLLMASK:5,
  calculateAt(dirfd, path, allowEmpty) {
        if (PATH.isAbs(path)) {
          return path;
        }
        // relative path
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = SYSCALLS.getStreamFromFD(dirfd);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);;
          }
          return dir;
        }
        return dir + '/' + path;
      },
  doStat(func, path, buf) {
        var stat = func(path);
        HEAP32[((buf)>>2)] = stat.dev;
        HEAP32[(((buf)+(4))>>2)] = stat.mode;
        HEAPU32[(((buf)+(8))>>2)] = stat.nlink;
        HEAP32[(((buf)+(12))>>2)] = stat.uid;
        HEAP32[(((buf)+(16))>>2)] = stat.gid;
        HEAP32[(((buf)+(20))>>2)] = stat.rdev;
        HEAP64[(((buf)+(24))>>3)] = BigInt(stat.size);
        HEAP32[(((buf)+(32))>>2)] = 4096;
        HEAP32[(((buf)+(36))>>2)] = stat.blocks;
        var atime = stat.atime.getTime();
        var mtime = stat.mtime.getTime();
        var ctime = stat.ctime.getTime();
        HEAP64[(((buf)+(40))>>3)] = BigInt(Math.floor(atime / 1000));
        HEAPU32[(((buf)+(48))>>2)] = (atime % 1000) * 1000 * 1000;
        HEAP64[(((buf)+(56))>>3)] = BigInt(Math.floor(mtime / 1000));
        HEAPU32[(((buf)+(64))>>2)] = (mtime % 1000) * 1000 * 1000;
        HEAP64[(((buf)+(72))>>3)] = BigInt(Math.floor(ctime / 1000));
        HEAPU32[(((buf)+(80))>>2)] = (ctime % 1000) * 1000 * 1000;
        HEAP64[(((buf)+(88))>>3)] = BigInt(stat.ino);
        return 0;
      },
  doMsync(addr, stream, len, flags, offset) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (flags & 2) {
          // MAP_PRIVATE calls need not to be synced back to underlying fs
          return 0;
        }
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },
  getStreamFromFD(fd) {
        var stream = FS.getStreamChecked(fd);
        return stream;
      },
  varargs:undefined,
  getStr(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },
  };
  var ___syscall__newselect = function (nfds, readfds, writefds, exceptfds, timeout) {
  try {
  
      // readfds are supported,
      // writefds checks socket open status
      // exceptfds are supported, although on web, such exceptional conditions never arise in web sockets
      //                          and so the exceptfds list will always return empty.
      // timeout is supported, although on SOCKFS and PIPEFS these are ignored and always treated as 0 - fully async
  
      var total = 0;
  
      var srcReadLow = (readfds ? HEAP32[((readfds)>>2)] : 0),
          srcReadHigh = (readfds ? HEAP32[(((readfds)+(4))>>2)] : 0);
      var srcWriteLow = (writefds ? HEAP32[((writefds)>>2)] : 0),
          srcWriteHigh = (writefds ? HEAP32[(((writefds)+(4))>>2)] : 0);
      var srcExceptLow = (exceptfds ? HEAP32[((exceptfds)>>2)] : 0),
          srcExceptHigh = (exceptfds ? HEAP32[(((exceptfds)+(4))>>2)] : 0);
  
      var dstReadLow = 0,
          dstReadHigh = 0;
      var dstWriteLow = 0,
          dstWriteHigh = 0;
      var dstExceptLow = 0,
          dstExceptHigh = 0;
  
      var allLow = (readfds ? HEAP32[((readfds)>>2)] : 0) |
                   (writefds ? HEAP32[((writefds)>>2)] : 0) |
                   (exceptfds ? HEAP32[((exceptfds)>>2)] : 0);
      var allHigh = (readfds ? HEAP32[(((readfds)+(4))>>2)] : 0) |
                    (writefds ? HEAP32[(((writefds)+(4))>>2)] : 0) |
                    (exceptfds ? HEAP32[(((exceptfds)+(4))>>2)] : 0);
  
      var check = (fd, low, high, val) => fd < 32 ? (low & val) : (high & val);
  
      for (var fd = 0; fd < nfds; fd++) {
        var mask = 1 << (fd % 32);
        if (!(check(fd, allLow, allHigh, mask))) {
          continue;  // index isn't in the set
        }
  
        var stream = SYSCALLS.getStreamFromFD(fd);
  
        var flags = SYSCALLS.DEFAULT_POLLMASK;
  
        if (stream.stream_ops.poll) {
          var timeoutInMillis = -1;
          if (timeout) {
            // select(2) is declared to accept "struct timeval { time_t tv_sec; suseconds_t tv_usec; }".
            // However, musl passes the two values to the syscall as an array of long values.
            // Note that sizeof(time_t) != sizeof(long) in wasm32. The former is 8, while the latter is 4.
            // This means using "C_STRUCTS.timeval.tv_usec" leads to a wrong offset.
            // So, instead, we use POINTER_SIZE.
            var tv_sec = (readfds ? HEAP32[((timeout)>>2)] : 0),
                tv_usec = (readfds ? HEAP32[(((timeout)+(4))>>2)] : 0);
            timeoutInMillis = (tv_sec + tv_usec / 1000000) * 1000;
          }
          flags = stream.stream_ops.poll(stream, timeoutInMillis);
        }
  
        if ((flags & 1) && check(fd, srcReadLow, srcReadHigh, mask)) {
          fd < 32 ? (dstReadLow = dstReadLow | mask) : (dstReadHigh = dstReadHigh | mask);
          total++;
        }
        if ((flags & 4) && check(fd, srcWriteLow, srcWriteHigh, mask)) {
          fd < 32 ? (dstWriteLow = dstWriteLow | mask) : (dstWriteHigh = dstWriteHigh | mask);
          total++;
        }
        if ((flags & 2) && check(fd, srcExceptLow, srcExceptHigh, mask)) {
          fd < 32 ? (dstExceptLow = dstExceptLow | mask) : (dstExceptHigh = dstExceptHigh | mask);
          total++;
        }
      }
  
      if (readfds) {
        HEAP32[((readfds)>>2)] = dstReadLow;
        HEAP32[(((readfds)+(4))>>2)] = dstReadHigh;
      }
      if (writefds) {
        HEAP32[((writefds)>>2)] = dstWriteLow;
        HEAP32[(((writefds)+(4))>>2)] = dstWriteHigh;
      }
      if (exceptfds) {
        HEAP32[((exceptfds)>>2)] = dstExceptLow;
        HEAP32[(((exceptfds)+(4))>>2)] = dstExceptHigh;
      }
  
      return total;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  };
  ___syscall__newselect.sig = 'iipppp';

  var SOCKFS = {
  websocketArgs:{
  },
  callbacks:{
  },
  on(event, callback) {
        SOCKFS.callbacks[event] = callback;
      },
  emit(event, param) {
        SOCKFS.callbacks[event]?.(param);
      },
  mount(mount) {
        // The incomming Module['websocket'] can be used for configuring 
        // configuring subprotocol/url, etc
        SOCKFS.websocketArgs = Module['websocket'] || {};
        // Add the Event registration mechanism to the exported websocket configuration
        // object so we can register network callbacks from native JavaScript too.
        // For more documentation see system/include/emscripten/emscripten.h
        (Module['websocket'] ??= {})['on'] = SOCKFS.on;
  
        return FS.createNode(null, '/', 16895, 0);
      },
  createSocket(family, type, protocol) {
        type &= ~526336; // Some applications may pass it; it makes no sense for a single process.
        var streaming = type == 1;
        if (streaming && protocol && protocol != 6) {
          throw new FS.ErrnoError(66); // if SOCK_STREAM, must be tcp or 0.
        }
  
        // create our internal socket structure
        var sock = {
          family,
          type,
          protocol,
          server: null,
          error: null, // Used in getsockopt for SOL_SOCKET/SO_ERROR test
          peers: {},
          pending: [],
          recv_queue: [],
          sock_ops: SOCKFS.websocket_sock_ops
        };
  
        // create the filesystem node to store the socket structure
        var name = SOCKFS.nextname();
        var node = FS.createNode(SOCKFS.root, name, 49152, 0);
        node.sock = sock;
  
        // and the wrapping stream that enables library functions such
        // as read and write to indirectly interact with the socket
        var stream = FS.createStream({
          path: name,
          node,
          flags: 2,
          seekable: false,
          stream_ops: SOCKFS.stream_ops
        });
  
        // map the new stream to the socket structure (sockets have a 1:1
        // relationship with a stream)
        sock.stream = stream;
  
        return sock;
      },
  getSocket(fd) {
        var stream = FS.getStream(fd);
        if (!stream || !FS.isSocket(stream.node.mode)) {
          return null;
        }
        return stream.node.sock;
      },
  stream_ops:{
  poll(stream) {
          var sock = stream.node.sock;
          return sock.sock_ops.poll(sock);
        },
  ioctl(stream, request, varargs) {
          var sock = stream.node.sock;
          return sock.sock_ops.ioctl(sock, request, varargs);
        },
  read(stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          var msg = sock.sock_ops.recvmsg(sock, length);
          if (!msg) {
            // socket is closed
            return 0;
          }
          buffer.set(msg.buffer, offset);
          return msg.buffer.length;
        },
  write(stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          return sock.sock_ops.sendmsg(sock, buffer, offset, length);
        },
  close(stream) {
          var sock = stream.node.sock;
          sock.sock_ops.close(sock);
        },
  },
  nextname() {
        if (!SOCKFS.nextname.current) {
          SOCKFS.nextname.current = 0;
        }
        return `socket[${SOCKFS.nextname.current++}]`;
      },
  websocket_sock_ops:{
  createPeer(sock, addr, port) {
          var ws;
  
          if (typeof addr == 'object') {
            ws = addr;
            addr = null;
            port = null;
          }
  
          if (ws) {
            // for sockets that've already connected (e.g. we're the server)
            // we can inspect the _socket property for the address
            if (ws._socket) {
              addr = ws._socket.remoteAddress;
              port = ws._socket.remotePort;
            }
            // if we're just now initializing a connection to the remote,
            // inspect the url property
            else {
              var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
              if (!result) {
                throw new Error('WebSocket URL must be in the format ws(s)://address:port');
              }
              addr = result[1];
              port = parseInt(result[2], 10);
            }
          } else {
            // create the actual websocket object and connect
            try {
              // The default value is 'ws://' the replace is needed because the compiler replaces '//' comments with '#'
              // comments without checking context, so we'd end up with ws:#, the replace swaps the '#' for '//' again.
              var url = 'ws:#'.replace('#', '//');
              // Make the WebSocket subprotocol (Sec-WebSocket-Protocol) default to binary if no configuration is set.
              var subProtocols = 'binary'; // The default value is 'binary'
              // The default WebSocket options
              var opts = undefined;
  
              // Fetch runtime WebSocket URL config.
              if (SOCKFS.websocketArgs['url']) {
                url = SOCKFS.websocketArgs['url'];
              }
              // Fetch runtime WebSocket subprotocol config.
              if (SOCKFS.websocketArgs['subprotocol']) {
                subProtocols = SOCKFS.websocketArgs['subprotocol'];
              } else if (SOCKFS.websocketArgs['subprotocol'] === null) {
                subProtocols = 'null'
              }
  
              if (url === 'ws://' || url === 'wss://') { // Is the supplied URL config just a prefix, if so complete it.
                var parts = addr.split('/');
                url = url + parts[0] + ":" + port + "/" + parts.slice(1).join('/');
              }
  
              if (subProtocols !== 'null') {
                // The regex trims the string (removes spaces at the beginning and end, then splits the string by
                // <any space>,<any space> into an Array. Whitespace removal is important for Websockify and ws.
                subProtocols = subProtocols.replace(/^ +| +$/g,"").split(/ *, */);
  
                opts = subProtocols;
              }
  
              // If node we use the ws library.
              var WebSocketConstructor;
              {
                WebSocketConstructor = WebSocket;
              }
              ws = new WebSocketConstructor(url, opts);
              ws.binaryType = 'arraybuffer';
            } catch (e) {
              throw new FS.ErrnoError(23);
            }
          }
  
          var peer = {
            addr,
            port,
            socket: ws,
            msg_send_queue: []
          };
  
          SOCKFS.websocket_sock_ops.addPeer(sock, peer);
          SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
  
          // if this is a bound dgram socket, send the port number first to allow
          // us to override the ephemeral port reported to us by remotePort on the
          // remote end.
          if (sock.type === 2 && typeof sock.sport != 'undefined') {
            peer.msg_send_queue.push(new Uint8Array([
                255, 255, 255, 255,
                'p'.charCodeAt(0), 'o'.charCodeAt(0), 'r'.charCodeAt(0), 't'.charCodeAt(0),
                ((sock.sport & 0xff00) >> 8) , (sock.sport & 0xff)
            ]));
          }
  
          return peer;
        },
  getPeer(sock, addr, port) {
          return sock.peers[addr + ':' + port];
        },
  addPeer(sock, peer) {
          sock.peers[peer.addr + ':' + peer.port] = peer;
        },
  removePeer(sock, peer) {
          delete sock.peers[peer.addr + ':' + peer.port];
        },
  handlePeerEvents(sock, peer) {
          var first = true;
  
          var handleOpen = function () {
  
            sock.connecting = false;
            SOCKFS.emit('open', sock.stream.fd);
  
            try {
              var queued = peer.msg_send_queue.shift();
              while (queued) {
                peer.socket.send(queued);
                queued = peer.msg_send_queue.shift();
              }
            } catch (e) {
              // not much we can do here in the way of proper error handling as we've already
              // lied and said this data was sent. shut it down.
              peer.socket.close();
            }
          };
  
          function handleMessage(data) {
            if (typeof data == 'string') {
              var encoder = new TextEncoder(); // should be utf-8
              data = encoder.encode(data); // make a typed array from the string
            } else {
              assert(data.byteLength !== undefined); // must receive an ArrayBuffer
              if (data.byteLength == 0) {
                // An empty ArrayBuffer will emit a pseudo disconnect event
                // as recv/recvmsg will return zero which indicates that a socket
                // has performed a shutdown although the connection has not been disconnected yet.
                return;
              }
              data = new Uint8Array(data); // make a typed array view on the array buffer
            }
  
            // if this is the port message, override the peer's port with it
            var wasfirst = first;
            first = false;
            if (wasfirst &&
                data.length === 10 &&
                data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 &&
                data[4] === 'p'.charCodeAt(0) && data[5] === 'o'.charCodeAt(0) && data[6] === 'r'.charCodeAt(0) && data[7] === 't'.charCodeAt(0)) {
              // update the peer's port and it's key in the peer map
              var newport = ((data[8] << 8) | data[9]);
              SOCKFS.websocket_sock_ops.removePeer(sock, peer);
              peer.port = newport;
              SOCKFS.websocket_sock_ops.addPeer(sock, peer);
              return;
            }
  
            sock.recv_queue.push({ addr: peer.addr, port: peer.port, data: data });
            SOCKFS.emit('message', sock.stream.fd);
          };
  
          if (ENVIRONMENT_IS_NODE) {
            peer.socket.on('open', handleOpen);
            peer.socket.on('message', function(data, isBinary) {
              if (!isBinary) {
                return;
              }
              handleMessage((new Uint8Array(data)).buffer); // copy from node Buffer -> ArrayBuffer
            });
            peer.socket.on('close', function() {
              SOCKFS.emit('close', sock.stream.fd);
            });
            peer.socket.on('error', function(error) {
              // Although the ws library may pass errors that may be more descriptive than
              // ECONNREFUSED they are not necessarily the expected error code e.g.
              // ENOTFOUND on getaddrinfo seems to be node.js specific, so using ECONNREFUSED
              // is still probably the most useful thing to do.
              sock.error = 14; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
              SOCKFS.emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
              // don't throw
            });
          } else {
            peer.socket.onopen = handleOpen;
            peer.socket.onclose = function() {
              SOCKFS.emit('close', sock.stream.fd);
            };
            peer.socket.onmessage = function peer_socket_onmessage(event) {
              handleMessage(event.data);
            };
            peer.socket.onerror = function(error) {
              // The WebSocket spec only allows a 'simple event' to be thrown on error,
              // so we only really know as much as ECONNREFUSED.
              sock.error = 14; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
              SOCKFS.emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
            };
          }
        },
  poll(sock) {
          if (sock.type === 1 && sock.server) {
            // listen sockets should only say they're available for reading
            // if there are pending clients.
            return sock.pending.length ? (64 | 1) : 0;
          }
  
          var mask = 0;
          var dest = sock.type === 1 ?  // we only care about the socket state for connection-based sockets
            SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) :
            null;
  
          if (sock.recv_queue.length ||
              !dest ||  // connection-less sockets are always ready to read
              (dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {  // let recv return 0 once closed
            mask |= (64 | 1);
          }
  
          if (!dest ||  // connection-less sockets are always ready to write
              (dest && dest.socket.readyState === dest.socket.OPEN)) {
            mask |= 4;
          }
  
          if ((dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {
            // When an non-blocking connect fails mark the socket as writable.
            // Its up to the calling code to then use getsockopt with SO_ERROR to
            // retrieve the error.
            // See https://man7.org/linux/man-pages/man2/connect.2.html
            if (sock.connecting) {
              mask |= 4;
            } else  {
              mask |= 16;
            }
          }
  
          return mask;
        },
  ioctl(sock, request, arg) {
          switch (request) {
            case 21531:
              var bytes = 0;
              if (sock.recv_queue.length) {
                bytes = sock.recv_queue[0].data.length;
              }
              HEAP32[((arg)>>2)] = bytes;
              return 0;
            default:
              return 28;
          }
        },
  close(sock) {
          // if we've spawned a listen server, close it
          if (sock.server) {
            try {
              sock.server.close();
            } catch (e) {
            }
            sock.server = null;
          }
          // close any peer connections
          var peers = Object.keys(sock.peers);
          for (var i = 0; i < peers.length; i++) {
            var peer = sock.peers[peers[i]];
            try {
              peer.socket.close();
            } catch (e) {
            }
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
          }
          return 0;
        },
  bind(sock, addr, port) {
          if (typeof sock.saddr != 'undefined' || typeof sock.sport != 'undefined') {
            throw new FS.ErrnoError(28);  // already bound
          }
          sock.saddr = addr;
          sock.sport = port;
          // in order to emulate dgram sockets, we need to launch a listen server when
          // binding on a connection-less socket
          // note: this is only required on the server side
          if (sock.type === 2) {
            // close the existing server if it exists
            if (sock.server) {
              sock.server.close();
              sock.server = null;
            }
            // swallow error operation not supported error that occurs when binding in the
            // browser where this isn't supported
            try {
              sock.sock_ops.listen(sock, 0);
            } catch (e) {
              if (!(e.name === 'ErrnoError')) throw e;
              if (e.errno !== 138) throw e;
            }
          }
        },
  connect(sock, addr, port) {
          if (sock.server) {
            throw new FS.ErrnoError(138);
          }
  
          // TODO autobind
          // if (!sock.addr && sock.type == 2) {
          // }
  
          // early out if we're already connected / in the middle of connecting
          if (typeof sock.daddr != 'undefined' && typeof sock.dport != 'undefined') {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (dest) {
              if (dest.socket.readyState === dest.socket.CONNECTING) {
                throw new FS.ErrnoError(7);
              } else {
                throw new FS.ErrnoError(30);
              }
            }
          }
  
          // add the socket to our peer list and set our
          // destination address / port to match
          var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
          sock.daddr = peer.addr;
          sock.dport = peer.port;
  
          // because we cannot synchronously block to wait for the WebSocket
          // connection to complete, we return here pretending that the connection
          // was a success.
          sock.connecting = true;
        },
  listen(sock, backlog) {
          if (!ENVIRONMENT_IS_NODE) {
            throw new FS.ErrnoError(138);
          }
        },
  accept(listensock) {
          if (!listensock.server || !listensock.pending.length) {
            throw new FS.ErrnoError(28);
          }
          var newsock = listensock.pending.shift();
          newsock.stream.flags = listensock.stream.flags;
          return newsock;
        },
  getname(sock, peer) {
          var addr, port;
          if (peer) {
            if (sock.daddr === undefined || sock.dport === undefined) {
              throw new FS.ErrnoError(53);
            }
            addr = sock.daddr;
            port = sock.dport;
          } else {
            // TODO saddr and sport will be set for bind()'d UDP sockets, but what
            // should we be returning for TCP sockets that've been connect()'d?
            addr = sock.saddr || 0;
            port = sock.sport || 0;
          }
          return { addr, port };
        },
  sendmsg(sock, buffer, offset, length, addr, port) {
          if (sock.type === 2) {
            // connection-less sockets will honor the message address,
            // and otherwise fall back to the bound destination address
            if (addr === undefined || port === undefined) {
              addr = sock.daddr;
              port = sock.dport;
            }
            // if there was no address to fall back to, error out
            if (addr === undefined || port === undefined) {
              throw new FS.ErrnoError(17);
            }
          } else {
            // connection-based sockets will only use the bound
            addr = sock.daddr;
            port = sock.dport;
          }
  
          // find the peer for the destination address
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
  
          // early out if not connected with a connection-based socket
          if (sock.type === 1) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              throw new FS.ErrnoError(53);
            }
          }
  
          // create a copy of the incoming data to send, as the WebSocket API
          // doesn't work entirely with an ArrayBufferView, it'll just send
          // the entire underlying buffer
          if (ArrayBuffer.isView(buffer)) {
            offset += buffer.byteOffset;
            buffer = buffer.buffer;
          }
  
          var data = buffer.slice(offset, offset + length);
  
          // if we don't have a cached connectionless UDP datagram connection, or
          // the TCP socket is still connecting, queue the message to be sent upon
          // connect, and lie, saying the data was sent now.
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            // if we're not connected, open a new connection
            if (sock.type === 2) {
              if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
              }
            }
            dest.msg_send_queue.push(data);
            return length;
          }
  
          try {
            // send the actual data
            dest.socket.send(data);
            return length;
          } catch (e) {
            throw new FS.ErrnoError(28);
          }
        },
  recvmsg(sock, length) {
          // http://pubs.opengroup.org/onlinepubs/7908799/xns/recvmsg.html
          if (sock.type === 1 && sock.server) {
            // tcp servers should not be recv()'ing on the listen socket
            throw new FS.ErrnoError(53);
          }
  
          var queued = sock.recv_queue.shift();
          if (!queued) {
            if (sock.type === 1) {
              var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
  
              if (!dest) {
                // if we have a destination address but are not connected, error out
                throw new FS.ErrnoError(53);
              }
              if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                // return null if the socket has closed
                return null;
              }
              // else, our socket is in a valid state but truly has nothing available
              throw new FS.ErrnoError(6);
            }
            throw new FS.ErrnoError(6);
          }
  
          // queued.data will be an ArrayBuffer if it's unadulterated, but if it's
          // requeued TCP data it'll be an ArrayBufferView
          var queuedLength = queued.data.byteLength || queued.data.length;
          var queuedOffset = queued.data.byteOffset || 0;
          var queuedBuffer = queued.data.buffer || queued.data;
          var bytesRead = Math.min(length, queuedLength);
          var res = {
            buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
            addr: queued.addr,
            port: queued.port
          };
  
          // push back any unread data for TCP connections
          if (sock.type === 1 && bytesRead < queuedLength) {
            var bytesRemaining = queuedLength - bytesRead;
            queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
            sock.recv_queue.unshift(queued);
          }
  
          return res;
        },
  },
  };
  
  var getSocketFromFD = (fd) => {
      var socket = SOCKFS.getSocket(fd);
      if (!socket) throw new FS.ErrnoError(8);
      return socket;
    };
  
  var Sockets = {
  BUFFER_SIZE:10240,
  MAX_BUFFER_SIZE:10485760,
  nextFd:1,
  fds:{
  },
  nextport:1,
  maxport:65535,
  peer:null,
  connections:{
  },
  portmap:{
  },
  localAddr:4261412874,
  addrPool:[33554442,50331658,67108874,83886090,100663306,117440522,134217738,150994954,167772170,184549386,201326602,218103818,234881034],
  };
  
  var inetPton4 = (str) => {
      var b = str.split('.');
      for (var i = 0; i < 4; i++) {
        var tmp = Number(b[i]);
        if (isNaN(tmp)) return null;
        b[i] = tmp;
      }
      return (b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24)) >>> 0;
    };
  
  
  /** @suppress {checkTypes} */
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
      var words;
      var w, offset, z, i;
      /* http://home.deds.nl/~aeron/regex/ */
      var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i
      var parts = [];
      if (!valid6regx.test(str)) {
        return null;
      }
      if (str === "::") {
        return [0, 0, 0, 0, 0, 0, 0, 0];
      }
      // Z placeholder to keep track of zeros when splitting the string on ":"
      if (str.startsWith("::")) {
        str = str.replace("::", "Z:"); // leading zeros case
      } else {
        str = str.replace("::", ":Z:");
      }
  
      if (str.indexOf(".") > 0) {
        // parse IPv4 embedded stress
        str = str.replace(new RegExp('[.]', 'g'), ":");
        words = str.split(":");
        words[words.length-4] = jstoi_q(words[words.length-4]) + jstoi_q(words[words.length-3])*256;
        words[words.length-3] = jstoi_q(words[words.length-2]) + jstoi_q(words[words.length-1])*256;
        words = words.slice(0, words.length-2);
      } else {
        words = str.split(":");
      }
  
      offset = 0; z = 0;
      for (w=0; w < words.length; w++) {
        if (typeof words[w] == 'string') {
          if (words[w] === 'Z') {
            // compressed zeros - write appropriate number of zero words
            for (z = 0; z < (8 - words.length+1); z++) {
              parts[w+z] = 0;
            }
            offset = z-1;
          } else {
            // parse hex to field to 16-bit value and write it in network byte-order
            parts[w+offset] = _htons(parseInt(words[w],16));
          }
        } else {
          // parsed IPv4 words
          parts[w+offset] = words[w];
        }
      }
      return [
        (parts[1] << 16) | parts[0],
        (parts[3] << 16) | parts[2],
        (parts[5] << 16) | parts[4],
        (parts[7] << 16) | parts[6]
      ];
    };
  
  
  /** @param {number=} addrlen */
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
      switch (family) {
        case 2:
          addr = inetPton4(addr);
          zeroMemory(sa, 16);
          if (addrlen) {
            HEAP32[((addrlen)>>2)] = 16;
          }
          HEAP16[((sa)>>1)] = family;
          HEAP32[(((sa)+(4))>>2)] = addr;
          HEAP16[(((sa)+(2))>>1)] = _htons(port);
          break;
        case 10:
          addr = inetPton6(addr);
          zeroMemory(sa, 28);
          if (addrlen) {
            HEAP32[((addrlen)>>2)] = 28;
          }
          HEAP32[((sa)>>2)] = family;
          HEAP32[(((sa)+(8))>>2)] = addr[0];
          HEAP32[(((sa)+(12))>>2)] = addr[1];
          HEAP32[(((sa)+(16))>>2)] = addr[2];
          HEAP32[(((sa)+(20))>>2)] = addr[3];
          HEAP16[(((sa)+(2))>>1)] = _htons(port);
          break;
        default:
          return 5;
      }
      return 0;
    };
  
  
  var DNS = {
  address_map:{
  id:1,
  addrs:{
  },
  names:{
  },
  },
  lookup_name(name) {
        // If the name is already a valid ipv4 / ipv6 address, don't generate a fake one.
        var res = inetPton4(name);
        if (res !== null) {
          return name;
        }
        res = inetPton6(name);
        if (res !== null) {
          return name;
        }
  
        // See if this name is already mapped.
        var addr;
  
        if (DNS.address_map.addrs[name]) {
          addr = DNS.address_map.addrs[name];
        } else {
          var id = DNS.address_map.id++;
          assert(id < 65535, 'exceeded max address mappings of 65535');
  
          addr = '172.29.' + (id & 0xff) + '.' + (id & 0xff00);
  
          DNS.address_map.names[addr] = name;
          DNS.address_map.addrs[name] = addr;
        }
  
        return addr;
      },
  lookup_addr(addr) {
        if (DNS.address_map.names[addr]) {
          return DNS.address_map.names[addr];
        }
  
        return null;
      },
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
  try {
  
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_accept4.sig = 'iippiii';

  
  
  var inetNtop4 = (addr) =>
      (addr & 0xff) + '.' + ((addr >> 8) & 0xff) + '.' + ((addr >> 16) & 0xff) + '.' + ((addr >> 24) & 0xff);
  
  
  var inetNtop6 = (ints) => {
      //  ref:  http://www.ietf.org/rfc/rfc2373.txt - section 2.5.4
      //  Format for IPv4 compatible and mapped  128-bit IPv6 Addresses
      //  128-bits are split into eight 16-bit words
      //  stored in network byte order (big-endian)
      //  |                80 bits               | 16 |      32 bits        |
      //  +-----------------------------------------------------------------+
      //  |               10 bytes               |  2 |      4 bytes        |
      //  +--------------------------------------+--------------------------+
      //  +               5 words                |  1 |      2 words        |
      //  +--------------------------------------+--------------------------+
      //  |0000..............................0000|0000|    IPv4 ADDRESS     | (compatible)
      //  +--------------------------------------+----+---------------------+
      //  |0000..............................0000|FFFF|    IPv4 ADDRESS     | (mapped)
      //  +--------------------------------------+----+---------------------+
      var str = "";
      var word = 0;
      var longest = 0;
      var lastzero = 0;
      var zstart = 0;
      var len = 0;
      var i = 0;
      var parts = [
        ints[0] & 0xffff,
        (ints[0] >> 16),
        ints[1] & 0xffff,
        (ints[1] >> 16),
        ints[2] & 0xffff,
        (ints[2] >> 16),
        ints[3] & 0xffff,
        (ints[3] >> 16)
      ];
  
      // Handle IPv4-compatible, IPv4-mapped, loopback and any/unspecified addresses
  
      var hasipv4 = true;
      var v4part = "";
      // check if the 10 high-order bytes are all zeros (first 5 words)
      for (i = 0; i < 5; i++) {
        if (parts[i] !== 0) { hasipv4 = false; break; }
      }
  
      if (hasipv4) {
        // low-order 32-bits store an IPv4 address (bytes 13 to 16) (last 2 words)
        v4part = inetNtop4(parts[6] | (parts[7] << 16));
        // IPv4-mapped IPv6 address if 16-bit value (bytes 11 and 12) == 0xFFFF (6th word)
        if (parts[5] === -1) {
          str = "::ffff:";
          str += v4part;
          return str;
        }
        // IPv4-compatible IPv6 address if 16-bit value (bytes 11 and 12) == 0x0000 (6th word)
        if (parts[5] === 0) {
          str = "::";
          //special case IPv6 addresses
          if (v4part === "0.0.0.0") v4part = ""; // any/unspecified address
          if (v4part === "0.0.0.1") v4part = "1";// loopback address
          str += v4part;
          return str;
        }
      }
  
      // Handle all other IPv6 addresses
  
      // first run to find the longest contiguous zero words
      for (word = 0; word < 8; word++) {
        if (parts[word] === 0) {
          if (word - lastzero > 1) {
            len = 0;
          }
          lastzero = word;
          len++;
        }
        if (len > longest) {
          longest = len;
          zstart = word - longest + 1;
        }
      }
  
      for (word = 0; word < 8; word++) {
        if (longest > 1) {
          // compress contiguous zeros - to produce "::"
          if (parts[word] === 0 && word >= zstart && word < (zstart + longest) ) {
            if (word === zstart) {
              str += ":";
              if (zstart === 0) str += ":"; //leading zeros case
            }
            continue;
          }
        }
        // converts 16-bit words from big-endian to little-endian before converting to hex string
        str += Number(_ntohs(parts[word] & 0xffff)).toString(16);
        str += word < 7 ? ":" : "";
      }
      return str;
    };
  
  var readSockaddr = (sa, salen) => {
      // family / port offsets are common to both sockaddr_in and sockaddr_in6
      var family = HEAP16[((sa)>>1)];
      var port = _ntohs(HEAPU16[(((sa)+(2))>>1)]);
      var addr;
  
      switch (family) {
        case 2:
          if (salen !== 16) {
            return { errno: 28 };
          }
          addr = HEAP32[(((sa)+(4))>>2)];
          addr = inetNtop4(addr);
          break;
        case 10:
          if (salen !== 28) {
            return { errno: 28 };
          }
          addr = [
            HEAP32[(((sa)+(8))>>2)],
            HEAP32[(((sa)+(12))>>2)],
            HEAP32[(((sa)+(16))>>2)],
            HEAP32[(((sa)+(20))>>2)]
          ];
          addr = inetNtop6(addr);
          break;
        default:
          return { errno: 5 };
      }
  
      return { family: family, addr: addr, port: port };
    };
  
  
  var getSocketAddress = (addrp, addrlen) => {
      var info = readSockaddr(addrp, addrlen);
      if (info.errno) throw new FS.ErrnoError(info.errno);
      info.addr = DNS.lookup_addr(info.addr) || info.addr;
      return info;
    };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
  try {
  
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_bind.sig = 'iippiii';

  function ___syscall_chdir(path) {
  try {
  
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_chdir.sig = 'ip';

  function ___syscall_chmod(path, mode) {
  try {
  
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_chmod.sig = 'ipi';

  
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
  try {
  
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_connect.sig = 'iippiii';

  function ___syscall_dup(fd) {
  try {
  
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_dup.sig = 'ii';

  function ___syscall_dup3(fd, newfd, flags) {
  try {
  
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd) return -28;
      // Check newfd is within range of valid open file descriptors.
      if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS) return -8;
      var existing = FS.getStream(newfd);
      if (existing) FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_dup3.sig = 'iiii';

  function ___syscall_faccessat(dirfd, path, amode, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        // need a valid mode
        return -28;
      }
      var lookup = FS.lookupPath(path, { follow: true });
      var node = lookup.node;
      if (!node) {
        return -44;
      }
      var perms = '';
      if (amode & 4) perms += 'r';
      if (amode & 2) perms += 'w';
      if (amode & 1) perms += 'x';
      if (perms /* otherwise, they've just passed F_OK */ && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_faccessat.sig = 'iipii';

  var ___syscall_fadvise64 = (fd, offset, len, advice) => 0;
  ___syscall_fadvise64.sig = 'iijji';

  
  var INT53_MAX = 9007199254740992;
  
  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => (num < INT53_MIN || num > INT53_MAX) ? NaN : Number(num);
  function ___syscall_fallocate(fd, mode, offset, len) {
    offset = bigintToI53Checked(offset);
    len = bigintToI53Checked(len);
  
    
  try {
  
      if (isNaN(offset)) return 61;
      var stream = SYSCALLS.getStreamFromFD(fd)
      FS.allocate(stream, offset, len);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  ;
  }
  ___syscall_fallocate.sig = 'iiijj';

  function ___syscall_fchdir(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.chdir(stream.path);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_fchdir.sig = 'ii';

  function ___syscall_fchmod(fd, mode) {
  try {
  
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_fchmod.sig = 'iii';

  function ___syscall_fchmodat2(dirfd, path, mode, flags) {
  try {
  
      var nofollow = flags & 256;
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      FS.chmod(path, mode, nofollow);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_fchmodat2.sig = 'iipii';

  function ___syscall_fchown32(fd, owner, group) {
  try {
  
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_fchown32.sig = 'iiii';

  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & (~256);
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_fchownat.sig = 'iipiii';

  /** @suppress {duplicate } */
  var syscallGetVarargI = () => {
      // the `+` prepended here is necessary to convince the JSCompiler that varargs is indeed a number.
      var ret = HEAP32[((+SYSCALLS.varargs)>>2)];
      SYSCALLS.varargs += 4;
      return ret;
    };
  var syscallGetVarargP = syscallGetVarargI;
  
  
  function ___syscall_fcntl64(fd, cmd, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;  // FD_CLOEXEC makes no sense for a single process.
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          // We're always unlocked.
          HEAP16[(((arg)+(offset))>>1)] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0; // Pretend that the locking is successful.
      }
      return -28;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_fcntl64.sig = 'iiip';

  function ___syscall_fdatasync(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0; // we can't do anything synchronously; the in-memory FS is already synced to
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_fdatasync.sig = 'ii';

  function ___syscall_fstat64(fd, buf) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_fstat64.sig = 'iip';

  function ___syscall_statfs64(path, size, buf) {
  try {
  
      var stats = FS.statfs(SYSCALLS.getStr(path));
      HEAP32[(((buf)+(4))>>2)] = stats.bsize;
      HEAP32[(((buf)+(40))>>2)] = stats.bsize;
      HEAP32[(((buf)+(8))>>2)] = stats.blocks;
      HEAP32[(((buf)+(12))>>2)] = stats.bfree;
      HEAP32[(((buf)+(16))>>2)] = stats.bavail;
      HEAP32[(((buf)+(20))>>2)] = stats.files;
      HEAP32[(((buf)+(24))>>2)] = stats.ffree;
      HEAP32[(((buf)+(28))>>2)] = stats.fsid;
      HEAP32[(((buf)+(44))>>2)] = stats.flags;  // ST_NOSUID
      HEAP32[(((buf)+(36))>>2)] = stats.namelen;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_statfs64.sig = 'ippp';
  
  function ___syscall_fstatfs64(fd, size, buf) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return ___syscall_statfs64(0, size, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_fstatfs64.sig = 'iipp';

  function ___syscall_ftruncate64(fd, length) {
    length = bigintToI53Checked(length);
  
    
  try {
  
      if (isNaN(length)) return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  ;
  }
  ___syscall_ftruncate64.sig = 'iij';

  
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    };
  function ___syscall_getcwd(buf, size) {
  try {
  
      if (size === 0) return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes) return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_getcwd.sig = 'ipp';

  
  function ___syscall_getdents64(fd, dirp, count) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd)
      stream.getdents ||= FS.readdir(stream.path);
  
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
  
      var startIdx = Math.floor(off / struct_size);
      var endIdx = Math.min(stream.getdents.length, startIdx + Math.floor(count/struct_size))
      for (var idx = startIdx; idx < endIdx; idx++) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === '.') {
          id = stream.node.id;
          type = 4; // DT_DIR
        }
        else if (name === '..') {
          var lookup = FS.lookupPath(stream.path, { parent: true });
          id = lookup.node.id;
          type = 4; // DT_DIR
        }
        else {
          var child;
          try {
            child = FS.lookupNode(stream.node, name);
          } catch (e) {
            // If the entry is not a directory, file, or symlink, nodefs
            // lookupNode will raise EINVAL. Skip these and continue.
            if (e?.errno === 28) {
              continue;
            }
            throw e;
          }
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 :  // DT_CHR, character device.
                 FS.isDir(child.mode) ? 4 :     // DT_DIR, directory.
                 FS.isLink(child.mode) ? 10 :   // DT_LNK, symbolic link.
                 8;                             // DT_REG, regular file.
        }
        HEAP64[((dirp + pos)>>3)] = BigInt(id);
        HEAP64[(((dirp + pos)+(8))>>3)] = BigInt((idx + 1) * struct_size);
        HEAP16[(((dirp + pos)+(16))>>1)] = 280;
        HEAP8[(dirp + pos)+(18)] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_getdents64.sig = 'iipp';

  
  
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
  try {
  
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53; // The socket is not connected.
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_getpeername.sig = 'iippiii';

  
  
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
  try {
  
      var sock = getSocketFromFD(fd);
      // TODO: sock.saddr should never be undefined, see TODO in websocket_sock_ops.getname
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || '0.0.0.0'), sock.sport, addrlen);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_getsockname.sig = 'iippiii';

  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
  try {
  
      var sock = getSocketFromFD(fd);
      // Minimal getsockopt aimed at resolving https://github.com/emscripten-core/emscripten/issues/2211
      // so only supports SOL_SOCKET with SO_ERROR.
      if (level === 1) {
        if (optname === 4) {
          HEAP32[((optval)>>2)] = sock.error;
          HEAP32[((optlen)>>2)] = 4;
          sock.error = null; // Clear the error (The SO_ERROR option obtains and then clears this field).
          return 0;
        }
      }
      return -50; // The option is unknown at the level indicated.
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_getsockopt.sig = 'iiiippi';

  
  function ___syscall_ioctl(fd, op, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty) return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty) return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[((argp)>>2)] = termios.c_iflag || 0;
            HEAP32[(((argp)+(4))>>2)] = termios.c_oflag || 0;
            HEAP32[(((argp)+(8))>>2)] = termios.c_cflag || 0;
            HEAP32[(((argp)+(12))>>2)] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[(argp + i)+(17)] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty) return -59;
          return 0; // no-op, not actually adjusting terminal settings
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty) return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[((argp)>>2)];
            var c_oflag = HEAP32[(((argp)+(4))>>2)];
            var c_cflag = HEAP32[(((argp)+(8))>>2)];
            var c_lflag = HEAP32[(((argp)+(12))>>2)];
            var c_cc = []
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[(argp + i)+(17)]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, { c_iflag, c_oflag, c_cflag, c_lflag, c_cc });
          }
          return 0; // no-op, not actually adjusting terminal settings
        }
        case 21519: {
          if (!stream.tty) return -59;
          var argp = syscallGetVarargP();
          HEAP32[((argp)>>2)] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty) return -59;
          return -28; // not supported
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          // TODO: in theory we should write to the winsize struct that gets
          // passed in, but for now musl doesn't read anything on it
          if (!stream.tty) return -59;
          if (stream.tty.ops && stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = syscallGetVarargP();
            HEAP16[((argp)>>1)] = winsize[0];
            HEAP16[(((argp)+(2))>>1)] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          // TODO: technically, this ioctl call should change the window size.
          // but, since emscripten doesn't have any concept of a terminal window
          // yet, we'll just silently throw it away as we do TIOCGWINSZ
          if (!stream.tty) return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty) return -59;
          return 0;
        }
        default: return -28; // not supported
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_ioctl.sig = 'iiip';

  function ___syscall_listen(fd, backlog) {
  try {
  
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_listen.sig = 'iiiiiii';

  function ___syscall_lstat64(path, buf) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_lstat64.sig = 'ipp';

  function ___syscall_mkdirat(dirfd, path, mode) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_mkdirat.sig = 'iipi';

  function ___syscall_mknodat(dirfd, path, mode, dev) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      // we don't want this in the JS API as it uses mknod to create all nodes.
      switch (mode & 61440) {
        case 32768:
        case 8192:
        case 24576:
        case 4096:
        case 49152:
          break;
        default: return -28;
      }
      FS.mknod(path, mode, dev);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_mknodat.sig = 'iipii';

  function ___syscall_newfstatat(dirfd, path, buf, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & (~6400);
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_newfstatat.sig = 'iippi';

  
  function ___syscall_openat(dirfd, path, flags, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_openat.sig = 'iipip';

  var PIPEFS = {
  BUCKET_BUFFER_SIZE:8192,
  mount(mount) {
        // Do not pollute the real root directory or its child nodes with pipes
        // Looks like it is OK to create another pseudo-root node not linked to the FS.root hierarchy this way
        return FS.createNode(null, '/', 16384 | 0o777, 0);
      },
  createPipe() {
        var pipe = {
          buckets: [],
          // refcnt 2 because pipe has a read end and a write end. We need to be
          // able to read from the read end after write end is closed.
          refcnt : 2,
        };
  
        pipe.buckets.push({
          buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
          offset: 0,
          roffset: 0
        });
  
        var rName = PIPEFS.nextname();
        var wName = PIPEFS.nextname();
        var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
        var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
  
        rNode.pipe = pipe;
        wNode.pipe = pipe;
  
        var readableStream = FS.createStream({
          path: rName,
          node: rNode,
          flags: 0,
          seekable: false,
          stream_ops: PIPEFS.stream_ops
        });
        rNode.stream = readableStream;
  
        var writableStream = FS.createStream({
          path: wName,
          node: wNode,
          flags: 1,
          seekable: false,
          stream_ops: PIPEFS.stream_ops
        });
        wNode.stream = writableStream;
  
        return {
          readable_fd: readableStream.fd,
          writable_fd: writableStream.fd
        };
      },
  stream_ops:{
  poll(stream) {
          var pipe = stream.node.pipe;
  
          if ((stream.flags & 2097155) === 1) {
            return (256 | 4);
          }
          if (pipe.buckets.length > 0) {
            for (var i = 0; i < pipe.buckets.length; i++) {
              var bucket = pipe.buckets[i];
              if (bucket.offset - bucket.roffset > 0) {
                return (64 | 1);
              }
            }
          }
  
          return 0;
        },
  ioctl(stream, request, varargs) {
          return 28;
        },
  fsync(stream) {
          return 28;
        },
  read(stream, buffer, offset, length, position /* ignored */) {
          var pipe = stream.node.pipe;
          var currentLength = 0;
  
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            currentLength += bucket.offset - bucket.roffset;
          }
  
          var data = buffer.subarray(offset, offset + length);
  
          if (length <= 0) {
            return 0;
          }
          if (currentLength == 0) {
            // Behave as if the read end is always non-blocking
            throw new FS.ErrnoError(6);
          }
          var toRead = Math.min(currentLength, length);
  
          var totalRead = toRead;
          var toRemove = 0;
  
          for (var i = 0; i < pipe.buckets.length; i++) {
            var currBucket = pipe.buckets[i];
            var bucketSize = currBucket.offset - currBucket.roffset;
  
            if (toRead <= bucketSize) {
              var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
              if (toRead < bucketSize) {
                tmpSlice = tmpSlice.subarray(0, toRead);
                currBucket.roffset += toRead;
              } else {
                toRemove++;
              }
              data.set(tmpSlice);
              break;
            } else {
              var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
              data.set(tmpSlice);
              data = data.subarray(tmpSlice.byteLength);
              toRead -= tmpSlice.byteLength;
              toRemove++;
            }
          }
  
          if (toRemove && toRemove == pipe.buckets.length) {
            // Do not generate excessive garbage in use cases such as
            // write several bytes, read everything, write several bytes, read everything...
            toRemove--;
            pipe.buckets[toRemove].offset = 0;
            pipe.buckets[toRemove].roffset = 0;
          }
  
          pipe.buckets.splice(0, toRemove);
  
          return totalRead;
        },
  write(stream, buffer, offset, length, position /* ignored */) {
          var pipe = stream.node.pipe;
  
          var data = buffer.subarray(offset, offset + length);
  
          var dataLen = data.byteLength;
          if (dataLen <= 0) {
            return 0;
          }
  
          var currBucket = null;
  
          if (pipe.buckets.length == 0) {
            currBucket = {
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: 0,
              roffset: 0
            };
            pipe.buckets.push(currBucket);
          } else {
            currBucket = pipe.buckets[pipe.buckets.length - 1];
          }
  
          assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
  
          var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
          if (freeBytesInCurrBuffer >= dataLen) {
            currBucket.buffer.set(data, currBucket.offset);
            currBucket.offset += dataLen;
            return dataLen;
          } else if (freeBytesInCurrBuffer > 0) {
            currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
            currBucket.offset += freeBytesInCurrBuffer;
            data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
          }
  
          var numBuckets = (data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE) | 0;
          var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
  
          for (var i = 0; i < numBuckets; i++) {
            var newBucket = {
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: PIPEFS.BUCKET_BUFFER_SIZE,
              roffset: 0
            };
            pipe.buckets.push(newBucket);
            newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
            data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
          }
  
          if (remElements > 0) {
            var newBucket = {
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: data.byteLength,
              roffset: 0
            };
            pipe.buckets.push(newBucket);
            newBucket.buffer.set(data);
          }
  
          return dataLen;
        },
  close(stream) {
          var pipe = stream.node.pipe;
          pipe.refcnt--;
          if (pipe.refcnt === 0) {
            pipe.buckets = null;
          }
        },
  },
  nextname() {
        if (!PIPEFS.nextname.current) {
          PIPEFS.nextname.current = 0;
        }
        return 'pipe[' + (PIPEFS.nextname.current++) + ']';
      },
  };
  function ___syscall_pipe(fdPtr) {
  try {
  
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
  
      var res = PIPEFS.createPipe();
  
      HEAP32[((fdPtr)>>2)] = res.readable_fd;
      HEAP32[(((fdPtr)+(4))>>2)] = res.writable_fd;
  
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_pipe.sig = 'ip';

  function ___syscall_poll(fds, nfds, timeout) {
  try {
  
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[((pollfd)>>2)];
        var events = HEAP16[(((pollfd)+(4))>>1)];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask) nonzero++;
        HEAP16[(((pollfd)+(6))>>1)] = mask;
      }
      return nonzero;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_poll.sig = 'ipii';

  
  
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0) return -28;
      var ret = FS.readlink(path);
  
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf+len];
      stringToUTF8(ret, buf, bufsize+1);
      // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)
      // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.
      HEAP8[buf+len] = endChar;
      return len;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_readlinkat.sig = 'iippp';

  
  
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
  try {
  
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len);
      if (!msg) return 0; // socket is closed
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_recvfrom.sig = 'iippipp';

  
  
  function ___syscall_recvmsg(fd, message, flags, d1, d2, d3) {
  try {
  
      var sock = getSocketFromFD(fd);
      var iov = HEAPU32[(((message)+(8))>>2)];
      var num = HEAP32[(((message)+(12))>>2)];
      // get the total amount of data we can read across all arrays
      var total = 0;
      for (var i = 0; i < num; i++) {
        total += HEAP32[(((iov)+((8 * i) + 4))>>2)];
      }
      // try to read total data
      var msg = sock.sock_ops.recvmsg(sock, total);
      if (!msg) return 0; // socket is closed
  
      // TODO honor flags:
      // MSG_OOB
      // Requests out-of-band data. The significance and semantics of out-of-band data are protocol-specific.
      // MSG_PEEK
      // Peeks at the incoming message.
      // MSG_WAITALL
      // Requests that the function block until the full amount of data requested can be returned. The function may return a smaller amount of data if a signal is caught, if the connection is terminated, if MSG_PEEK was specified, or if an error is pending for the socket.
  
      // write the source address out
      var name = HEAPU32[((message)>>2)];
      if (name) {
        var errno = writeSockaddr(name, sock.family, DNS.lookup_name(msg.addr), msg.port);
      }
      // write the buffer out to the scatter-gather arrays
      var bytesRead = 0;
      var bytesRemaining = msg.buffer.byteLength;
      for (var i = 0; bytesRemaining > 0 && i < num; i++) {
        var iovbase = HEAPU32[(((iov)+((8 * i) + 0))>>2)];
        var iovlen = HEAP32[(((iov)+((8 * i) + 4))>>2)];
        if (!iovlen) {
          continue;
        }
        var length = Math.min(iovlen, bytesRemaining);
        var buf = msg.buffer.subarray(bytesRead, bytesRead + length);
        HEAPU8.set(buf, iovbase + bytesRead);
        bytesRead += length;
        bytesRemaining -= length;
      }
  
      // TODO set msghdr.msg_flags
      // MSG_EOR
      // End of record was received (if supported by the protocol).
      // MSG_OOB
      // Out-of-band data was received.
      // MSG_TRUNC
      // Normal data was truncated.
      // MSG_CTRUNC
  
      return bytesRead;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_recvmsg.sig = 'iipiiii';

  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
  try {
  
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_renameat.sig = 'iipip';

  function ___syscall_rmdir(path) {
  try {
  
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_rmdir.sig = 'ip';

  
  
  function ___syscall_sendmsg(fd, message, flags, d1, d2, d3) {
  try {
  
      var sock = getSocketFromFD(fd);
      var iov = HEAPU32[(((message)+(8))>>2)];
      var num = HEAP32[(((message)+(12))>>2)];
      // read the address and port to send to
      var addr, port;
      var name = HEAPU32[((message)>>2)];
      var namelen = HEAP32[(((message)+(4))>>2)];
      if (name) {
        var info = getSocketAddress(name, namelen);
        port = info.port;
        addr = info.addr;
      }
      // concatenate scatter-gather arrays into one message buffer
      var total = 0;
      for (var i = 0; i < num; i++) {
        total += HEAP32[(((iov)+((8 * i) + 4))>>2)];
      }
      var view = new Uint8Array(total);
      var offset = 0;
      for (var i = 0; i < num; i++) {
        var iovbase = HEAPU32[(((iov)+((8 * i) + 0))>>2)];
        var iovlen = HEAP32[(((iov)+((8 * i) + 4))>>2)];
        for (var j = 0; j < iovlen; j++) {
          view[offset++] = HEAP8[(iovbase)+(j)];
        }
      }
      // write the buffer
      return sock.sock_ops.sendmsg(sock, view, 0, total, addr, port);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_sendmsg.sig = 'iipippi';

  
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
  try {
  
      var sock = getSocketFromFD(fd);
      if (!addr) {
        // send, no address provided
        return FS.write(sock.stream, HEAP8, message, length);
      }
      var dest = getSocketAddress(addr, addr_len);
      // sendto an address
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_sendto.sig = 'iippipp';

  function ___syscall_socket(domain, type, protocol) {
  try {
  
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_socket.sig = 'iiiiiii';

  function ___syscall_stat64(path, buf) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_stat64.sig = 'ipp';


  function ___syscall_symlinkat(target, dirfd, linkpath) {
  try {
  
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      linkpath = SYSCALLS.calculateAt(dirfd, linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_symlinkat.sig = 'ipip';

  
  function ___syscall_truncate64(path, length) {
    length = bigintToI53Checked(length);
  
    
  try {
  
      if (isNaN(length)) return 61;
      path = SYSCALLS.getStr(path);
      FS.truncate(path, length);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  ;
  }
  ___syscall_truncate64.sig = 'ipj';

  function ___syscall_unlinkat(dirfd, path, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort('Invalid flags passed to unlinkat');
      }
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_unlinkat.sig = 'iipi';

  var readI53FromI64 = (ptr) => {
      return HEAPU32[((ptr)>>2)] + HEAP32[(((ptr)+(4))>>2)] * 4294967296;
    };
  
  function ___syscall_utimensat(dirfd, path, times, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      var now = Date.now(), atime, mtime;
      if (!times) {
        atime = now;
        mtime = now;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[(((times)+(8))>>2)];
        if (nanoseconds == 1073741823) {
          atime = now;
        } else if (nanoseconds == 1073741822) {
          atime = null;
        } else {
          atime = (seconds*1000) + (nanoseconds/(1000*1000));
        }
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[(((times)+(8))>>2)];
        if (nanoseconds == 1073741823) {
          mtime = now;
        } else if (nanoseconds == 1073741822) {
          mtime = null;
        } else {
          mtime = (seconds*1000) + (nanoseconds/(1000*1000));
        }
      }
      // null here means UTIME_OMIT was passed. If both were set to UTIME_OMIT then
      // we can skip the call completely.
      if ((mtime ?? atime) !== null) {
        FS.utime(path, atime, mtime);
      }
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_utimensat.sig = 'iippi';

  var ___table_base = new WebAssembly.Global({'value': 'i32', 'mutable': false}, 1);

  var __abort_js = () =>
      abort('');
  __abort_js.sig = 'v';

  var ENV = {
  };
  
  
  
  
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
      var size = lengthBytesUTF8(str) + 1;
      var ret = stackAlloc(size);
      stringToUTF8(str, ret, size);
      return ret;
    };
  
  
  var dlSetError = (msg) => {
      var sp = stackSave();
      var cmsg = stringToUTF8OnStack(msg);
      ___dl_seterr(cmsg, 0);
      stackRestore(sp);
    };
  
  
  var dlopenInternal = (handle, jsflags) => {
      // void *dlopen(const char *file, int mode);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/dlopen.html
      var filename = UTF8ToString(handle + 36);
      var flags = HEAP32[(((handle)+(4))>>2)];
      filename = PATH.normalize(filename);
      var searchpaths = [];
  
      var global = Boolean(flags & 256);
      var localScope = global ? null : {};
  
      // We don't care about RTLD_NOW and RTLD_LAZY.
      var combinedFlags = {
        global,
        nodelete:  Boolean(flags & 4096),
        loadAsync: jsflags.loadAsync,
      }
  
      if (jsflags.loadAsync) {
        return loadDynamicLibrary(filename, combinedFlags, localScope, handle);
      }
  
      try {
        return loadDynamicLibrary(filename, combinedFlags, localScope, handle)
      } catch (e) {
        dlSetError(`Could not load dynamic lib: ${filename}\n${e}`);
        return 0;
      }
    };
  var __dlopen_js = (handle) => {
      return dlopenInternal(handle, { loadAsync: false });
    };
  __dlopen_js.sig = 'pp';

  
  
  
  var __dlsym_js = (handle, symbol, symbolIndex) => {
      // void *dlsym(void *restrict handle, const char *restrict name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html
      symbol = UTF8ToString(symbol);
      var result;
      var newSymIndex;
  
      var lib = LDSO.loadedLibsByHandle[handle];
      if (!lib.exports.hasOwnProperty(symbol) || lib.exports[symbol].stub) {
        dlSetError(`Tried to lookup unknown symbol "${symbol}" in dynamic lib: ${lib.name}`)
        return 0;
      }
      newSymIndex = Object.keys(lib.exports).indexOf(symbol);
      result = lib.exports[symbol];
  
      if (typeof result == 'function') {
  
        var addr = getFunctionAddress(result);
        if (addr) {
          result = addr;
        } else {
          // Insert the function into the wasm table.  If its a direct wasm
          // function the second argument will not be needed.  If its a JS
          // function we rely on the `sig` attribute being set based on the
          // `<func>__sig` specified in library JS file.
          result = addFunction(result, result.sig);
          HEAPU32[((symbolIndex)>>2)] = newSymIndex;
        }
      }
      return result;
    };
  __dlsym_js.sig = 'pppp';

  var embindRepr = (v) => {
      if (v === null) {
          return 'null';
      }
      var t = typeof v;
      if (t === 'object' || t === 'array' || t === 'function') {
          return v.toString();
      } else {
          return '' + v;
      }
    };
  
  var embind_init_charCodes = () => {
      var codes = new Array(256);
      for (var i = 0; i < 256; ++i) {
          codes[i] = String.fromCharCode(i);
      }
      embind_charCodes = codes;
    };
  var embind_charCodes;
  var readLatin1String = (ptr) => {
      var ret = "";
      var c = ptr;
      while (HEAPU8[c]) {
          ret += embind_charCodes[HEAPU8[c++]];
      }
      return ret;
    };
  
  var awaitingDependencies = {
  };
  
  var registeredTypes = {
  };
  
  var typeDependencies = {
  };
  
  var BindingError;
  var throwBindingError = (message) => { throw new BindingError(message); };
  
  
  
  
  var InternalError;
  var throwInternalError = (message) => { throw new InternalError(message); };
  var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {
      myTypes.forEach((type) => typeDependencies[type] = dependentTypes);
  
      function onComplete(typeConverters) {
        var myTypeConverters = getTypeConverters(typeConverters);
        if (myTypeConverters.length !== myTypes.length) {
          throwInternalError('Mismatched type converter count');
        }
        for (var i = 0; i < myTypes.length; ++i) {
          registerType(myTypes[i], myTypeConverters[i]);
        }
      }
  
      var typeConverters = new Array(dependentTypes.length);
      var unregisteredTypes = [];
      var registered = 0;
      dependentTypes.forEach((dt, i) => {
        if (registeredTypes.hasOwnProperty(dt)) {
          typeConverters[i] = registeredTypes[dt];
        } else {
          unregisteredTypes.push(dt);
          if (!awaitingDependencies.hasOwnProperty(dt)) {
            awaitingDependencies[dt] = [];
          }
          awaitingDependencies[dt].push(() => {
            typeConverters[i] = registeredTypes[dt];
            ++registered;
            if (registered === unregisteredTypes.length) {
              onComplete(typeConverters);
            }
          });
        }
      });
      if (0 === unregisteredTypes.length) {
        onComplete(typeConverters);
      }
    };
  /** @param {Object=} options */
  function sharedRegisterType(rawType, registeredInstance, options = {}) {
      var name = registeredInstance.name;
      if (!rawType) {
        throwBindingError(`type "${name}" must have a positive integer typeid pointer`);
      }
      if (registeredTypes.hasOwnProperty(rawType)) {
        if (options.ignoreDuplicateRegistrations) {
          return;
        } else {
          throwBindingError(`Cannot register type '${name}' twice`);
        }
      }
  
      registeredTypes[rawType] = registeredInstance;
      delete typeDependencies[rawType];
  
      if (awaitingDependencies.hasOwnProperty(rawType)) {
        var callbacks = awaitingDependencies[rawType];
        delete awaitingDependencies[rawType];
        callbacks.forEach((cb) => cb());
      }
    }
  /** @param {Object=} options */
  function registerType(rawType, registeredInstance, options = {}) {
      return sharedRegisterType(rawType, registeredInstance, options);
    }
  
  var integerReadValueFromPointer = (name, width, signed) => {
      // integers are quite common, so generate very specialized functions
      switch (width) {
          case 1: return signed ?
              (pointer) => HEAP8[pointer] :
              (pointer) => HEAPU8[pointer];
          case 2: return signed ?
              (pointer) => HEAP16[((pointer)>>1)] :
              (pointer) => HEAPU16[((pointer)>>1)]
          case 4: return signed ?
              (pointer) => HEAP32[((pointer)>>2)] :
              (pointer) => HEAPU32[((pointer)>>2)]
          case 8: return signed ?
              (pointer) => HEAP64[((pointer)>>3)] :
              (pointer) => HEAPU64[((pointer)>>3)]
          default:
              throw new TypeError(`invalid integer width (${width}): ${name}`);
      }
    };
  /** @suppress {globalThis} */
  var __embind_register_bigint = (primitiveType, name, size, minRange, maxRange) => {
      name = readLatin1String(name);
  
      var isUnsignedType = (name.indexOf('u') != -1);
  
      // maxRange comes through as -1 for uint64_t (see issue 13902). Work around that temporarily
      if (isUnsignedType) {
        maxRange = (1n << 64n) - 1n;
      }
  
      registerType(primitiveType, {
        name,
        'fromWireType': (value) => value,
        'toWireType': function(destructors, value) {
          if (typeof value != "bigint" && typeof value != "number") {
            throw new TypeError(`Cannot convert "${embindRepr(value)}" to ${this.name}`);
          }
          if (typeof value == "number") {
            value = BigInt(value);
          }
          return value;
        },
        argPackAdvance: GenericWireTypeSize,
        'readValueFromPointer': integerReadValueFromPointer(name, size, !isUnsignedType),
        destructorFunction: null, // This type does not need a destructor
      });
    };
  __embind_register_bigint.sig = 'vpppjj';

  
  
  var GenericWireTypeSize = 8;
  /** @suppress {globalThis} */
  var __embind_register_bool = (rawType, name, trueValue, falseValue) => {
      name = readLatin1String(name);
      registerType(rawType, {
          name,
          'fromWireType': function(wt) {
              // ambiguous emscripten ABI: sometimes return values are
              // true or false, and sometimes integers (0 or 1)
              return !!wt;
          },
          'toWireType': function(destructors, o) {
              return o ? trueValue : falseValue;
          },
          argPackAdvance: GenericWireTypeSize,
          'readValueFromPointer': function(pointer) {
              return this['fromWireType'](HEAPU8[pointer]);
          },
          destructorFunction: null, // This type does not need a destructor
      });
    };
  __embind_register_bool.sig = 'vppii';

  
  var emval_freelist = [];
  
  var emval_handles = [];
  var __emval_decref = (handle) => {
      if (handle > 9 && 0 === --emval_handles[handle + 1]) {
        emval_handles[handle] = undefined;
        emval_freelist.push(handle);
      }
    };
  __emval_decref.sig = 'vp';
  
  
  
  
  
  var count_emval_handles = () => {
      return emval_handles.length / 2 - 5 - emval_freelist.length;
    };
  
  var init_emval = () => {
      // reserve 0 and some special values. These never get de-allocated.
      emval_handles.push(
        0, 1,
        undefined, 1,
        null, 1,
        true, 1,
        false, 1,
      );
      Module['count_emval_handles'] = count_emval_handles;
    };
  var Emval = {
  toValue:(handle) => {
        if (!handle) {
            throwBindingError('Cannot use deleted val. handle = ' + handle);
        }
        return emval_handles[handle];
      },
  toHandle:(value) => {
        switch (value) {
          case undefined: return 2;
          case null: return 4;
          case true: return 6;
          case false: return 8;
          default:{
            const handle = emval_freelist.pop() || emval_handles.length;
            emval_handles[handle] = value;
            emval_handles[handle + 1] = 1;
            return handle;
          }
        }
      },
  };
  
  /** @suppress {globalThis} */
  function readPointer(pointer) {
      return this['fromWireType'](HEAPU32[((pointer)>>2)]);
    }
  
  var EmValType = {
      name: 'emscripten::val',
      'fromWireType': (handle) => {
        var rv = Emval.toValue(handle);
        __emval_decref(handle);
        return rv;
      },
      'toWireType': (destructors, value) => Emval.toHandle(value),
      argPackAdvance: GenericWireTypeSize,
      'readValueFromPointer': readPointer,
      destructorFunction: null, // This type does not need a destructor
  
      // TODO: do we need a deleteObject here?  write a test where
      // emval is passed into JS via an interface
    };
  var __embind_register_emval = (rawType) => registerType(rawType, EmValType);
  __embind_register_emval.sig = 'vp';

  
  var floatReadValueFromPointer = (name, width) => {
      switch (width) {
          case 4: return function(pointer) {
              return this['fromWireType'](HEAPF32[((pointer)>>2)]);
          };
          case 8: return function(pointer) {
              return this['fromWireType'](HEAPF64[((pointer)>>3)]);
          };
          default:
              throw new TypeError(`invalid float width (${width}): ${name}`);
      }
    };
  
  
  var __embind_register_float = (rawType, name, size) => {
      name = readLatin1String(name);
      registerType(rawType, {
        name,
        'fromWireType': (value) => value,
        'toWireType': (destructors, value) => {
          // The VM will perform JS to Wasm value conversion, according to the spec:
          // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue
          return value;
        },
        argPackAdvance: GenericWireTypeSize,
        'readValueFromPointer': floatReadValueFromPointer(name, size),
        destructorFunction: null, // This type does not need a destructor
      });
    };
  __embind_register_float.sig = 'vppp';

  
  
  
  /** @suppress {globalThis} */
  var __embind_register_integer = (primitiveType, name, size, minRange, maxRange) => {
      name = readLatin1String(name);
      // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come
      // out as 'i32 -1'. Always treat those as max u32.
      if (maxRange === -1) {
        maxRange = 4294967295;
      }
  
      var fromWireType = (value) => value;
  
      if (minRange === 0) {
        var bitshift = 32 - 8*size;
        fromWireType = (value) => (value << bitshift) >>> bitshift;
      }
  
      var isUnsignedType = (name.includes('unsigned'));
      var checkAssertions = (value, toTypeName) => {
      }
      var toWireType;
      if (isUnsignedType) {
        toWireType = function(destructors, value) {
          checkAssertions(value, this.name);
          return value >>> 0;
        }
      } else {
        toWireType = function(destructors, value) {
          checkAssertions(value, this.name);
          // The VM will perform JS to Wasm value conversion, according to the spec:
          // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue
          return value;
        }
      }
      registerType(primitiveType, {
        name,
        'fromWireType': fromWireType,
        'toWireType': toWireType,
        argPackAdvance: GenericWireTypeSize,
        'readValueFromPointer': integerReadValueFromPointer(name, size, minRange !== 0),
        destructorFunction: null, // This type does not need a destructor
      });
    };
  __embind_register_integer.sig = 'vpppii';

  
  var __embind_register_memory_view = (rawType, dataTypeIndex, name) => {
      var typeMapping = [
        Int8Array,
        Uint8Array,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,
        BigInt64Array,
        BigUint64Array,
      ];
  
      var TA = typeMapping[dataTypeIndex];
  
      function decodeMemoryView(handle) {
        var size = HEAPU32[((handle)>>2)];
        var data = HEAPU32[(((handle)+(4))>>2)];
        return new TA(HEAP8.buffer, data, size);
      }
  
      name = readLatin1String(name);
      registerType(rawType, {
        name,
        'fromWireType': decodeMemoryView,
        argPackAdvance: GenericWireTypeSize,
        'readValueFromPointer': decodeMemoryView,
      }, {
        ignoreDuplicateRegistrations: true,
      });
    };
  __embind_register_memory_view.sig = 'vpip';

  
  
  
  
  
  
  
  
  var __embind_register_std_string = (rawType, name) => {
      name = readLatin1String(name);
      var stdStringIsUTF8
      = true;
  
      registerType(rawType, {
        name,
        // For some method names we use string keys here since they are part of
        // the public/external API and/or used by the runtime-generated code.
        'fromWireType'(value) {
          var length = HEAPU32[((value)>>2)];
          var payload = value + 4;
  
          var str;
          if (stdStringIsUTF8) {
            var decodeStartPtr = payload;
            // Looping here to support possible embedded '0' bytes
            for (var i = 0; i <= length; ++i) {
              var currentBytePtr = payload + i;
              if (i == length || HEAPU8[currentBytePtr] == 0) {
                var maxRead = currentBytePtr - decodeStartPtr;
                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                if (str === undefined) {
                  str = stringSegment;
                } else {
                  str += String.fromCharCode(0);
                  str += stringSegment;
                }
                decodeStartPtr = currentBytePtr + 1;
              }
            }
          } else {
            var a = new Array(length);
            for (var i = 0; i < length; ++i) {
              a[i] = String.fromCharCode(HEAPU8[payload + i]);
            }
            str = a.join('');
          }
  
          _free(value);
  
          return str;
        },
        'toWireType'(destructors, value) {
          if (value instanceof ArrayBuffer) {
            value = new Uint8Array(value);
          }
  
          var length;
          var valueIsOfTypeString = (typeof value == 'string');
  
          if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
            throwBindingError('Cannot pass non-string to std::string');
          }
          if (stdStringIsUTF8 && valueIsOfTypeString) {
            length = lengthBytesUTF8(value);
          } else {
            length = value.length;
          }
  
          // assumes POINTER_SIZE alignment
          var base = _malloc(4 + length + 1);
          var ptr = base + 4;
          HEAPU32[((base)>>2)] = length;
          if (stdStringIsUTF8 && valueIsOfTypeString) {
            stringToUTF8(value, ptr, length + 1);
          } else {
            if (valueIsOfTypeString) {
              for (var i = 0; i < length; ++i) {
                var charCode = value.charCodeAt(i);
                if (charCode > 255) {
                  _free(ptr);
                  throwBindingError('String has UTF-16 code units that do not fit in 8 bits');
                }
                HEAPU8[ptr + i] = charCode;
              }
            } else {
              for (var i = 0; i < length; ++i) {
                HEAPU8[ptr + i] = value[i];
              }
            }
          }
  
          if (destructors !== null) {
            destructors.push(_free, base);
          }
          return base;
        },
        argPackAdvance: GenericWireTypeSize,
        'readValueFromPointer': readPointer,
        destructorFunction(ptr) {
          _free(ptr);
        },
      });
    };
  __embind_register_std_string.sig = 'vpp';

  
  
  
  var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;;
  var UTF16ToString = (ptr, maxBytesToRead) => {
      var endPtr = ptr;
      // TextDecoder needs to know the byte length in advance, it doesn't stop on
      // null terminator by itself.
      // Also, use the length info to avoid running tiny strings through
      // TextDecoder, since .subarray() allocates garbage.
      var idx = endPtr >> 1;
      var maxIdx = idx + maxBytesToRead / 2;
      // If maxBytesToRead is not passed explicitly, it will be undefined, and this
      // will always evaluate to true. This saves on code size.
      while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;
      endPtr = idx << 1;
  
      if (endPtr - ptr > 32 && UTF16Decoder)
        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  
      // Fallback: decode without UTF16Decoder
      var str = '';
  
      // If maxBytesToRead is not passed explicitly, it will be undefined, and the
      // for-loop's condition will always evaluate to true. The loop is then
      // terminated on the first null char.
      for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
        var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
        if (codeUnit == 0) break;
        // fromCharCode constructs a character from a UTF-16 code unit, so we can
        // pass the UTF16 string right through.
        str += String.fromCharCode(codeUnit);
      }
  
      return str;
    };
  
  var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {
      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
      maxBytesToWrite ??= 0x7FFFFFFF;
      if (maxBytesToWrite < 2) return 0;
      maxBytesToWrite -= 2; // Null terminator.
      var startPtr = outPtr;
      var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
      for (var i = 0; i < numCharsToWrite; ++i) {
        // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
        HEAP16[((outPtr)>>1)] = codeUnit;
        outPtr += 2;
      }
      // Null-terminate the pointer to the HEAP.
      HEAP16[((outPtr)>>1)] = 0;
      return outPtr - startPtr;
    };
  
  var lengthBytesUTF16 = (str) => str.length*2;
  
  var UTF32ToString = (ptr, maxBytesToRead) => {
      var i = 0;
  
      var str = '';
      // If maxBytesToRead is not passed explicitly, it will be undefined, and this
      // will always evaluate to true. This saves on code size.
      while (!(i >= maxBytesToRead / 4)) {
        var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
        if (utf32 == 0) break;
        ++i;
        // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        if (utf32 >= 0x10000) {
          var ch = utf32 - 0x10000;
          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
        } else {
          str += String.fromCharCode(utf32);
        }
      }
      return str;
    };
  
  var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {
      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
      maxBytesToWrite ??= 0x7FFFFFFF;
      if (maxBytesToWrite < 4) return 0;
      var startPtr = outPtr;
      var endPtr = startPtr + maxBytesToWrite - 4;
      for (var i = 0; i < str.length; ++i) {
        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
          var trailSurrogate = str.charCodeAt(++i);
          codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
        }
        HEAP32[((outPtr)>>2)] = codeUnit;
        outPtr += 4;
        if (outPtr + 4 > endPtr) break;
      }
      // Null-terminate the pointer to the HEAP.
      HEAP32[((outPtr)>>2)] = 0;
      return outPtr - startPtr;
    };
  
  var lengthBytesUTF32 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        var codeUnit = str.charCodeAt(i);
        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
        len += 4;
      }
  
      return len;
    };
  var __embind_register_std_wstring = (rawType, charSize, name) => {
      name = readLatin1String(name);
      var decodeString, encodeString, readCharAt, lengthBytesUTF;
      if (charSize === 2) {
        decodeString = UTF16ToString;
        encodeString = stringToUTF16;
        lengthBytesUTF = lengthBytesUTF16;
        readCharAt = (pointer) => HEAPU16[((pointer)>>1)];
      } else if (charSize === 4) {
        decodeString = UTF32ToString;
        encodeString = stringToUTF32;
        lengthBytesUTF = lengthBytesUTF32;
        readCharAt = (pointer) => HEAPU32[((pointer)>>2)];
      }
      registerType(rawType, {
        name,
        'fromWireType': (value) => {
          // Code mostly taken from _embind_register_std_string fromWireType
          var length = HEAPU32[((value)>>2)];
          var str;
  
          var decodeStartPtr = value + 4;
          // Looping here to support possible embedded '0' bytes
          for (var i = 0; i <= length; ++i) {
            var currentBytePtr = value + 4 + i * charSize;
            if (i == length || readCharAt(currentBytePtr) == 0) {
              var maxReadBytes = currentBytePtr - decodeStartPtr;
              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
              if (str === undefined) {
                str = stringSegment;
              } else {
                str += String.fromCharCode(0);
                str += stringSegment;
              }
              decodeStartPtr = currentBytePtr + charSize;
            }
          }
  
          _free(value);
  
          return str;
        },
        'toWireType': (destructors, value) => {
          if (!(typeof value == 'string')) {
            throwBindingError(`Cannot pass non-string to C++ string type ${name}`);
          }
  
          // assumes POINTER_SIZE alignment
          var length = lengthBytesUTF(value);
          var ptr = _malloc(4 + length + charSize);
          HEAPU32[((ptr)>>2)] = length / charSize;
  
          encodeString(value, ptr + 4, length + charSize);
  
          if (destructors !== null) {
            destructors.push(_free, ptr);
          }
          return ptr;
        },
        argPackAdvance: GenericWireTypeSize,
        'readValueFromPointer': readPointer,
        destructorFunction(ptr) {
          _free(ptr);
        }
      });
    };
  __embind_register_std_wstring.sig = 'vppp';

  
  var __embind_register_void = (rawType, name) => {
      name = readLatin1String(name);
      registerType(rawType, {
        isVoid: true, // void return values can be optimized out sometimes
        name,
        argPackAdvance: 0,
        'fromWireType': () => undefined,
        // TODO: assert if anything else is given?
        'toWireType': (destructors, o) => undefined,
      });
    };
  __embind_register_void.sig = 'vpp';

  
  
  
  
  var __emscripten_dlopen_js = (handle, onsuccess, onerror, user_data) => {
      /** @param {Object=} e */
      function errorCallback(e) {
        var filename = UTF8ToString(handle + 36);
        dlSetError(`'Could not load dynamic lib: ${filename}\n${e}`);
        
        callUserCallback(() => getWasmTableEntry(onerror)(handle, user_data));
      }
      function successCallback() {
        
        callUserCallback(() => getWasmTableEntry(onsuccess)(handle, user_data));
      }
  
      
      var promise = dlopenInternal(handle, { loadAsync: true });
      if (promise) {
        promise.then(successCallback, errorCallback);
      } else {
        errorCallback();
      }
    };
  __emscripten_dlopen_js.sig = 'vpppp';

  var getExecutableName = () => thisProgram || './this.program';
  
  var __emscripten_get_progname = (str, len) => stringToUTF8(getExecutableName(), str, len);
  __emscripten_get_progname.sig = 'vpi';

  
  
  
  var __emscripten_lookup_name = (name) => {
      // uint32_t _emscripten_lookup_name(const char *name);
      var nameString = UTF8ToString(name);
      return inetPton4(DNS.lookup_name(nameString));
    };
  __emscripten_lookup_name.sig = 'ip';

  var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  __emscripten_memcpy_js.sig = 'vppp';

  var __emscripten_runtime_keepalive_clear = () => {
      noExitRuntime = false;
      runtimeKeepaliveCounter = 0;
    };
  __emscripten_runtime_keepalive_clear.sig = 'v';

  var __emscripten_set_offscreencanvas_size = (target, width, height) => {
      return -1;
    };
  __emscripten_set_offscreencanvas_size.sig = 'ipii';

  var __emscripten_system = (command) => {
      // int system(const char *command);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/system.html
      // Can't call external programs.
      if (!command) return 0; // no shell available
      return -52;
    };
  __emscripten_system.sig = 'ip';

  var __emscripten_throw_longjmp = () => {
      throw Infinity;
    };
  __emscripten_throw_longjmp.sig = 'v';


  var __emval_delete = (object, property) => {
      object = Emval.toValue(object);
      property = Emval.toValue(property);
      return delete object[property];
    };
  __emval_delete.sig = 'ipp';

  var __emval_greater_than = (first, second) => {
      first = Emval.toValue(first);
      second = Emval.toValue(second);
      return first > second;
    };
  __emval_greater_than.sig = 'ipp';

  var __emval_incref = (handle) => {
      if (handle > 9) {
        emval_handles[handle + 1] += 1;
      }
    };
  __emval_incref.sig = 'vp';

  var __emval_less_than = (first, second) => {
      first = Emval.toValue(first);
      second = Emval.toValue(second);
      return first < second;
    };
  __emval_less_than.sig = 'ipp';

  var emval_symbols = {
  };
  
  var getStringOrSymbol = (address) => {
      var symbol = emval_symbols[address];
      if (symbol === undefined) {
        return readLatin1String(address);
      }
      return symbol;
    };
  
  var __emval_new_cstring = (v) => Emval.toHandle(getStringOrSymbol(v));
  __emval_new_cstring.sig = 'pp';

  var __emval_set_property = (handle, key, value) => {
      handle = Emval.toValue(handle);
      key = Emval.toValue(key);
      value = Emval.toValue(value);
      handle[key] = value;
    };
  __emval_set_property.sig = 'vppp';

  var __emval_strictly_equals = (first, second) => {
      first = Emval.toValue(first);
      second = Emval.toValue(second);
      return first === second;
    };
  __emval_strictly_equals.sig = 'ipp';

  function __gmtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
  
    
      var date = new Date(time * 1000);
      HEAP32[((tmPtr)>>2)] = date.getUTCSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getUTCMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getUTCHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getUTCDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getUTCMonth();
      HEAP32[(((tmPtr)+(20))>>2)] = date.getUTCFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)] = date.getUTCDay();
      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
    ;
  }
  __gmtime_js.sig = 'vjp';

  var isLeapYear = (year) => year%4 === 0 && (year%100 !== 0 || year%400 === 0);
  
  var MONTH_DAYS_LEAP_CUMULATIVE = [0,31,60,91,121,152,182,213,244,274,305,335];
  
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0,31,59,90,120,151,181,212,243,273,304,334];
  var ydayFromDate = (date) => {
      var leap = isLeapYear(date.getFullYear());
      var monthDaysCumulative = (leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE);
      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1; // -1 since it's days since Jan 1
  
      return yday;
    };
  
  function __localtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);
  
    
      var date = new Date(time*1000);
      HEAP32[((tmPtr)>>2)] = date.getSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getMonth();
      HEAP32[(((tmPtr)+(20))>>2)] = date.getFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)] = date.getDay();
  
      var yday = ydayFromDate(date)|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
      HEAP32[(((tmPtr)+(36))>>2)] = -(date.getTimezoneOffset() * 60);
  
      // Attention: DST is in December in South, and some regions don't have DST at all.
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;
      HEAP32[(((tmPtr)+(32))>>2)] = dst;
    ;
  }
  __localtime_js.sig = 'vjp';

  
  var __mktime_js = function(tmPtr) {
  
    var ret = (() => { 
      var date = new Date(HEAP32[(((tmPtr)+(20))>>2)] + 1900,
                          HEAP32[(((tmPtr)+(16))>>2)],
                          HEAP32[(((tmPtr)+(12))>>2)],
                          HEAP32[(((tmPtr)+(8))>>2)],
                          HEAP32[(((tmPtr)+(4))>>2)],
                          HEAP32[((tmPtr)>>2)],
                          0);
  
      // There's an ambiguous hour when the time goes back; the tm_isdst field is
      // used to disambiguate it.  Date() basically guesses, so we fix it up if it
      // guessed wrong, or fill in tm_isdst with the guess if it's -1.
      var dst = HEAP32[(((tmPtr)+(32))>>2)];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset); // DST is in December in South
      if (dst < 0) {
        // Attention: some regions don't have DST at all.
        HEAP32[(((tmPtr)+(32))>>2)] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if ((dst > 0) != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        // Don't try setMinutes(date.getMinutes() + ...) -- it's messed up.
        date.setTime(date.getTime() + (trueOffset - guessedOffset)*60000);
      }
  
      HEAP32[(((tmPtr)+(24))>>2)] = date.getDay();
      var yday = ydayFromDate(date)|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
      // To match expected behavior, update fields from date
      HEAP32[((tmPtr)>>2)] = date.getSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getMonth();
      HEAP32[(((tmPtr)+(20))>>2)] = date.getYear();
  
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      // Return time in microseconds
      return timeMs / 1000;
     })();
    return BigInt(ret);
  };
  __mktime_js.sig = 'jp';

  
  
  
  
  
  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
    offset = bigintToI53Checked(offset);
  
    
  try {
  
      if (isNaN(offset)) return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[((allocated)>>2)] = res.allocated;
      HEAPU32[((addr)>>2)] = ptr;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  ;
  }
  __mmap_js.sig = 'ipiiijpp';

  
  function __msync_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);
  
    
  try {
  
      if (isNaN(offset)) return 61;
      SYSCALLS.doMsync(addr, SYSCALLS.getStreamFromFD(fd), len, flags, offset);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  ;
  }
  __msync_js.sig = 'ippiiij';

  
  function __munmap_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);
  
    
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  ;
  }
  __munmap_js.sig = 'ippiiij';

  var timers = {
  };
  
  
  
  var _emscripten_get_now = () => performance.now();
  _emscripten_get_now.sig = 'd';
  var __setitimer_js = (which, timeout_ms) => {
      // First, clear any existing timer.
      if (timers[which]) {
        clearTimeout(timers[which].id);
        delete timers[which];
      }
  
      // A timeout of zero simply cancels the current timeout so we have nothing
      // more to do.
      if (!timeout_ms) return 0;
  
      var id = setTimeout(() => {
        delete timers[which];
        callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
      }, timeout_ms);
      timers[which] = { id, timeout_ms };
      return 0;
    };
  __setitimer_js.sig = 'iid';

  var __timegm_js = function(tmPtr) {
  
    var ret = (() => { 
      var time = Date.UTC(HEAP32[(((tmPtr)+(20))>>2)] + 1900,
                          HEAP32[(((tmPtr)+(16))>>2)],
                          HEAP32[(((tmPtr)+(12))>>2)],
                          HEAP32[(((tmPtr)+(8))>>2)],
                          HEAP32[(((tmPtr)+(4))>>2)],
                          HEAP32[((tmPtr)>>2)],
                          0);
      var date = new Date(time);
  
      HEAP32[(((tmPtr)+(24))>>2)] = date.getUTCDay();
      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
  
      return date.getTime() / 1000;
     })();
    return BigInt(ret);
  };
  __timegm_js.sig = 'jp';

  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
      // TODO: Use (malleable) environment variables instead of system settings.
      var currentYear = new Date().getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();
  
      // Local standard timezone offset. Local standard time is not adjusted for
      // daylight savings.  This code uses the fact that getTimezoneOffset returns
      // a greater value during Standard Time versus Daylight Saving Time (DST).
      // Thus it determines the expected output during Standard Time, and it
      // compares whether the output of the given date the same (Standard) or less
      // (DST).
      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
  
      // timezone is specified as seconds west of UTC ("The external variable
      // `timezone` shall be set to the difference, in seconds, between
      // Coordinated Universal Time (UTC) and local standard time."), the same
      // as returned by stdTimezoneOffset.
      // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html
      HEAPU32[((timezone)>>2)] = stdTimezoneOffset * 60;
  
      HEAP32[((daylight)>>2)] = Number(winterOffset != summerOffset);
  
      var extractZone = (timezoneOffset) => {
        // Why inverse sign?
        // Read here https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset
        var sign = timezoneOffset >= 0 ? "-" : "+";
  
        var absOffset = Math.abs(timezoneOffset)
        var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
        var minutes = String(absOffset % 60).padStart(2, "0");
  
        return `UTC${sign}${hours}${minutes}`;
      }
  
      var winterName = extractZone(winterOffset);
      var summerName = extractZone(summerOffset);
      if (summerOffset < winterOffset) {
        // Northern hemisphere
        stringToUTF8(winterName, std_name, 17);
        stringToUTF8(summerName, dst_name, 17);
      } else {
        stringToUTF8(winterName, dst_name, 17);
        stringToUTF8(summerName, std_name, 17);
      }
    };
  __tzset_js.sig = 'vpppp';

  
  var _emscripten_set_main_loop_timing = (mode, value) => {
      MainLoop.timingMode = mode;
      MainLoop.timingValue = value;
  
      if (!MainLoop.func) {
        return 1; // Return non-zero on failure, can't set timing mode when there is no main loop.
      }
  
      if (!MainLoop.running) {
        
        MainLoop.running = true;
      }
      if (mode == 0) {
        MainLoop.scheduler = function MainLoop_scheduler_setTimeout() {
          var timeUntilNextTick = Math.max(0, MainLoop.tickStartTime + value - _emscripten_get_now())|0;
          setTimeout(MainLoop.runner, timeUntilNextTick); // doing this each time means that on exception, we stop
        };
        MainLoop.method = 'timeout';
      } else if (mode == 1) {
        MainLoop.scheduler = function MainLoop_scheduler_rAF() {
          MainLoop.requestAnimationFrame(MainLoop.runner);
        };
        MainLoop.method = 'rAF';
      } else if (mode == 2) {
        if (typeof MainLoop.setImmediate == 'undefined') {
          if (typeof setImmediate == 'undefined') {
            // Emulate setImmediate. (note: not a complete polyfill, we don't emulate clearImmediate() to keep code size to minimum, since not needed)
            var setImmediates = [];
            var emscriptenMainLoopMessageId = 'setimmediate';
            /** @param {Event} event */
            var MainLoop_setImmediate_messageHandler = (event) => {
              // When called in current thread or Worker, the main loop ID is structured slightly different to accommodate for --proxy-to-worker runtime listening to Worker events,
              // so check for both cases.
              if (event.data === emscriptenMainLoopMessageId || event.data.target === emscriptenMainLoopMessageId) {
                event.stopPropagation();
                setImmediates.shift()();
              }
            };
            addEventListener("message", MainLoop_setImmediate_messageHandler, true);
            MainLoop.setImmediate = /** @type{function(function(): ?, ...?): number} */((func) => {
              setImmediates.push(func);
              if (ENVIRONMENT_IS_WORKER) {
                Module['setImmediates'] ??= [];
                Module['setImmediates'].push(func);
                postMessage({target: emscriptenMainLoopMessageId}); // In --proxy-to-worker, route the message via proxyClient.js
              } else postMessage(emscriptenMainLoopMessageId, "*"); // On the main thread, can just send the message to itself.
            });
          } else {
            MainLoop.setImmediate = setImmediate;
          }
        }
        MainLoop.scheduler = function MainLoop_scheduler_setImmediate() {
          MainLoop.setImmediate(MainLoop.runner);
        };
        MainLoop.method = 'immediate';
      }
      return 0;
    };
  _emscripten_set_main_loop_timing.sig = 'iii';
  
  
  
    /**
     * @param {number=} arg
     * @param {boolean=} noSetTiming
     */
  var setMainLoop = (iterFunc, fps, simulateInfiniteLoop, arg, noSetTiming) => {
      MainLoop.func = iterFunc;
      MainLoop.arg = arg;
  
      var thisMainLoopId = MainLoop.currentlyRunningMainloop;
      function checkIsRunning() {
        if (thisMainLoopId < MainLoop.currentlyRunningMainloop) {
          
          maybeExit();
          return false;
        }
        return true;
      }
  
      // We create the loop runner here but it is not actually running until
      // _emscripten_set_main_loop_timing is called (which might happen a
      // later time).  This member signifies that the current runner has not
      // yet been started so that we can call runtimeKeepalivePush when it
      // gets it timing set for the first time.
      MainLoop.running = false;
      MainLoop.runner = function MainLoop_runner() {
        if (ABORT) return;
        if (MainLoop.queue.length > 0) {
          var start = Date.now();
          var blocker = MainLoop.queue.shift();
          blocker.func(blocker.arg);
          if (MainLoop.remainingBlockers) {
            var remaining = MainLoop.remainingBlockers;
            var next = remaining%1 == 0 ? remaining-1 : Math.floor(remaining);
            if (blocker.counted) {
              MainLoop.remainingBlockers = next;
            } else {
              // not counted, but move the progress along a tiny bit
              next = next + 0.5; // do not steal all the next one's progress
              MainLoop.remainingBlockers = (8*remaining + next)/9;
            }
          }
          MainLoop.updateStatus();
  
          // catches pause/resume main loop from blocker execution
          if (!checkIsRunning()) return;
  
          setTimeout(MainLoop.runner, 0);
          return;
        }
  
        // catch pauses from non-main loop sources
        if (!checkIsRunning()) return;
  
        // Implement very basic swap interval control
        MainLoop.currentFrameNumber = MainLoop.currentFrameNumber + 1 | 0;
        if (MainLoop.timingMode == 1 && MainLoop.timingValue > 1 && MainLoop.currentFrameNumber % MainLoop.timingValue != 0) {
          // Not the scheduled time to render this frame - skip.
          MainLoop.scheduler();
          return;
        } else if (MainLoop.timingMode == 0) {
          MainLoop.tickStartTime = _emscripten_get_now();
        }
  
        MainLoop.runIter(iterFunc);
  
        // catch pauses from the main loop itself
        if (!checkIsRunning()) return;
  
        MainLoop.scheduler();
      }
  
      if (!noSetTiming) {
        if (fps && fps > 0) {
          _emscripten_set_main_loop_timing(0, 1000.0 / fps);
        } else {
          // Do rAF by rendering each frame (no decimating)
          _emscripten_set_main_loop_timing(1, 1);
        }
  
        MainLoop.scheduler();
      }
  
      if (simulateInfiniteLoop) {
        throw 'unwind';
      }
    };
  
  
  var MainLoop = {
  running:false,
  scheduler:null,
  method:"",
  currentlyRunningMainloop:0,
  func:null,
  arg:0,
  timingMode:0,
  timingValue:0,
  currentFrameNumber:0,
  queue:[],
  preMainLoop:[],
  postMainLoop:[],
  pause() {
        MainLoop.scheduler = null;
        // Incrementing this signals the previous main loop that it's now become old, and it must return.
        MainLoop.currentlyRunningMainloop++;
      },
  resume() {
        MainLoop.currentlyRunningMainloop++;
        var timingMode = MainLoop.timingMode;
        var timingValue = MainLoop.timingValue;
        var func = MainLoop.func;
        MainLoop.func = null;
        // do not set timing and call scheduler, we will do it on the next lines
        setMainLoop(func, 0, false, MainLoop.arg, true);
        _emscripten_set_main_loop_timing(timingMode, timingValue);
        MainLoop.scheduler();
      },
  updateStatus() {
        if (Module['setStatus']) {
          var message = Module['statusMessage'] || 'Please wait...';
          var remaining = MainLoop.remainingBlockers ?? 0;
          var expected = MainLoop.expectedBlockers ?? 0;
          if (remaining) {
            if (remaining < expected) {
              Module['setStatus'](`{message} ({expected - remaining}/{expected})`);
            } else {
              Module['setStatus'](message);
            }
          } else {
            Module['setStatus']('');
          }
        }
      },
  init() {
        Module['preMainLoop'] && MainLoop.preMainLoop.push(Module['preMainLoop']);
        Module['postMainLoop'] && MainLoop.postMainLoop.push(Module['postMainLoop']);
      },
  runIter(func) {
        if (ABORT) return;
        for (var pre of MainLoop.preMainLoop) {
          if (pre() === false) {
            return; // |return false| skips a frame
          }
        }
        callUserCallback(func);
        for (var post of MainLoop.postMainLoop) {
          post();
        }
      },
  nextRAF:0,
  fakeRequestAnimationFrame(func) {
        // try to keep 60fps between calls to here
        var now = Date.now();
        if (MainLoop.nextRAF === 0) {
          MainLoop.nextRAF = now + 1000/60;
        } else {
          while (now + 2 >= MainLoop.nextRAF) { // fudge a little, to avoid timer jitter causing us to do lots of delay:0
            MainLoop.nextRAF += 1000/60;
          }
        }
        var delay = Math.max(MainLoop.nextRAF - now, 0);
        setTimeout(func, delay);
      },
  requestAnimationFrame(func) {
        if (typeof requestAnimationFrame == 'function') {
          requestAnimationFrame(func);
          return;
        }
        var RAF = MainLoop.fakeRequestAnimationFrame;
        RAF(func);
      },
  };
  
  var AL = {
  QUEUE_INTERVAL:25,
  QUEUE_LOOKAHEAD:0.1,
  DEVICE_NAME:"Emscripten OpenAL",
  CAPTURE_DEVICE_NAME:"Emscripten OpenAL capture",
  ALC_EXTENSIONS:{
  ALC_SOFT_pause_device:true,
  ALC_SOFT_HRTF:true,
  },
  AL_EXTENSIONS:{
  AL_EXT_float32:true,
  AL_SOFT_loop_points:true,
  AL_SOFT_source_length:true,
  AL_EXT_source_distance_model:true,
  AL_SOFT_source_spatialize:true,
  },
  _alcErr:0,
  alcErr:0,
  deviceRefCounts:{
  },
  alcStringCache:{
  },
  paused:false,
  stringCache:{
  },
  contexts:{
  },
  currentCtx:null,
  buffers:{
  0:{
  id:0,
  refCount:0,
  audioBuf:null,
  frequency:0,
  bytesPerSample:2,
  channels:1,
  length:0,
  },
  },
  paramArray:[],
  _nextId:1,
  newId:() => AL.freeIds.length > 0 ? AL.freeIds.pop() : AL._nextId++,
  freeIds:[],
  scheduleContextAudio:(ctx) => {
        // If we are animating using the requestAnimationFrame method, then the main loop does not run when in the background.
        // To give a perfect glitch-free audio stop when switching from foreground to background, we need to avoid updating
        // audio altogether when in the background, so detect that case and kill audio buffer streaming if so.
        if (MainLoop.timingMode === 1 && document['visibilityState'] != 'visible') {
          return;
        }
  
        for (var i in ctx.sources) {
          AL.scheduleSourceAudio(ctx.sources[i]);
        }
      },
  scheduleSourceAudio:(src, lookahead) => {
        // See comment on scheduleContextAudio above.
        if (MainLoop.timingMode === 1 && document['visibilityState'] != 'visible') {
          return;
        }
        if (src.state !== 4114) {
          return;
        }
  
        var currentTime = AL.updateSourceTime(src);
  
        var startTime = src.bufStartTime;
        var startOffset = src.bufOffset;
        var bufCursor = src.bufsProcessed;
  
        // Advance past any audio that is already scheduled
        for (var i = 0; i < src.audioQueue.length; i++) {
          var audioSrc = src.audioQueue[i];
          startTime = audioSrc._startTime + audioSrc._duration;
          startOffset = 0.0;
          bufCursor += audioSrc._skipCount + 1;
        }
  
        if (!lookahead) {
          lookahead = AL.QUEUE_LOOKAHEAD;
        }
        var lookaheadTime = currentTime + lookahead;
        var skipCount = 0;
        while (startTime < lookaheadTime) {
          if (bufCursor >= src.bufQueue.length) {
            if (src.looping) {
              bufCursor %= src.bufQueue.length;
            } else {
              break;
            }
          }
  
          var buf = src.bufQueue[bufCursor % src.bufQueue.length];
          // If the buffer contains no data, skip it
          if (buf.length === 0) {
            skipCount++;
            // If we've gone through the whole queue and everything is 0 length, just give up
            if (skipCount === src.bufQueue.length) {
              break;
            }
          } else {
            var audioSrc = src.context.audioCtx.createBufferSource();
            audioSrc.buffer = buf.audioBuf;
            audioSrc.playbackRate.value = src.playbackRate;
            if (buf.audioBuf._loopStart || buf.audioBuf._loopEnd) {
              audioSrc.loopStart = buf.audioBuf._loopStart;
              audioSrc.loopEnd = buf.audioBuf._loopEnd;
            }
  
            var duration = 0.0;
            // If the source is a looping static buffer, use native looping for gapless playback
            if (src.type === 4136 && src.looping) {
              duration = Number.POSITIVE_INFINITY;
              audioSrc.loop = true;
              if (buf.audioBuf._loopStart) {
                audioSrc.loopStart = buf.audioBuf._loopStart;
              }
              if (buf.audioBuf._loopEnd) {
                audioSrc.loopEnd = buf.audioBuf._loopEnd;
              }
            } else {
              duration = (buf.audioBuf.duration - startOffset) / src.playbackRate;
            }
  
            audioSrc._startOffset = startOffset;
            audioSrc._duration = duration;
            audioSrc._skipCount = skipCount;
            skipCount = 0;
  
            audioSrc.connect(src.gain);
  
            if (typeof audioSrc.start != 'undefined') {
              // Sample the current time as late as possible to mitigate drift
              startTime = Math.max(startTime, src.context.audioCtx.currentTime);
              audioSrc.start(startTime, startOffset);
            } else if (typeof audioSrc.noteOn != 'undefined') {
              startTime = Math.max(startTime, src.context.audioCtx.currentTime);
              audioSrc.noteOn(startTime);
            }
            audioSrc._startTime = startTime;
            src.audioQueue.push(audioSrc);
  
            startTime += duration;
          }
  
          startOffset = 0.0;
          bufCursor++;
        }
      },
  updateSourceTime:(src) => {
        var currentTime = src.context.audioCtx.currentTime;
        if (src.state !== 4114) {
          return currentTime;
        }
  
        // if the start time is unset, determine it based on the current offset.
        // This will be the case when a source is resumed after being paused, and
        // allows us to pretend that the source actually started playing some time
        // in the past such that it would just now have reached the stored offset.
        if (!isFinite(src.bufStartTime)) {
          src.bufStartTime = currentTime - src.bufOffset / src.playbackRate;
          src.bufOffset = 0.0;
        }
  
        var nextStartTime = 0.0;
        while (src.audioQueue.length) {
          var audioSrc = src.audioQueue[0];
          src.bufsProcessed += audioSrc._skipCount;
          nextStartTime = audioSrc._startTime + audioSrc._duration; // n.b. audioSrc._duration already factors in playbackRate, so no divide by src.playbackRate on it.
  
          if (currentTime < nextStartTime) {
            break;
          }
  
          src.audioQueue.shift();
          src.bufStartTime = nextStartTime;
          src.bufOffset = 0.0;
          src.bufsProcessed++;
        }
  
        if (src.bufsProcessed >= src.bufQueue.length && !src.looping) {
          // The source has played its entire queue and is non-looping, so just mark it as stopped.
          AL.setSourceState(src, 4116);
        } else if (src.type === 4136 && src.looping) {
          // If the source is a looping static buffer, determine the buffer offset based on the loop points
          var buf = src.bufQueue[0];
          if (buf.length === 0) {
            src.bufOffset = 0.0;
          } else {
            var delta = (currentTime - src.bufStartTime) * src.playbackRate;
            var loopStart = buf.audioBuf._loopStart || 0.0;
            var loopEnd = buf.audioBuf._loopEnd || buf.audioBuf.duration;
            if (loopEnd <= loopStart) {
              loopEnd = buf.audioBuf.duration;
            }
  
            if (delta < loopEnd) {
              src.bufOffset = delta;
            } else {
              src.bufOffset = loopStart + (delta - loopStart) % (loopEnd - loopStart);
            }
          }
        } else if (src.audioQueue[0]) {
          // The source is still actively playing, so we just need to calculate where we are in the current buffer
          // so it can be remembered if the source gets paused.
          src.bufOffset = (currentTime - src.audioQueue[0]._startTime) * src.playbackRate;
        } else {
          // The source hasn't finished yet, but there is no scheduled audio left for it. This can be because
          // the source has just been started/resumed, or due to an underrun caused by a long blocking operation.
          // We need to determine what state we would be in by this point in time so that when we next schedule
          // audio playback, it will be just as if no underrun occurred.
  
          if (src.type !== 4136 && src.looping) {
            // if the source is a looping buffer queue, let's first calculate the queue duration, so we can
            // quickly fast forward past any full loops of the queue and only worry about the remainder.
            var srcDuration = AL.sourceDuration(src) / src.playbackRate;
            if (srcDuration > 0.0) {
              src.bufStartTime += Math.floor((currentTime - src.bufStartTime) / srcDuration) * srcDuration;
            }
          }
  
          // Since we've already skipped any full-queue loops if there were any, we just need to find
          // out where in the queue the remaining time puts us, which won't require stepping through the
          // entire queue more than once.
          for (var i = 0; i < src.bufQueue.length; i++) {
            if (src.bufsProcessed >= src.bufQueue.length) {
              if (src.looping) {
                src.bufsProcessed %= src.bufQueue.length;
              } else {
                AL.setSourceState(src, 4116);
                break;
              }
            }
  
            var buf = src.bufQueue[src.bufsProcessed];
            if (buf.length > 0) {
              nextStartTime = src.bufStartTime + buf.audioBuf.duration / src.playbackRate;
  
              if (currentTime < nextStartTime) {
                src.bufOffset = (currentTime - src.bufStartTime) * src.playbackRate;
                break;
              }
  
              src.bufStartTime = nextStartTime;
            }
  
            src.bufOffset = 0.0;
            src.bufsProcessed++;
          }
        }
  
        return currentTime;
      },
  cancelPendingSourceAudio:(src) => {
        AL.updateSourceTime(src);
  
        for (var i = 1; i < src.audioQueue.length; i++) {
          var audioSrc = src.audioQueue[i];
          audioSrc.stop();
        }
  
        if (src.audioQueue.length > 1) {
          src.audioQueue.length = 1;
        }
      },
  stopSourceAudio:(src) => {
        for (var i = 0; i < src.audioQueue.length; i++) {
          src.audioQueue[i].stop();
        }
        src.audioQueue.length = 0;
      },
  setSourceState:(src, state) => {
        if (state === 4114) {
          if (src.state === 4114 || src.state == 4116) {
            src.bufsProcessed = 0;
            src.bufOffset = 0.0;
          } else {
          }
  
          AL.stopSourceAudio(src);
  
          src.state = 4114;
          src.bufStartTime = Number.NEGATIVE_INFINITY;
          AL.scheduleSourceAudio(src);
        } else if (state === 4115) {
          if (src.state === 4114) {
            // Store off the current offset to restore with on resume.
            AL.updateSourceTime(src);
            AL.stopSourceAudio(src);
  
            src.state = 4115;
          }
        } else if (state === 4116) {
          if (src.state !== 4113) {
            src.state = 4116;
            src.bufsProcessed = src.bufQueue.length;
            src.bufStartTime = Number.NEGATIVE_INFINITY;
            src.bufOffset = 0.0;
            AL.stopSourceAudio(src);
          }
        } else if (state === 4113) {
          if (src.state !== 4113) {
            src.state = 4113;
            src.bufsProcessed = 0;
            src.bufStartTime = Number.NEGATIVE_INFINITY;
            src.bufOffset = 0.0;
            AL.stopSourceAudio(src);
          }
        }
      },
  initSourcePanner:(src) => {
        if (src.type === 0x1030 /* AL_UNDETERMINED */) {
          return;
        }
  
        // Find the first non-zero buffer in the queue to determine the proper format
        var templateBuf = AL.buffers[0];
        for (var i = 0; i < src.bufQueue.length; i++) {
          if (src.bufQueue[i].id !== 0) {
            templateBuf = src.bufQueue[i];
            break;
          }
        }
        // Create a panner if AL_SOURCE_SPATIALIZE_SOFT is set to true, or alternatively if it's set to auto and the source is mono
        if (src.spatialize === 1 || (src.spatialize === 2 /* AL_AUTO_SOFT */ && templateBuf.channels === 1)) {
          if (src.panner) {
            return;
          }
          src.panner = src.context.audioCtx.createPanner();
  
          AL.updateSourceGlobal(src);
          AL.updateSourceSpace(src);
  
          src.panner.connect(src.context.gain);
          src.gain.disconnect();
          src.gain.connect(src.panner);
        } else {
          if (!src.panner) {
            return;
          }
  
          src.panner.disconnect();
          src.gain.disconnect();
          src.gain.connect(src.context.gain);
          src.panner = null;
        }
      },
  updateContextGlobal:(ctx) => {
        for (var i in ctx.sources) {
          AL.updateSourceGlobal(ctx.sources[i]);
        }
      },
  updateSourceGlobal:(src) => {
        var panner = src.panner;
        if (!panner) {
          return;
        }
  
        panner.refDistance = src.refDistance;
        panner.maxDistance = src.maxDistance;
        panner.rolloffFactor = src.rolloffFactor;
  
        panner.panningModel = src.context.hrtf ? 'HRTF' : 'equalpower';
  
        // Use the source's distance model if AL_SOURCE_DISTANCE_MODEL is enabled
        var distanceModel = src.context.sourceDistanceModel ? src.distanceModel : src.context.distanceModel;
        switch (distanceModel) {
        case 0:
          panner.distanceModel = 'inverse';
          panner.refDistance = 3.40282e38 /* FLT_MAX */;
          break;
        case 0xd001 /* AL_INVERSE_DISTANCE */:
        case 0xd002 /* AL_INVERSE_DISTANCE_CLAMPED */:
          panner.distanceModel = 'inverse';
          break;
        case 0xd003 /* AL_LINEAR_DISTANCE */:
        case 0xd004 /* AL_LINEAR_DISTANCE_CLAMPED */:
          panner.distanceModel = 'linear';
          break;
        case 0xd005 /* AL_EXPONENT_DISTANCE */:
        case 0xd006 /* AL_EXPONENT_DISTANCE_CLAMPED */:
          panner.distanceModel = 'exponential';
          break;
        }
      },
  updateListenerSpace:(ctx) => {
        var listener = ctx.audioCtx.listener;
        if (listener.positionX) {
          listener.positionX.value = ctx.listener.position[0];
          listener.positionY.value = ctx.listener.position[1];
          listener.positionZ.value = ctx.listener.position[2];
        } else {
          listener.setPosition(ctx.listener.position[0], ctx.listener.position[1], ctx.listener.position[2]);
        }
        if (listener.forwardX) {
          listener.forwardX.value = ctx.listener.direction[0];
          listener.forwardY.value = ctx.listener.direction[1];
          listener.forwardZ.value = ctx.listener.direction[2];
          listener.upX.value = ctx.listener.up[0];
          listener.upY.value = ctx.listener.up[1];
          listener.upZ.value = ctx.listener.up[2];
        } else {
          listener.setOrientation(
            ctx.listener.direction[0], ctx.listener.direction[1], ctx.listener.direction[2],
            ctx.listener.up[0], ctx.listener.up[1], ctx.listener.up[2]);
        }
  
        // Update sources that are relative to the listener
        for (var i in ctx.sources) {
          AL.updateSourceSpace(ctx.sources[i]);
        }
      },
  updateSourceSpace:(src) => {
        if (!src.panner) {
          return;
        }
        var panner = src.panner;
  
        var posX = src.position[0];
        var posY = src.position[1];
        var posZ = src.position[2];
        var dirX = src.direction[0];
        var dirY = src.direction[1];
        var dirZ = src.direction[2];
  
        var listener = src.context.listener;
        var lPosX = listener.position[0];
        var lPosY = listener.position[1];
        var lPosZ = listener.position[2];
  
        // WebAudio does spatialization in world-space coordinates, meaning both the buffer sources and
        // the listener position are in the same absolute coordinate system relative to a fixed origin.
        // By default, OpenAL works this way as well, but it also provides a "listener relative" mode, where
        // a buffer source's coordinate are interpreted not in absolute world space, but as being relative
        // to the listener object itself, so as the listener moves the source appears to move with it
        // with no update required. Since web audio does not support this mode, we must transform the source
        // coordinates from listener-relative space to absolute world space.
        //
        // We do this via affine transformation matrices applied to the source position and source direction.
        // A change-of-basis converts from listener-space displacements to world-space displacements,
        // which must be done for both the source position and direction. Lastly, the source position must be
        // added to the listener position to get the final source position, since the source position represents
        // a displacement from the listener.
        if (src.relative) {
          // Negate the listener direction since forward is -Z.
          var lBackX = -listener.direction[0];
          var lBackY = -listener.direction[1];
          var lBackZ = -listener.direction[2];
          var lUpX = listener.up[0];
          var lUpY = listener.up[1];
          var lUpZ = listener.up[2];
  
          var inverseMagnitude = (x, y, z) => {
            var length = Math.sqrt(x * x + y * y + z * z);
  
            if (length < Number.EPSILON) {
              return 0.0;
            }
  
            return 1.0 / length;
          };
  
          // Normalize the Back vector
          var invMag = inverseMagnitude(lBackX, lBackY, lBackZ);
          lBackX *= invMag;
          lBackY *= invMag;
          lBackZ *= invMag;
  
          // ...and the Up vector
          invMag = inverseMagnitude(lUpX, lUpY, lUpZ);
          lUpX *= invMag;
          lUpY *= invMag;
          lUpZ *= invMag;
  
          // Calculate the Right vector as the cross product of the Up and Back vectors
          var lRightX = (lUpY * lBackZ - lUpZ * lBackY);
          var lRightY = (lUpZ * lBackX - lUpX * lBackZ);
          var lRightZ = (lUpX * lBackY - lUpY * lBackX);
  
          // Back and Up might not be exactly perpendicular, so the cross product also needs normalization
          invMag = inverseMagnitude(lRightX, lRightY, lRightZ);
          lRightX *= invMag;
          lRightY *= invMag;
          lRightZ *= invMag;
  
          // Recompute Up from the now orthonormal Right and Back vectors so we have a fully orthonormal basis
          lUpX = (lBackY * lRightZ - lBackZ * lRightY);
          lUpY = (lBackZ * lRightX - lBackX * lRightZ);
          lUpZ = (lBackX * lRightY - lBackY * lRightX);
  
          var oldX = dirX;
          var oldY = dirY;
          var oldZ = dirZ;
  
          // Use our 3 vectors to apply a change-of-basis matrix to the source direction
          dirX = oldX * lRightX + oldY * lUpX + oldZ * lBackX;
          dirY = oldX * lRightY + oldY * lUpY + oldZ * lBackY;
          dirZ = oldX * lRightZ + oldY * lUpZ + oldZ * lBackZ;
  
          oldX = posX;
          oldY = posY;
          oldZ = posZ;
  
          // ...and to the source position
          posX = oldX * lRightX + oldY * lUpX + oldZ * lBackX;
          posY = oldX * lRightY + oldY * lUpY + oldZ * lBackY;
          posZ = oldX * lRightZ + oldY * lUpZ + oldZ * lBackZ;
  
          // The change-of-basis corrects the orientation, but the origin is still the listener.
          // Translate the source position by the listener position to finish.
          posX += lPosX;
          posY += lPosY;
          posZ += lPosZ;
        }
  
        if (panner.positionX) {
          // Assigning to panner.positionX/Y/Z unnecessarily seems to cause performance issues
          // See https://github.com/emscripten-core/emscripten/issues/15847
  
          if (posX != panner.positionX.value) panner.positionX.value = posX;
          if (posY != panner.positionY.value) panner.positionY.value = posY;
          if (posZ != panner.positionZ.value) panner.positionZ.value = posZ;
        } else {
          panner.setPosition(posX, posY, posZ);
        }
        if (panner.orientationX) {
          // Assigning to panner.orientation/Y/Z unnecessarily seems to cause performance issues
          // See https://github.com/emscripten-core/emscripten/issues/15847
  
          if (dirX != panner.orientationX.value) panner.orientationX.value = dirX;
          if (dirY != panner.orientationY.value) panner.orientationY.value = dirY;
          if (dirZ != panner.orientationZ.value) panner.orientationZ.value = dirZ;
        } else {
          panner.setOrientation(dirX, dirY, dirZ);
        }
  
        var oldShift = src.dopplerShift;
        var velX = src.velocity[0];
        var velY = src.velocity[1];
        var velZ = src.velocity[2];
        var lVelX = listener.velocity[0];
        var lVelY = listener.velocity[1];
        var lVelZ = listener.velocity[2];
        if (posX === lPosX && posY === lPosY && posZ === lPosZ
          || velX === lVelX && velY === lVelY && velZ === lVelZ)
        {
          src.dopplerShift = 1.0;
        } else {
          // Doppler algorithm from 1.1 spec
          var speedOfSound = src.context.speedOfSound;
          var dopplerFactor = src.context.dopplerFactor;
  
          var slX = lPosX - posX;
          var slY = lPosY - posY;
          var slZ = lPosZ - posZ;
  
          var magSl = Math.sqrt(slX * slX + slY * slY + slZ * slZ);
          var vls = (slX * lVelX + slY * lVelY + slZ * lVelZ) / magSl;
          var vss = (slX * velX + slY * velY + slZ * velZ) / magSl;
  
          vls = Math.min(vls, speedOfSound / dopplerFactor);
          vss = Math.min(vss, speedOfSound / dopplerFactor);
  
          src.dopplerShift = (speedOfSound - dopplerFactor * vls) / (speedOfSound - dopplerFactor * vss);
        }
        if (src.dopplerShift !== oldShift) {
          AL.updateSourceRate(src);
        }
      },
  updateSourceRate:(src) => {
        if (src.state === 4114) {
          // clear scheduled buffers
          AL.cancelPendingSourceAudio(src);
  
          var audioSrc = src.audioQueue[0];
          if (!audioSrc) {
            return; // It is possible that AL.scheduleContextAudio() has not yet fed the next buffer, if so, skip.
          }
  
          var duration;
          if (src.type === 4136 && src.looping) {
            duration = Number.POSITIVE_INFINITY;
          } else {
            // audioSrc._duration is expressed after factoring in playbackRate, so when changing playback rate, need
            // to recompute/rescale the rate to the new playback speed.
            duration = (audioSrc.buffer.duration - audioSrc._startOffset) / src.playbackRate;
          }
  
          audioSrc._duration = duration;
          audioSrc.playbackRate.value = src.playbackRate;
  
          // reschedule buffers with the new playbackRate
          AL.scheduleSourceAudio(src);
        }
      },
  sourceDuration:(src) => {
        var length = 0.0;
        for (var i = 0; i < src.bufQueue.length; i++) {
          var audioBuf = src.bufQueue[i].audioBuf;
          length += audioBuf ? audioBuf.duration : 0.0;
        }
        return length;
      },
  sourceTell:(src) => {
        AL.updateSourceTime(src);
  
        var offset = 0.0;
        for (var i = 0; i < src.bufsProcessed; i++) {
          if (src.bufQueue[i].audioBuf) {
            offset += src.bufQueue[i].audioBuf.duration;
          }
        }
        offset += src.bufOffset;
  
        return offset;
      },
  sourceSeek:(src, offset) => {
        var playing = src.state == 4114;
        if (playing) {
          AL.setSourceState(src, 4113);
        }
  
        if (src.bufQueue[src.bufsProcessed].audioBuf !== null) {
          src.bufsProcessed = 0;
          while (offset > src.bufQueue[src.bufsProcessed].audioBuf.duration) {
            offset -= src.bufQueue[src.bufsProcessed].audioBuf.duration;
            src.bufsProcessed++;
          }
  
          src.bufOffset = offset;
        }
  
        if (playing) {
          AL.setSourceState(src, 4114);
        }
      },
  getGlobalParam:(funcname, param) => {
        if (!AL.currentCtx) {
          return null;
        }
  
        switch (param) {
        case 49152:
          return AL.currentCtx.dopplerFactor;
        case 49155:
          return AL.currentCtx.speedOfSound;
        case 53248:
          return AL.currentCtx.distanceModel;
        default:
          AL.currentCtx.err = 40962;
          return null;
        }
      },
  setGlobalParam:(funcname, param, value) => {
        if (!AL.currentCtx) {
          return;
        }
  
        switch (param) {
        case 49152:
          if (!Number.isFinite(value) || value < 0.0) { // Strictly negative values are disallowed
            AL.currentCtx.err = 40963;
            return;
          }
  
          AL.currentCtx.dopplerFactor = value;
          AL.updateListenerSpace(AL.currentCtx);
          break;
        case 49155:
          if (!Number.isFinite(value) || value <= 0.0) { // Negative or zero values are disallowed
            AL.currentCtx.err = 40963;
            return;
          }
  
          AL.currentCtx.speedOfSound = value;
          AL.updateListenerSpace(AL.currentCtx);
          break;
        case 53248:
          switch (value) {
          case 0:
          case 0xd001 /* AL_INVERSE_DISTANCE */:
          case 0xd002 /* AL_INVERSE_DISTANCE_CLAMPED */:
          case 0xd003 /* AL_LINEAR_DISTANCE */:
          case 0xd004 /* AL_LINEAR_DISTANCE_CLAMPED */:
          case 0xd005 /* AL_EXPONENT_DISTANCE */:
          case 0xd006 /* AL_EXPONENT_DISTANCE_CLAMPED */:
            AL.currentCtx.distanceModel = value;
            AL.updateContextGlobal(AL.currentCtx);
            break;
          default:
            AL.currentCtx.err = 40963;
            return;
          }
          break;
        default:
          AL.currentCtx.err = 40962;
          return;
        }
      },
  getListenerParam:(funcname, param) => {
        if (!AL.currentCtx) {
          return null;
        }
  
        switch (param) {
        case 4100:
          return AL.currentCtx.listener.position;
        case 4102:
          return AL.currentCtx.listener.velocity;
        case 4111:
          return AL.currentCtx.listener.direction.concat(AL.currentCtx.listener.up);
        case 4106:
          return AL.currentCtx.gain.gain.value;
        default:
          AL.currentCtx.err = 40962;
          return null;
        }
      },
  setListenerParam:(funcname, param, value) => {
        if (!AL.currentCtx) {
          return;
        }
        if (value === null) {
          AL.currentCtx.err = 40962;
          return;
        }
  
        var listener = AL.currentCtx.listener;
        switch (param) {
        case 4100:
          if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
            AL.currentCtx.err = 40963;
            return;
          }
  
          listener.position[0] = value[0];
          listener.position[1] = value[1];
          listener.position[2] = value[2];
          AL.updateListenerSpace(AL.currentCtx);
          break;
        case 4102:
          if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
            AL.currentCtx.err = 40963;
            return;
          }
  
          listener.velocity[0] = value[0];
          listener.velocity[1] = value[1];
          listener.velocity[2] = value[2];
          AL.updateListenerSpace(AL.currentCtx);
          break;
        case 4106:
          if (!Number.isFinite(value) || value < 0.0) {
            AL.currentCtx.err = 40963;
            return;
          }
  
          AL.currentCtx.gain.gain.value = value;
          break;
        case 4111:
          if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])
            || !Number.isFinite(value[3]) || !Number.isFinite(value[4]) || !Number.isFinite(value[5])
          ) {
            AL.currentCtx.err = 40963;
            return;
          }
  
          listener.direction[0] = value[0];
          listener.direction[1] = value[1];
          listener.direction[2] = value[2];
          listener.up[0] = value[3];
          listener.up[1] = value[4];
          listener.up[2] = value[5];
          AL.updateListenerSpace(AL.currentCtx);
          break;
        default:
          AL.currentCtx.err = 40962;
          return;
        }
      },
  getBufferParam:(funcname, bufferId, param) => {
        if (!AL.currentCtx) {
          return;
        }
        var buf = AL.buffers[bufferId];
        if (!buf || bufferId === 0) {
          AL.currentCtx.err = 40961;
          return;
        }
  
        switch (param) {
        case 0x2001 /* AL_FREQUENCY */:
          return buf.frequency;
        case 0x2002 /* AL_BITS */:
          return buf.bytesPerSample * 8;
        case 0x2003 /* AL_CHANNELS */:
          return buf.channels;
        case 0x2004 /* AL_SIZE */:
          return buf.length * buf.bytesPerSample * buf.channels;
        case 0x2015 /* AL_LOOP_POINTS_SOFT */:
          if (buf.length === 0) {
            return [0, 0];
          }
          return [
            (buf.audioBuf._loopStart || 0.0) * buf.frequency,
            (buf.audioBuf._loopEnd || buf.length) * buf.frequency
          ];
        default:
          AL.currentCtx.err = 40962;
          return null;
        }
      },
  setBufferParam:(funcname, bufferId, param, value) => {
        if (!AL.currentCtx) {
          return;
        }
        var buf = AL.buffers[bufferId];
        if (!buf || bufferId === 0) {
          AL.currentCtx.err = 40961;
          return;
        }
        if (value === null) {
          AL.currentCtx.err = 40962;
          return;
        }
  
        switch (param) {
        case 0x2004 /* AL_SIZE */:
          if (value !== 0) {
            AL.currentCtx.err = 40963;
            return;
          }
  
          // Per the spec, setting AL_SIZE to 0 is a legal NOP.
          break;
        case 0x2015 /* AL_LOOP_POINTS_SOFT */:
          if (value[0] < 0 || value[0] > buf.length || value[1] < 0 || value[1] > buf.Length || value[0] >= value[1]) {
            AL.currentCtx.err = 40963;
            return;
          }
          if (buf.refCount > 0) {
            AL.currentCtx.err = 40964;
            return;
          }
  
          if (buf.audioBuf) {
            buf.audioBuf._loopStart = value[0] / buf.frequency;
            buf.audioBuf._loopEnd = value[1] / buf.frequency;
          }
          break;
        default:
          AL.currentCtx.err = 40962;
          return;
        }
      },
  getSourceParam:(funcname, sourceId, param) => {
        if (!AL.currentCtx) {
          return null;
        }
        var src = AL.currentCtx.sources[sourceId];
        if (!src) {
          AL.currentCtx.err = 40961;
          return null;
        }
  
        switch (param) {
        case 0x202 /* AL_SOURCE_RELATIVE */:
          return src.relative;
        case 0x1001 /* AL_CONE_INNER_ANGLE */:
          return src.coneInnerAngle;
        case 0x1002 /* AL_CONE_OUTER_ANGLE */:
          return src.coneOuterAngle;
        case 0x1003 /* AL_PITCH */:
          return src.pitch;
        case 4100:
          return src.position;
        case 4101:
          return src.direction;
        case 4102:
          return src.velocity;
        case 0x1007 /* AL_LOOPING */:
          return src.looping;
        case 0x1009 /* AL_BUFFER */:
          if (src.type === 4136) {
            return src.bufQueue[0].id;
          }
          return 0;
        case 4106:
          return src.gain.gain.value;
         case 0x100D /* AL_MIN_GAIN */:
          return src.minGain;
        case 0x100E /* AL_MAX_GAIN */:
          return src.maxGain;
        case 0x1010 /* AL_SOURCE_STATE */:
          return src.state;
        case 0x1015 /* AL_BUFFERS_QUEUED */:
          if (src.bufQueue.length === 1 && src.bufQueue[0].id === 0) {
            return 0;
          }
          return src.bufQueue.length;
        case 0x1016 /* AL_BUFFERS_PROCESSED */:
          if ((src.bufQueue.length === 1 && src.bufQueue[0].id === 0) || src.looping) {
            return 0;
          }
          return src.bufsProcessed;
        case 0x1020 /* AL_REFERENCE_DISTANCE */:
          return src.refDistance;
        case 0x1021 /* AL_ROLLOFF_FACTOR */:
          return src.rolloffFactor;
        case 0x1022 /* AL_CONE_OUTER_GAIN */:
          return src.coneOuterGain;
        case 0x1023 /* AL_MAX_DISTANCE */:
          return src.maxDistance;
        case 0x1024 /* AL_SEC_OFFSET */:
          return AL.sourceTell(src);
        case 0x1025 /* AL_SAMPLE_OFFSET */:
          var offset = AL.sourceTell(src);
          if (offset > 0.0) {
            offset *= src.bufQueue[0].frequency;
          }
          return offset;
        case 0x1026 /* AL_BYTE_OFFSET */:
          var offset = AL.sourceTell(src);
          if (offset > 0.0) {
            offset *= src.bufQueue[0].frequency * src.bufQueue[0].bytesPerSample;
          }
          return offset;
        case 0x1027 /* AL_SOURCE_TYPE */:
          return src.type;
        case 0x1214 /* AL_SOURCE_SPATIALIZE_SOFT */:
          return src.spatialize;
        case 0x2009 /* AL_BYTE_LENGTH_SOFT */:
          var length = 0;
          var bytesPerFrame = 0;
          for (var i = 0; i < src.bufQueue.length; i++) {
            length += src.bufQueue[i].length;
            if (src.bufQueue[i].id !== 0) {
              bytesPerFrame = src.bufQueue[i].bytesPerSample * src.bufQueue[i].channels;
            }
          }
          return length * bytesPerFrame;
        case 0x200A /* AL_SAMPLE_LENGTH_SOFT */:
          var length = 0;
          for (var i = 0; i < src.bufQueue.length; i++) {
            length += src.bufQueue[i].length;
          }
          return length;
        case 0x200B /* AL_SEC_LENGTH_SOFT */:
          return AL.sourceDuration(src);
        case 53248:
          return src.distanceModel;
        default:
          AL.currentCtx.err = 40962;
          return null;
        }
      },
  setSourceParam:(funcname, sourceId, param, value) => {
        if (!AL.currentCtx) {
          return;
        }
        var src = AL.currentCtx.sources[sourceId];
        if (!src) {
          AL.currentCtx.err = 40961;
          return;
        }
        if (value === null) {
          AL.currentCtx.err = 40962;
          return;
        }
  
        switch (param) {
        case 0x202 /* AL_SOURCE_RELATIVE */:
          if (value === 1) {
            src.relative = true;
            AL.updateSourceSpace(src);
          } else if (value === 0) {
            src.relative = false;
            AL.updateSourceSpace(src);
          } else {
            AL.currentCtx.err = 40963;
            return;
          }
          break;
        case 0x1001 /* AL_CONE_INNER_ANGLE */:
          if (!Number.isFinite(value)) {
            AL.currentCtx.err = 40963;
            return;
          }
  
          src.coneInnerAngle = value;
          if (src.panner) {
            src.panner.coneInnerAngle = value % 360.0;
          }
          break;
        case 0x1002 /* AL_CONE_OUTER_ANGLE */:
          if (!Number.isFinite(value)) {
            AL.currentCtx.err = 40963;
            return;
          }
  
          src.coneOuterAngle = value;
          if (src.panner) {
            src.panner.coneOuterAngle = value % 360.0;
          }
          break;
        case 0x1003 /* AL_PITCH */:
          if (!Number.isFinite(value) || value <= 0.0) {
            AL.currentCtx.err = 40963;
            return;
          }
  
          if (src.pitch === value) {
            break;
          }
  
          src.pitch = value;
          AL.updateSourceRate(src);
          break;
        case 4100:
          if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
            AL.currentCtx.err = 40963;
            return;
          }
  
          src.position[0] = value[0];
          src.position[1] = value[1];
          src.position[2] = value[2];
          AL.updateSourceSpace(src);
          break;
        case 4101:
          if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
            AL.currentCtx.err = 40963;
            return;
          }
  
          src.direction[0] = value[0];
          src.direction[1] = value[1];
          src.direction[2] = value[2];
          AL.updateSourceSpace(src);
          break;
        case 4102:
          if (!Number.isFinite(value[0]) || !Number.isFinite(value[1]) || !Number.isFinite(value[2])) {
            AL.currentCtx.err = 40963;
            return;
          }
  
          src.velocity[0] = value[0];
          src.velocity[1] = value[1];
          src.velocity[2] = value[2];
          AL.updateSourceSpace(src);
          break;
        case 0x1007 /* AL_LOOPING */:
          if (value === 1) {
            src.looping = true;
            AL.updateSourceTime(src);
            if (src.type === 4136 && src.audioQueue.length > 0) {
              var audioSrc  = src.audioQueue[0];
              audioSrc.loop = true;
              audioSrc._duration = Number.POSITIVE_INFINITY;
            }
          } else if (value === 0) {
            src.looping = false;
            var currentTime = AL.updateSourceTime(src);
            if (src.type === 4136 && src.audioQueue.length > 0) {
              var audioSrc  = src.audioQueue[0];
              audioSrc.loop = false;
              audioSrc._duration = src.bufQueue[0].audioBuf.duration / src.playbackRate;
              audioSrc._startTime = currentTime - src.bufOffset / src.playbackRate;
            }
          } else {
            AL.currentCtx.err = 40963;
            return;
          }
          break;
        case 0x1009 /* AL_BUFFER */:
          if (src.state === 4114 || src.state === 4115) {
            AL.currentCtx.err = 40964;
            return;
          }
  
          if (value === 0) {
            for (var i in src.bufQueue) {
              src.bufQueue[i].refCount--;
            }
            src.bufQueue.length = 1;
            src.bufQueue[0] = AL.buffers[0];
  
            src.bufsProcessed = 0;
            src.type = 0x1030 /* AL_UNDETERMINED */;
          } else {
            var buf = AL.buffers[value];
            if (!buf) {
              AL.currentCtx.err = 40963;
              return;
            }
  
            for (var i in src.bufQueue) {
              src.bufQueue[i].refCount--;
            }
            src.bufQueue.length = 0;
  
            buf.refCount++;
            src.bufQueue = [buf];
            src.bufsProcessed = 0;
            src.type = 4136;
          }
  
          AL.initSourcePanner(src);
          AL.scheduleSourceAudio(src);
          break;
        case 4106:
          if (!Number.isFinite(value) || value < 0.0) {
            AL.currentCtx.err = 40963;
            return;
          }
          src.gain.gain.value = value;
          break;
        case 0x100D /* AL_MIN_GAIN */:
          if (!Number.isFinite(value) || value < 0.0 || value > Math.min(src.maxGain, 1.0)) {
            AL.currentCtx.err = 40963;
            return;
          }
          src.minGain = value;
          break;
        case 0x100E /* AL_MAX_GAIN */:
          if (!Number.isFinite(value) || value < Math.max(0.0, src.minGain) || value > 1.0) {
            AL.currentCtx.err = 40963;
            return;
          }
          src.maxGain = value;
          break;
        case 0x1020 /* AL_REFERENCE_DISTANCE */:
          if (!Number.isFinite(value) || value < 0.0) {
            AL.currentCtx.err = 40963;
            return;
          }
          src.refDistance = value;
          if (src.panner) {
            src.panner.refDistance = value;
          }
          break;
        case 0x1021 /* AL_ROLLOFF_FACTOR */:
          if (!Number.isFinite(value) || value < 0.0) {
            AL.currentCtx.err = 40963;
            return;
          }
          src.rolloffFactor = value;
          if (src.panner) {
            src.panner.rolloffFactor = value;
          }
          break;
        case 0x1022 /* AL_CONE_OUTER_GAIN */:
          if (!Number.isFinite(value) || value < 0.0 || value > 1.0) {
            AL.currentCtx.err = 40963;
            return;
          }
          src.coneOuterGain = value;
          if (src.panner) {
            src.panner.coneOuterGain = value;
          }
          break;
        case 0x1023 /* AL_MAX_DISTANCE */:
          if (!Number.isFinite(value) || value < 0.0) {
            AL.currentCtx.err = 40963;
            return;
          }
          src.maxDistance = value;
          if (src.panner) {
            src.panner.maxDistance = value;
          }
          break;
        case 0x1024 /* AL_SEC_OFFSET */:
          if (value < 0.0 || value > AL.sourceDuration(src)) {
            AL.currentCtx.err = 40963;
            return;
          }
  
          AL.sourceSeek(src, value);
          break;
        case 0x1025 /* AL_SAMPLE_OFFSET */:
          var srcLen = AL.sourceDuration(src);
          if (srcLen > 0.0) {
            var frequency;
            for (var bufId in src.bufQueue) {
              if (bufId) {
                frequency = src.bufQueue[bufId].frequency;
                break;
              }
            }
            value /= frequency;
          }
          if (value < 0.0 || value > srcLen) {
            AL.currentCtx.err = 40963;
            return;
          }
  
          AL.sourceSeek(src, value);
          break;
        case 0x1026 /* AL_BYTE_OFFSET */:
          var srcLen = AL.sourceDuration(src);
          if (srcLen > 0.0) {
            var bytesPerSec;
            for (var bufId in src.bufQueue) {
              if (bufId) {
                var buf = src.bufQueue[bufId];
                bytesPerSec = buf.frequency * buf.bytesPerSample * buf.channels;
                break;
              }
            }
            value /= bytesPerSec;
          }
          if (value < 0.0 || value > srcLen) {
            AL.currentCtx.err = 40963;
            return;
          }
  
          AL.sourceSeek(src, value);
          break;
        case 0x1214 /* AL_SOURCE_SPATIALIZE_SOFT */:
          if (value !== 0 && value !== 1 && value !== 2 /* AL_AUTO_SOFT */) {
            AL.currentCtx.err = 40963;
            return;
          }
  
          src.spatialize = value;
          AL.initSourcePanner(src);
          break;
        case 0x2009 /* AL_BYTE_LENGTH_SOFT */:
        case 0x200A /* AL_SAMPLE_LENGTH_SOFT */:
        case 0x200B /* AL_SEC_LENGTH_SOFT */:
          AL.currentCtx.err = 40964;
          break;
        case 53248:
          switch (value) {
          case 0:
          case 0xd001 /* AL_INVERSE_DISTANCE */:
          case 0xd002 /* AL_INVERSE_DISTANCE_CLAMPED */:
          case 0xd003 /* AL_LINEAR_DISTANCE */:
          case 0xd004 /* AL_LINEAR_DISTANCE_CLAMPED */:
          case 0xd005 /* AL_EXPONENT_DISTANCE */:
          case 0xd006 /* AL_EXPONENT_DISTANCE_CLAMPED */:
            src.distanceModel = value;
            if (AL.currentCtx.sourceDistanceModel) {
              AL.updateContextGlobal(AL.currentCtx);
            }
            break;
          default:
            AL.currentCtx.err = 40963;
            return;
          }
          break;
        default:
          AL.currentCtx.err = 40962;
          return;
        }
      },
  captures:{
  },
  sharedCaptureAudioCtx:null,
  requireValidCaptureDevice:(deviceId, funcname) => {
        if (deviceId === 0) {
          AL.alcErr = 40961;
          return null;
        }
        var c = AL.captures[deviceId];
        if (!c) {
          AL.alcErr = 40961;
          return null;
        }
        var err = c.mediaStreamError;
        if (err) {
          AL.alcErr = 40961;
          return null;
        }
        return c;
      },
  };
  var _alBuffer3f = (bufferId, param, value0, value1, value2) => {
      AL.setBufferParam('alBuffer3f', bufferId, param, null);
    };
  _alBuffer3f.sig = 'viifff';

  var _alBuffer3i = (bufferId, param, value0, value1, value2) => {
      AL.setBufferParam('alBuffer3i', bufferId, param, null);
    };
  _alBuffer3i.sig = 'viiiii';

  var _alBufferData = (bufferId, format, pData, size, freq) => {
      if (!AL.currentCtx) {
        return;
      }
      var buf = AL.buffers[bufferId];
      if (!buf) {
        AL.currentCtx.err = 40963;
        return;
      }
      if (freq <= 0) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      var audioBuf = null;
      try {
        switch (format) {
        case 0x1100 /* AL_FORMAT_MONO8 */:
          if (size > 0) {
            audioBuf = AL.currentCtx.audioCtx.createBuffer(1, size, freq);
            var channel0 = audioBuf.getChannelData(0);
            for (var i = 0; i < size; ++i) {
              channel0[i] = HEAPU8[pData++] * 0.0078125 /* 1/128 */ - 1.0;
            }
          }
          buf.bytesPerSample = 1;
          buf.channels = 1;
          buf.length = size;
          break;
        case 0x1101 /* AL_FORMAT_MONO16 */:
          if (size > 0) {
            audioBuf = AL.currentCtx.audioCtx.createBuffer(1, size >> 1, freq);
            var channel0 = audioBuf.getChannelData(0);
            pData >>= 1;
            for (var i = 0; i < size >> 1; ++i) {
              channel0[i] = HEAP16[pData++] * 0.000030517578125 /* 1/32768 */;
            }
          }
          buf.bytesPerSample = 2;
          buf.channels = 1;
          buf.length = size >> 1;
          break;
        case 0x1102 /* AL_FORMAT_STEREO8 */:
          if (size > 0) {
            audioBuf = AL.currentCtx.audioCtx.createBuffer(2, size >> 1, freq);
            var channel0 = audioBuf.getChannelData(0);
            var channel1 = audioBuf.getChannelData(1);
            for (var i = 0; i < size >> 1; ++i) {
              channel0[i] = HEAPU8[pData++] * 0.0078125 /* 1/128 */ - 1.0;
              channel1[i] = HEAPU8[pData++] * 0.0078125 /* 1/128 */ - 1.0;
            }
          }
          buf.bytesPerSample = 1;
          buf.channels = 2;
          buf.length = size >> 1;
          break;
        case 0x1103 /* AL_FORMAT_STEREO16 */:
          if (size > 0) {
            audioBuf = AL.currentCtx.audioCtx.createBuffer(2, size >> 2, freq);
            var channel0 = audioBuf.getChannelData(0);
            var channel1 = audioBuf.getChannelData(1);
            pData >>= 1;
            for (var i = 0; i < size >> 2; ++i) {
              channel0[i] = HEAP16[pData++] * 0.000030517578125 /* 1/32768 */;
              channel1[i] = HEAP16[pData++] * 0.000030517578125 /* 1/32768 */;
            }
          }
          buf.bytesPerSample = 2;
          buf.channels = 2;
          buf.length = size >> 2;
          break;
        case 0x10010 /* AL_FORMAT_MONO_FLOAT32 */:
          if (size > 0) {
            audioBuf = AL.currentCtx.audioCtx.createBuffer(1, size >> 2, freq);
            var channel0 = audioBuf.getChannelData(0);
            pData >>= 2;
            for (var i = 0; i < size >> 2; ++i) {
              channel0[i] = HEAPF32[pData++];
            }
          }
          buf.bytesPerSample = 4;
          buf.channels = 1;
          buf.length = size >> 2;
          break;
        case 0x10011 /* AL_FORMAT_STEREO_FLOAT32 */:
          if (size > 0) {
            audioBuf = AL.currentCtx.audioCtx.createBuffer(2, size >> 3, freq);
            var channel0 = audioBuf.getChannelData(0);
            var channel1 = audioBuf.getChannelData(1);
            pData >>= 2;
            for (var i = 0; i < size >> 3; ++i) {
              channel0[i] = HEAPF32[pData++];
              channel1[i] = HEAPF32[pData++];
            }
          }
          buf.bytesPerSample = 4;
          buf.channels = 2;
          buf.length = size >> 3;
          break;
        default:
          AL.currentCtx.err = 40963;
          return;
        }
        buf.frequency = freq;
        buf.audioBuf = audioBuf;
      } catch (e) {
        AL.currentCtx.err = 40963;
        return;
      }
    };
  _alBufferData.sig = 'viipii';

  var _alBufferf = (bufferId, param, value) => {
      AL.setBufferParam('alBufferf', bufferId, param, null);
    };
  _alBufferf.sig = 'viif';

  var _alBufferfv = (bufferId, param, pValues) => {
      if (!AL.currentCtx) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      AL.setBufferParam('alBufferfv', bufferId, param, null);
    };
  _alBufferfv.sig = 'viip';

  var _alBufferi = (bufferId, param, value) => {
      AL.setBufferParam('alBufferi', bufferId, param, null);
    };
  _alBufferi.sig = 'viii';

  var _alBufferiv = (bufferId, param, pValues) => {
      if (!AL.currentCtx) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      switch (param) {
      case 0x2015 /* AL_LOOP_POINTS_SOFT */:
        AL.paramArray[0] = HEAP32[((pValues)>>2)];
        AL.paramArray[1] = HEAP32[(((pValues)+(4))>>2)];
        AL.setBufferParam('alBufferiv', bufferId, param, AL.paramArray);
        break;
      default:
        AL.setBufferParam('alBufferiv', bufferId, param, null);
        break;
      }
    };
  _alBufferiv.sig = 'viip';

  var _alDeleteBuffers = (count, pBufferIds) => {
      if (!AL.currentCtx) {
        return;
      }
  
      for (var i = 0; i < count; ++i) {
        var bufId = HEAP32[(((pBufferIds)+(i*4))>>2)];
        /// Deleting the zero buffer is a legal NOP, so ignore it
        if (bufId === 0) {
          continue;
        }
  
        // Make sure the buffer index is valid.
        if (!AL.buffers[bufId]) {
          AL.currentCtx.err = 40961;
          return;
        }
  
        // Make sure the buffer is no longer in use.
        if (AL.buffers[bufId].refCount) {
          AL.currentCtx.err = 40964;
          return;
        }
      }
  
      for (var i = 0; i < count; ++i) {
        var bufId = HEAP32[(((pBufferIds)+(i*4))>>2)];
        if (bufId === 0) {
          continue;
        }
  
        AL.deviceRefCounts[AL.buffers[bufId].deviceId]--;
        delete AL.buffers[bufId];
        AL.freeIds.push(bufId);
      }
    };
  _alDeleteBuffers.sig = 'vip';

  var _alSourcei = (sourceId, param, value) => {
      switch (param) {
      case 0x202 /* AL_SOURCE_RELATIVE */:
      case 0x1001 /* AL_CONE_INNER_ANGLE */:
      case 0x1002 /* AL_CONE_OUTER_ANGLE */:
      case 0x1007 /* AL_LOOPING */:
      case 0x1009 /* AL_BUFFER */:
      case 0x1020 /* AL_REFERENCE_DISTANCE */:
      case 0x1021 /* AL_ROLLOFF_FACTOR */:
      case 0x1023 /* AL_MAX_DISTANCE */:
      case 0x1024 /* AL_SEC_OFFSET */:
      case 0x1025 /* AL_SAMPLE_OFFSET */:
      case 0x1026 /* AL_BYTE_OFFSET */:
      case 0x1214 /* AL_SOURCE_SPATIALIZE_SOFT */:
      case 0x2009 /* AL_BYTE_LENGTH_SOFT */:
      case 0x200A /* AL_SAMPLE_LENGTH_SOFT */:
      case 53248:
        AL.setSourceParam('alSourcei', sourceId, param, value);
        break;
      default:
        AL.setSourceParam('alSourcei', sourceId, param, null);
        break;
      }
    };
  _alSourcei.sig = 'viii';
  
  var _alDeleteSources = (count, pSourceIds) => {
      if (!AL.currentCtx) {
        return;
      }
  
      for (var i = 0; i < count; ++i) {
        var srcId = HEAP32[(((pSourceIds)+(i*4))>>2)];
        if (!AL.currentCtx.sources[srcId]) {
          AL.currentCtx.err = 40961;
          return;
        }
      }
  
      for (var i = 0; i < count; ++i) {
        var srcId = HEAP32[(((pSourceIds)+(i*4))>>2)];
        AL.setSourceState(AL.currentCtx.sources[srcId], 4116);
        _alSourcei(srcId, 0x1009 /* AL_BUFFER */, 0);
        delete AL.currentCtx.sources[srcId];
        AL.freeIds.push(srcId);
      }
    };
  _alDeleteSources.sig = 'vip';

  var _alDisable = (param) => {
      if (!AL.currentCtx) {
        return;
      }
      switch (param) {
      case 0x200 /* AL_SOURCE_DISTANCE_MODEL */:
        AL.currentCtx.sourceDistanceModel = false;
        AL.updateContextGlobal(AL.currentCtx);
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alDisable.sig = 'vi';

  var _alDistanceModel = (model) => {
      AL.setGlobalParam('alDistanceModel', 53248, model);
    };
  _alDistanceModel.sig = 'vi';

  var _alDopplerFactor = (value) => {
      AL.setGlobalParam('alDopplerFactor', 49152, value);
    };
  _alDopplerFactor.sig = 'vf';

  var _alDopplerVelocity = (value) => {
      warnOnce('alDopplerVelocity() is deprecated, and only kept for compatibility with OpenAL 1.0. Use alSpeedOfSound() instead.');
      if (!AL.currentCtx) {
        return;
      }
      if (value <= 0) { // Negative or zero values are disallowed
        AL.currentCtx.err = 40963;
        return;
      }
    };
  _alDopplerVelocity.sig = 'vf';

  var _alEnable = (param) => {
      if (!AL.currentCtx) {
        return;
      }
      switch (param) {
      case 0x200 /* AL_SOURCE_DISTANCE_MODEL */:
        AL.currentCtx.sourceDistanceModel = true;
        AL.updateContextGlobal(AL.currentCtx);
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alEnable.sig = 'vi';

  var _alGenBuffers = (count, pBufferIds) => {
      if (!AL.currentCtx) {
        return;
      }
  
      for (var i = 0; i < count; ++i) {
        var buf = {
          deviceId: AL.currentCtx.deviceId,
          id: AL.newId(),
          refCount: 0,
          audioBuf: null,
          frequency: 0,
          bytesPerSample: 2,
          channels: 1,
          length: 0,
        };
        AL.deviceRefCounts[buf.deviceId]++;
        AL.buffers[buf.id] = buf;
        HEAP32[(((pBufferIds)+(i*4))>>2)] = buf.id;
      }
    };
  _alGenBuffers.sig = 'vip';

  var _alGenSources = (count, pSourceIds) => {
      if (!AL.currentCtx) {
        return;
      }
      for (var i = 0; i < count; ++i) {
        var gain = AL.currentCtx.audioCtx.createGain();
        gain.connect(AL.currentCtx.gain);
        var src = {
          context: AL.currentCtx,
          id: AL.newId(),
          type: 0x1030 /* AL_UNDETERMINED */,
          state: 4113,
          bufQueue: [AL.buffers[0]],
          audioQueue: [],
          looping: false,
          pitch: 1.0,
          dopplerShift: 1.0,
          gain,
          minGain: 0.0,
          maxGain: 1.0,
          panner: null,
          bufsProcessed: 0,
          bufStartTime: Number.NEGATIVE_INFINITY,
          bufOffset: 0.0,
          relative: false,
          refDistance: 1.0,
          maxDistance: 3.40282e38 /* FLT_MAX */,
          rolloffFactor: 1.0,
          position: [0.0, 0.0, 0.0],
          velocity: [0.0, 0.0, 0.0],
          direction: [0.0, 0.0, 0.0],
          coneOuterGain: 0.0,
          coneInnerAngle: 360.0,
          coneOuterAngle: 360.0,
          distanceModel: 0xd002 /* AL_INVERSE_DISTANCE_CLAMPED */,
          spatialize: 2 /* AL_AUTO_SOFT */,
  
          get playbackRate() {
            return this.pitch * this.dopplerShift;
          }
        };
        AL.currentCtx.sources[src.id] = src;
        HEAP32[(((pSourceIds)+(i*4))>>2)] = src.id;
      }
    };
  _alGenSources.sig = 'vip';

  var _alGetBoolean = (param) => {
      var val = AL.getGlobalParam('alGetBoolean', param);
      if (val === null) {
        return 0;
      }
  
      switch (param) {
      case 49152:
      case 49155:
      case 53248:
        return val !== 0 ? 1 : 0;
      default:
        AL.currentCtx.err = 40962;
        return 0;
      }
    };
  _alGetBoolean.sig = 'ii';

  var _alGetBooleanv = (param, pValues) => {
      var val = AL.getGlobalParam('alGetBooleanv', param);
      // Silently ignore null destinations, as per the spec for global state functions
      if (val === null || !pValues) {
        return;
      }
  
      switch (param) {
      case 49152:
      case 49155:
      case 53248:
        HEAP8[pValues] = val;
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alGetBooleanv.sig = 'vip';

  var _alGetBuffer3f = (bufferId, param, pValue0, pValue1, pValue2) => {
      var val = AL.getBufferParam('alGetBuffer3f', bufferId, param);
      if (val === null) {
        return;
      }
      if (!pValue0 || !pValue1 || !pValue2) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      AL.currentCtx.err = 40962;
    };
  _alGetBuffer3f.sig = 'viippp';

  var _alGetBuffer3i = (bufferId, param, pValue0, pValue1, pValue2) => {
      var val = AL.getBufferParam('alGetBuffer3i', bufferId, param);
      if (val === null) {
        return;
      }
      if (!pValue0 || !pValue1 || !pValue2) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      AL.currentCtx.err = 40962;
    };
  _alGetBuffer3i.sig = 'viippp';

  var _alGetBufferf = (bufferId, param, pValue) => {
      var val = AL.getBufferParam('alGetBufferf', bufferId, param);
      if (val === null) {
        return;
      }
      if (!pValue) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      AL.currentCtx.err = 40962;
    };
  _alGetBufferf.sig = 'viip';

  var _alGetBufferfv = (bufferId, param, pValues) => {
      var val = AL.getBufferParam('alGetBufferfv', bufferId, param);
      if (val === null) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      AL.currentCtx.err = 40962;
    };
  _alGetBufferfv.sig = 'viip';

  var _alGetBufferi = (bufferId, param, pValue) => {
      var val = AL.getBufferParam('alGetBufferi', bufferId, param);
      if (val === null) {
        return;
      }
      if (!pValue) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      switch (param) {
      case 0x2001 /* AL_FREQUENCY */:
      case 0x2002 /* AL_BITS */:
      case 0x2003 /* AL_CHANNELS */:
      case 0x2004 /* AL_SIZE */:
        HEAP32[((pValue)>>2)] = val;
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alGetBufferi.sig = 'viip';

  var _alGetBufferiv = (bufferId, param, pValues) => {
      var val = AL.getBufferParam('alGetBufferiv', bufferId, param);
      if (val === null) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      switch (param) {
      case 0x2001 /* AL_FREQUENCY */:
      case 0x2002 /* AL_BITS */:
      case 0x2003 /* AL_CHANNELS */:
      case 0x2004 /* AL_SIZE */:
        HEAP32[((pValues)>>2)] = val;
        break;
      case 0x2015 /* AL_LOOP_POINTS_SOFT */:
        HEAP32[((pValues)>>2)] = val[0];
        HEAP32[(((pValues)+(4))>>2)] = val[1];
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alGetBufferiv.sig = 'viip';

  var _alGetDouble = (param) => {
      var val = AL.getGlobalParam('alGetDouble', param);
      if (val === null) {
        return 0.0;
      }
  
      switch (param) {
      case 49152:
      case 49155:
      case 53248:
        return val;
      default:
        AL.currentCtx.err = 40962;
        return 0.0;
      }
    };
  _alGetDouble.sig = 'di';

  var _alGetDoublev = (param, pValues) => {
      var val = AL.getGlobalParam('alGetDoublev', param);
      // Silently ignore null destinations, as per the spec for global state functions
      if (val === null || !pValues) {
        return;
      }
  
      switch (param) {
      case 49152:
      case 49155:
      case 53248:
        HEAPF64[((pValues)>>3)] = val;
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alGetDoublev.sig = 'vip';

  
  var _alGetEnumValue = (pEnumName) => {
      if (!AL.currentCtx) {
        return 0;
      }
  
      if (!pEnumName) {
        AL.currentCtx.err = 40963;
        return 0;
      }
      var name = UTF8ToString(pEnumName);
  
      switch (name) {
      // Spec doesn't clearly state that alGetEnumValue() is required to
      // support _only_ extension tokens.
      // We should probably follow OpenAL-Soft's example and support all
      // of the names we know.
      // See http://repo.or.cz/openal-soft.git/blob/HEAD:/Alc/ALc.c
      case 'AL_BITS': return 0x2002;
      case 'AL_BUFFER': return 0x1009;
      case 'AL_BUFFERS_PROCESSED': return 0x1016;
      case 'AL_BUFFERS_QUEUED': return 0x1015;
      case 'AL_BYTE_OFFSET': return 0x1026;
      case 'AL_CHANNELS': return 0x2003;
      case 'AL_CONE_INNER_ANGLE': return 0x1001;
      case 'AL_CONE_OUTER_ANGLE': return 0x1002;
      case 'AL_CONE_OUTER_GAIN': return 0x1022;
      case 'AL_DIRECTION': return 0x1005;
      case 'AL_DISTANCE_MODEL': return 0xD000;
      case 'AL_DOPPLER_FACTOR': return 0xC000;
      case 'AL_DOPPLER_VELOCITY': return 0xC001;
      case 'AL_EXPONENT_DISTANCE': return 0xD005;
      case 'AL_EXPONENT_DISTANCE_CLAMPED': return 0xD006;
      case 'AL_EXTENSIONS': return 0xB004;
      case 'AL_FORMAT_MONO16': return 0x1101;
      case 'AL_FORMAT_MONO8': return 0x1100;
      case 'AL_FORMAT_STEREO16': return 0x1103;
      case 'AL_FORMAT_STEREO8': return 0x1102;
      case 'AL_FREQUENCY': return 0x2001;
      case 'AL_GAIN': return 0x100A;
      case 'AL_INITIAL': return 0x1011;
      case 'AL_INVALID': return -1;
      case 'AL_ILLEGAL_ENUM': // fallthrough
      case 'AL_INVALID_ENUM': return 0xA002;
      case 'AL_INVALID_NAME': return 0xA001;
      case 'AL_ILLEGAL_COMMAND': // fallthrough
      case 'AL_INVALID_OPERATION': return 0xA004;
      case 'AL_INVALID_VALUE': return 0xA003;
      case 'AL_INVERSE_DISTANCE': return 0xD001;
      case 'AL_INVERSE_DISTANCE_CLAMPED': return 0xD002;
      case 'AL_LINEAR_DISTANCE': return 0xD003;
      case 'AL_LINEAR_DISTANCE_CLAMPED': return 0xD004;
      case 'AL_LOOPING': return 0x1007;
      case 'AL_MAX_DISTANCE': return 0x1023;
      case 'AL_MAX_GAIN': return 0x100E;
      case 'AL_MIN_GAIN': return 0x100D;
      case 'AL_NONE': return 0;
      case 'AL_NO_ERROR': return 0;
      case 'AL_ORIENTATION': return 0x100F;
      case 'AL_OUT_OF_MEMORY': return 0xA005;
      case 'AL_PAUSED': return 0x1013;
      case 'AL_PENDING': return 0x2011;
      case 'AL_PITCH': return 0x1003;
      case 'AL_PLAYING': return 0x1012;
      case 'AL_POSITION': return 0x1004;
      case 'AL_PROCESSED': return 0x2012;
      case 'AL_REFERENCE_DISTANCE': return 0x1020;
      case 'AL_RENDERER': return 0xB003;
      case 'AL_ROLLOFF_FACTOR': return 0x1021;
      case 'AL_SAMPLE_OFFSET': return 0x1025;
      case 'AL_SEC_OFFSET': return 0x1024;
      case 'AL_SIZE': return 0x2004;
      case 'AL_SOURCE_RELATIVE': return 0x202;
      case 'AL_SOURCE_STATE': return 0x1010;
      case 'AL_SOURCE_TYPE': return 0x1027;
      case 'AL_SPEED_OF_SOUND': return 0xC003;
      case 'AL_STATIC': return 0x1028;
      case 'AL_STOPPED': return 0x1014;
      case 'AL_STREAMING': return 0x1029;
      case 'AL_UNDETERMINED': return 0x1030;
      case 'AL_UNUSED': return 0x2010;
      case 'AL_VELOCITY': return 0x1006;
      case 'AL_VENDOR': return 0xB001;
      case 'AL_VERSION': return 0xB002;
  
      /* Extensions */
      case 'AL_AUTO_SOFT': return 0x0002;
      case 'AL_SOURCE_DISTANCE_MODEL': return 0x200;
      case 'AL_SOURCE_SPATIALIZE_SOFT': return 0x1214;
      case 'AL_LOOP_POINTS_SOFT': return 0x2015;
      case 'AL_BYTE_LENGTH_SOFT': return 0x2009;
      case 'AL_SAMPLE_LENGTH_SOFT': return 0x200A;
      case 'AL_SEC_LENGTH_SOFT': return 0x200B;
      case 'AL_FORMAT_MONO_FLOAT32': return 0x10010;
      case 'AL_FORMAT_STEREO_FLOAT32': return 0x10011;
  
      default:
        AL.currentCtx.err = 40963;
        return 0;
      }
    };
  _alGetEnumValue.sig = 'ip';

  var _alGetError = () => {
      if (!AL.currentCtx) {
        return 40964;
      }
      // Reset error on get.
      var err = AL.currentCtx.err;
      AL.currentCtx.err = 0;
      return err;
    };
  _alGetError.sig = 'i';

  var _alGetFloat = (param) => {
      var val = AL.getGlobalParam('alGetFloat', param);
      if (val === null) {
        return 0.0;
      }
  
      switch (param) {
      case 49152:
      case 49155:
      case 53248:
        return val;
      default:
        return 0.0;
      }
    };
  _alGetFloat.sig = 'fi';

  var _alGetFloatv = (param, pValues) => {
      var val = AL.getGlobalParam('alGetFloatv', param);
      // Silently ignore null destinations, as per the spec for global state functions
      if (val === null || !pValues) {
        return;
      }
  
      switch (param) {
      case 49152:
      case 49155:
      case 53248:
        HEAPF32[((pValues)>>2)] = val;
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alGetFloatv.sig = 'vip';

  var _alGetInteger = (param) => {
      var val = AL.getGlobalParam('alGetInteger', param);
      if (val === null) {
        return 0;
      }
  
      switch (param) {
      case 49152:
      case 49155:
      case 53248:
        return val;
      default:
        AL.currentCtx.err = 40962;
        return 0;
      }
    };
  _alGetInteger.sig = 'ii';

  var _alGetIntegerv = (param, pValues) => {
      var val = AL.getGlobalParam('alGetIntegerv', param);
      // Silently ignore null destinations, as per the spec for global state functions
      if (val === null || !pValues) {
        return;
      }
  
      switch (param) {
      case 49152:
      case 49155:
      case 53248:
        HEAP32[((pValues)>>2)] = val;
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alGetIntegerv.sig = 'vip';

  var _alGetListener3f = (param, pValue0, pValue1, pValue2) => {
      var val = AL.getListenerParam('alGetListener3f', param);
      if (val === null) {
        return;
      }
      if (!pValue0 || !pValue1 || !pValue2) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      switch (param) {
      case 4100:
      case 4102:
        HEAPF32[((pValue0)>>2)] = val[0];
        HEAPF32[((pValue1)>>2)] = val[1];
        HEAPF32[((pValue2)>>2)] = val[2];
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alGetListener3f.sig = 'vippp';

  var _alGetListener3i = (param, pValue0, pValue1, pValue2) => {
      var val = AL.getListenerParam('alGetListener3i', param);
      if (val === null) {
        return;
      }
      if (!pValue0 || !pValue1 || !pValue2) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      switch (param) {
      case 4100:
      case 4102:
        HEAP32[((pValue0)>>2)] = val[0];
        HEAP32[((pValue1)>>2)] = val[1];
        HEAP32[((pValue2)>>2)] = val[2];
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alGetListener3i.sig = 'vippp';

  var _alGetListenerf = (param, pValue) => {
      var val = AL.getListenerParam('alGetListenerf', param);
      if (val === null) {
        return;
      }
      if (!pValue) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      switch (param) {
      case 4106:
        HEAPF32[((pValue)>>2)] = val;
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alGetListenerf.sig = 'vip';

  var _alGetListenerfv = (param, pValues) => {
      var val = AL.getListenerParam('alGetListenerfv', param);
      if (val === null) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      switch (param) {
      case 4100:
      case 4102:
        HEAPF32[((pValues)>>2)] = val[0];
        HEAPF32[(((pValues)+(4))>>2)] = val[1];
        HEAPF32[(((pValues)+(8))>>2)] = val[2];
        break;
      case 4111:
        HEAPF32[((pValues)>>2)] = val[0];
        HEAPF32[(((pValues)+(4))>>2)] = val[1];
        HEAPF32[(((pValues)+(8))>>2)] = val[2];
        HEAPF32[(((pValues)+(12))>>2)] = val[3];
        HEAPF32[(((pValues)+(16))>>2)] = val[4];
        HEAPF32[(((pValues)+(20))>>2)] = val[5];
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alGetListenerfv.sig = 'vip';

  var _alGetListeneri = (param, pValue) => {
      var val = AL.getListenerParam('alGetListeneri', param);
      if (val === null) {
        return;
      }
      if (!pValue) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      AL.currentCtx.err = 40962;
    };
  _alGetListeneri.sig = 'vip';

  var _alGetListeneriv = (param, pValues) => {
      var val = AL.getListenerParam('alGetListeneriv', param);
      if (val === null) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      switch (param) {
      case 4100:
      case 4102:
        HEAP32[((pValues)>>2)] = val[0];
        HEAP32[(((pValues)+(4))>>2)] = val[1];
        HEAP32[(((pValues)+(8))>>2)] = val[2];
        break;
      case 4111:
        HEAP32[((pValues)>>2)] = val[0];
        HEAP32[(((pValues)+(4))>>2)] = val[1];
        HEAP32[(((pValues)+(8))>>2)] = val[2];
        HEAP32[(((pValues)+(12))>>2)] = val[3];
        HEAP32[(((pValues)+(16))>>2)] = val[4];
        HEAP32[(((pValues)+(20))>>2)] = val[5];
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alGetListeneriv.sig = 'vip';

  var _alGetSource3f = (sourceId, param, pValue0, pValue1, pValue2) => {
      var val = AL.getSourceParam('alGetSource3f', sourceId, param);
      if (val === null) {
        return;
      }
      if (!pValue0 || !pValue1 || !pValue2) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      switch (param) {
      case 4100:
      case 4101:
      case 4102:
        HEAPF32[((pValue0)>>2)] = val[0];
        HEAPF32[((pValue1)>>2)] = val[1];
        HEAPF32[((pValue2)>>2)] = val[2];
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alGetSource3f.sig = 'viippp';

  var _alGetSource3i = (sourceId, param, pValue0, pValue1, pValue2) => {
      var val = AL.getSourceParam('alGetSource3i', sourceId, param);
      if (val === null) {
        return;
      }
      if (!pValue0 || !pValue1 || !pValue2) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      switch (param) {
      case 4100:
      case 4101:
      case 4102:
        HEAP32[((pValue0)>>2)] = val[0];
        HEAP32[((pValue1)>>2)] = val[1];
        HEAP32[((pValue2)>>2)] = val[2];
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alGetSource3i.sig = 'viippp';

  var _alGetSourcef = (sourceId, param, pValue) => {
      var val = AL.getSourceParam('alGetSourcef', sourceId, param);
      if (val === null) {
        return;
      }
      if (!pValue) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      switch (param) {
      case 0x1001 /* AL_CONE_INNER_ANGLE */:
      case 0x1002 /* AL_CONE_OUTER_ANGLE */:
      case 0x1003 /* AL_PITCH */:
      case 4106:
      case 0x100D /* AL_MIN_GAIN */:
      case 0x100E /* AL_MAX_GAIN */:
      case 0x1020 /* AL_REFERENCE_DISTANCE */:
      case 0x1021 /* AL_ROLLOFF_FACTOR */:
      case 0x1022 /* AL_CONE_OUTER_GAIN */:
      case 0x1023 /* AL_MAX_DISTANCE */:
      case 0x1024 /* AL_SEC_OFFSET */:
      case 0x1025 /* AL_SAMPLE_OFFSET */:
      case 0x1026 /* AL_BYTE_OFFSET */:
      case 0x200B /* AL_SEC_LENGTH_SOFT */:
        HEAPF32[((pValue)>>2)] = val;
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alGetSourcef.sig = 'viip';

  var _alGetSourcefv = (sourceId, param, pValues) => {
      var val = AL.getSourceParam('alGetSourcefv', sourceId, param);
      if (val === null) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      switch (param) {
      case 0x1001 /* AL_CONE_INNER_ANGLE */:
      case 0x1002 /* AL_CONE_OUTER_ANGLE */:
      case 0x1003 /* AL_PITCH */:
      case 4106:
      case 0x100D /* AL_MIN_GAIN */:
      case 0x100E /* AL_MAX_GAIN */:
      case 0x1020 /* AL_REFERENCE_DISTANCE */:
      case 0x1021 /* AL_ROLLOFF_FACTOR */:
      case 0x1022 /* AL_CONE_OUTER_GAIN */:
      case 0x1023 /* AL_MAX_DISTANCE */:
      case 0x1024 /* AL_SEC_OFFSET */:
      case 0x1025 /* AL_SAMPLE_OFFSET */:
      case 0x1026 /* AL_BYTE_OFFSET */:
      case 0x200B /* AL_SEC_LENGTH_SOFT */:
        HEAPF32[((pValues)>>2)] = val[0];
        break;
      case 4100:
      case 4101:
      case 4102:
        HEAPF32[((pValues)>>2)] = val[0];
        HEAPF32[(((pValues)+(4))>>2)] = val[1];
        HEAPF32[(((pValues)+(8))>>2)] = val[2];
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alGetSourcefv.sig = 'viip';

  var _alGetSourcei = (sourceId, param, pValue) => {
      var val = AL.getSourceParam('alGetSourcei', sourceId, param);
      if (val === null) {
        return;
      }
      if (!pValue) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      switch (param) {
      case 0x202 /* AL_SOURCE_RELATIVE */:
      case 0x1001 /* AL_CONE_INNER_ANGLE */:
      case 0x1002 /* AL_CONE_OUTER_ANGLE */:
      case 0x1007 /* AL_LOOPING */:
      case 0x1009 /* AL_BUFFER */:
      case 0x1010 /* AL_SOURCE_STATE */:
      case 0x1015 /* AL_BUFFERS_QUEUED */:
      case 0x1016 /* AL_BUFFERS_PROCESSED */:
      case 0x1020 /* AL_REFERENCE_DISTANCE */:
      case 0x1021 /* AL_ROLLOFF_FACTOR */:
      case 0x1023 /* AL_MAX_DISTANCE */:
      case 0x1024 /* AL_SEC_OFFSET */:
      case 0x1025 /* AL_SAMPLE_OFFSET */:
      case 0x1026 /* AL_BYTE_OFFSET */:
      case 0x1027 /* AL_SOURCE_TYPE */:
      case 0x1214 /* AL_SOURCE_SPATIALIZE_SOFT */:
      case 0x2009 /* AL_BYTE_LENGTH_SOFT */:
      case 0x200A /* AL_SAMPLE_LENGTH_SOFT */:
      case 53248:
        HEAP32[((pValue)>>2)] = val;
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alGetSourcei.sig = 'viip';

  var _alGetSourceiv = (sourceId, param, pValues) => {
      var val = AL.getSourceParam('alGetSourceiv', sourceId, param);
      if (val === null) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      switch (param) {
      case 0x202 /* AL_SOURCE_RELATIVE */:
      case 0x1001 /* AL_CONE_INNER_ANGLE */:
      case 0x1002 /* AL_CONE_OUTER_ANGLE */:
      case 0x1007 /* AL_LOOPING */:
      case 0x1009 /* AL_BUFFER */:
      case 0x1010 /* AL_SOURCE_STATE */:
      case 0x1015 /* AL_BUFFERS_QUEUED */:
      case 0x1016 /* AL_BUFFERS_PROCESSED */:
      case 0x1020 /* AL_REFERENCE_DISTANCE */:
      case 0x1021 /* AL_ROLLOFF_FACTOR */:
      case 0x1023 /* AL_MAX_DISTANCE */:
      case 0x1024 /* AL_SEC_OFFSET */:
      case 0x1025 /* AL_SAMPLE_OFFSET */:
      case 0x1026 /* AL_BYTE_OFFSET */:
      case 0x1027 /* AL_SOURCE_TYPE */:
      case 0x1214 /* AL_SOURCE_SPATIALIZE_SOFT */:
      case 0x2009 /* AL_BYTE_LENGTH_SOFT */:
      case 0x200A /* AL_SAMPLE_LENGTH_SOFT */:
      case 53248:
        HEAP32[((pValues)>>2)] = val;
        break;
      case 4100:
      case 4101:
      case 4102:
        HEAP32[((pValues)>>2)] = val[0];
        HEAP32[(((pValues)+(4))>>2)] = val[1];
        HEAP32[(((pValues)+(8))>>2)] = val[2];
        break;
      default:
        AL.currentCtx.err = 40962;
        return;
      }
    };
  _alGetSourceiv.sig = 'viip';

  
  
  var stringToNewUTF8 = (str) => {
      var size = lengthBytesUTF8(str) + 1;
      var ret = _malloc(size);
      if (ret) stringToUTF8(str, ret, size);
      return ret;
    };
  
  var _alGetString = (param) => {
      if (AL.stringCache[param]) {
        return AL.stringCache[param];
      }
  
      var ret;
      switch (param) {
      case 0:
        ret = 'No Error';
        break;
      case 40961:
        ret = 'Invalid Name';
        break;
      case 40962:
        ret = 'Invalid Enum';
        break;
      case 40963:
        ret = 'Invalid Value';
        break;
      case 40964:
        ret = 'Invalid Operation';
        break;
      case 0xA005 /* AL_OUT_OF_MEMORY */:
        ret = 'Out of Memory';
        break;
      case 0xB001 /* AL_VENDOR */:
        ret = 'Emscripten';
        break;
      case 0xB002 /* AL_VERSION */:
        ret = '1.1';
        break;
      case 0xB003 /* AL_RENDERER */:
        ret = 'WebAudio';
        break;
      case 0xB004 /* AL_EXTENSIONS */:
        ret = Object.keys(AL.AL_EXTENSIONS).join(' ');
        break;
      default:
        if (AL.currentCtx) {
          AL.currentCtx.err = 40962;
        } else {
        }
        return 0;
      }
  
      ret = stringToNewUTF8(ret);
      AL.stringCache[param] = ret;
      return ret;
    };
  _alGetString.sig = 'pi';

  var _alIsBuffer = (bufferId) => {
      if (!AL.currentCtx) {
        return false;
      }
      if (bufferId > AL.buffers.length) {
        return false;
      }
  
      if (!AL.buffers[bufferId]) {
        return false;
      }
      return true;
    };
  _alIsBuffer.sig = 'ii';

  var _alIsEnabled = (param) => {
      if (!AL.currentCtx) {
        return 0;
      }
      switch (param) {
      case 0x200 /* AL_SOURCE_DISTANCE_MODEL */:
        return AL.currentCtx.sourceDistanceModel ? 0 : 1;
      default:
        AL.currentCtx.err = 40962;
        return 0;
      }
    };
  _alIsEnabled.sig = 'ii';

  
  var _alIsExtensionPresent = (pExtName) => {
      var name = UTF8ToString(pExtName);
  
      return AL.AL_EXTENSIONS[name] ? 1 : 0;
    };
  _alIsExtensionPresent.sig = 'ip';

  var _alIsSource = (sourceId) => {
      if (!AL.currentCtx) {
        return false;
      }
  
      if (!AL.currentCtx.sources[sourceId]) {
        return false;
      }
      return true;
    };
  _alIsSource.sig = 'ii';

  var _alListener3f = (param, value0, value1, value2) => {
      switch (param) {
      case 4100:
      case 4102:
        AL.paramArray[0] = value0;
        AL.paramArray[1] = value1;
        AL.paramArray[2] = value2;
        AL.setListenerParam('alListener3f', param, AL.paramArray);
        break;
      default:
        AL.setListenerParam('alListener3f', param, null);
        break;
      }
    };
  _alListener3f.sig = 'vifff';

  var _alListener3i = (param, value0, value1, value2) => {
      switch (param) {
      case 4100:
      case 4102:
        AL.paramArray[0] = value0;
        AL.paramArray[1] = value1;
        AL.paramArray[2] = value2;
        AL.setListenerParam('alListener3i', param, AL.paramArray);
        break;
      default:
        AL.setListenerParam('alListener3i', param, null);
        break;
      }
    };
  _alListener3i.sig = 'viiii';

  var _alListenerf = (param, value) => {
      switch (param) {
      case 4106:
        AL.setListenerParam('alListenerf', param, value);
        break;
      default:
        AL.setListenerParam('alListenerf', param, null);
        break;
      }
    };
  _alListenerf.sig = 'vif';

  var _alListenerfv = (param, pValues) => {
      if (!AL.currentCtx) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      switch (param) {
      case 4100:
      case 4102:
        AL.paramArray[0] = HEAPF32[((pValues)>>2)];
        AL.paramArray[1] = HEAPF32[(((pValues)+(4))>>2)];
        AL.paramArray[2] = HEAPF32[(((pValues)+(8))>>2)];
        AL.setListenerParam('alListenerfv', param, AL.paramArray);
        break;
      case 4111:
        AL.paramArray[0] = HEAPF32[((pValues)>>2)];
        AL.paramArray[1] = HEAPF32[(((pValues)+(4))>>2)];
        AL.paramArray[2] = HEAPF32[(((pValues)+(8))>>2)];
        AL.paramArray[3] = HEAPF32[(((pValues)+(12))>>2)];
        AL.paramArray[4] = HEAPF32[(((pValues)+(16))>>2)];
        AL.paramArray[5] = HEAPF32[(((pValues)+(20))>>2)];
        AL.setListenerParam('alListenerfv', param, AL.paramArray);
        break;
      default:
        AL.setListenerParam('alListenerfv', param, null);
        break;
      }
    };
  _alListenerfv.sig = 'vip';

  var _alListeneri = (param, value) => {
      AL.setListenerParam('alListeneri', param, null);
    };
  _alListeneri.sig = 'vii';

  var _alListeneriv = (param, pValues) => {
      if (!AL.currentCtx) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      switch (param) {
      case 4100:
      case 4102:
        AL.paramArray[0] = HEAP32[((pValues)>>2)];
        AL.paramArray[1] = HEAP32[(((pValues)+(4))>>2)];
        AL.paramArray[2] = HEAP32[(((pValues)+(8))>>2)];
        AL.setListenerParam('alListeneriv', param, AL.paramArray);
        break;
      case 4111:
        AL.paramArray[0] = HEAP32[((pValues)>>2)];
        AL.paramArray[1] = HEAP32[(((pValues)+(4))>>2)];
        AL.paramArray[2] = HEAP32[(((pValues)+(8))>>2)];
        AL.paramArray[3] = HEAP32[(((pValues)+(12))>>2)];
        AL.paramArray[4] = HEAP32[(((pValues)+(16))>>2)];
        AL.paramArray[5] = HEAP32[(((pValues)+(20))>>2)];
        AL.setListenerParam('alListeneriv', param, AL.paramArray);
        break;
      default:
        AL.setListenerParam('alListeneriv', param, null);
        break;
      }
    };
  _alListeneriv.sig = 'vip';

  var _alSource3f = (sourceId, param, value0, value1, value2) => {
      switch (param) {
      case 4100:
      case 4101:
      case 4102:
        AL.paramArray[0] = value0;
        AL.paramArray[1] = value1;
        AL.paramArray[2] = value2;
        AL.setSourceParam('alSource3f', sourceId, param, AL.paramArray);
        break;
      default:
        AL.setSourceParam('alSource3f', sourceId, param, null);
        break;
      }
    };
  _alSource3f.sig = 'viifff';

  var _alSource3i = (sourceId, param, value0, value1, value2) => {
      switch (param) {
      case 4100:
      case 4101:
      case 4102:
        AL.paramArray[0] = value0;
        AL.paramArray[1] = value1;
        AL.paramArray[2] = value2;
        AL.setSourceParam('alSource3i', sourceId, param, AL.paramArray);
        break;
      default:
        AL.setSourceParam('alSource3i', sourceId, param, null);
        break;
      }
    };
  _alSource3i.sig = 'viiiii';

  var _alSourcePause = (sourceId) => {
      if (!AL.currentCtx) {
        return;
      }
      var src = AL.currentCtx.sources[sourceId];
      if (!src) {
        AL.currentCtx.err = 40961;
        return;
      }
      AL.setSourceState(src, 4115);
    };
  _alSourcePause.sig = 'vi';

  var _alSourcePausev = (count, pSourceIds) => {
      if (!AL.currentCtx) {
        return;
      }
      if (!pSourceIds) {
        AL.currentCtx.err = 40963;
      }
      for (var i = 0; i < count; ++i) {
        if (!AL.currentCtx.sources[HEAP32[(((pSourceIds)+(i*4))>>2)]]) {
          AL.currentCtx.err = 40961;
          return;
        }
      }
  
      for (var i = 0; i < count; ++i) {
        var srcId = HEAP32[(((pSourceIds)+(i*4))>>2)];
        AL.setSourceState(AL.currentCtx.sources[srcId], 4115);
      }
    };
  _alSourcePausev.sig = 'vip';

  var _alSourcePlay = (sourceId) => {
      if (!AL.currentCtx) {
        return;
      }
      var src = AL.currentCtx.sources[sourceId];
      if (!src) {
        AL.currentCtx.err = 40961;
        return;
      }
      AL.setSourceState(src, 4114);
    };
  _alSourcePlay.sig = 'vi';

  var _alSourcePlayv = (count, pSourceIds) => {
      if (!AL.currentCtx) {
        return;
      }
      if (!pSourceIds) {
        AL.currentCtx.err = 40963;
      }
      for (var i = 0; i < count; ++i) {
        if (!AL.currentCtx.sources[HEAP32[(((pSourceIds)+(i*4))>>2)]]) {
          AL.currentCtx.err = 40961;
          return;
        }
      }
  
      for (var i = 0; i < count; ++i) {
        var srcId = HEAP32[(((pSourceIds)+(i*4))>>2)];
        AL.setSourceState(AL.currentCtx.sources[srcId], 4114);
      }
    };
  _alSourcePlayv.sig = 'vip';

  var _alSourceQueueBuffers = (sourceId, count, pBufferIds) => {
      if (!AL.currentCtx) {
        return;
      }
      var src = AL.currentCtx.sources[sourceId];
      if (!src) {
        AL.currentCtx.err = 40961;
        return;
      }
      if (src.type === 4136) {
        AL.currentCtx.err = 40964;
        return;
      }
  
      if (count === 0) {
        return;
      }
  
      // Find the first non-zero buffer in the queue to determine the proper format
      var templateBuf = AL.buffers[0];
      for (var i = 0; i < src.bufQueue.length; i++) {
        if (src.bufQueue[i].id !== 0) {
          templateBuf = src.bufQueue[i];
          break;
        }
      }
  
      for (var i = 0; i < count; ++i) {
        var bufId = HEAP32[(((pBufferIds)+(i*4))>>2)];
        var buf = AL.buffers[bufId];
        if (!buf) {
          AL.currentCtx.err = 40961;
          return;
        }
  
        // Check that the added buffer has the correct format. If the template is the zero buffer, any format is valid.
        if (templateBuf.id !== 0 && (
          buf.frequency !== templateBuf.frequency
          || buf.bytesPerSample !== templateBuf.bytesPerSample
          || buf.channels !== templateBuf.channels)
        ) {
          AL.currentCtx.err = 40964;
        }
      }
  
      // If the only buffer in the queue is the zero buffer, clear the queue before we add anything.
      if (src.bufQueue.length === 1 && src.bufQueue[0].id === 0) {
        src.bufQueue.length = 0;
      }
  
      src.type = 0x1029 /* AL_STREAMING */;
      for (var i = 0; i < count; ++i) {
        var bufId = HEAP32[(((pBufferIds)+(i*4))>>2)];
        var buf = AL.buffers[bufId];
        buf.refCount++;
        src.bufQueue.push(buf);
      }
  
      // if the source is looping, cancel the schedule so we can reschedule the loop order
      if (src.looping) {
        AL.cancelPendingSourceAudio(src);
      }
  
      AL.initSourcePanner(src);
      AL.scheduleSourceAudio(src);
    };
  _alSourceQueueBuffers.sig = 'viip';

  var _alSourceRewind = (sourceId) => {
      if (!AL.currentCtx) {
        return;
      }
      var src = AL.currentCtx.sources[sourceId];
      if (!src) {
        AL.currentCtx.err = 40961;
        return;
      }
      // Stop the source first to clear the source queue
      AL.setSourceState(src, 4116);
      // Now set the state of AL_INITIAL according to the specification
      AL.setSourceState(src, 4113);
    };
  _alSourceRewind.sig = 'vi';

  var _alSourceRewindv = (count, pSourceIds) => {
      if (!AL.currentCtx) {
        return;
      }
      if (!pSourceIds) {
        AL.currentCtx.err = 40963;
      }
      for (var i = 0; i < count; ++i) {
        if (!AL.currentCtx.sources[HEAP32[(((pSourceIds)+(i*4))>>2)]]) {
          AL.currentCtx.err = 40961;
          return;
        }
      }
  
      for (var i = 0; i < count; ++i) {
        var srcId = HEAP32[(((pSourceIds)+(i*4))>>2)];
        AL.setSourceState(AL.currentCtx.sources[srcId], 4113);
      }
    };
  _alSourceRewindv.sig = 'vip';

  var _alSourceStop = (sourceId) => {
      if (!AL.currentCtx) {
        return;
      }
      var src = AL.currentCtx.sources[sourceId];
      if (!src) {
        AL.currentCtx.err = 40961;
        return;
      }
      AL.setSourceState(src, 4116);
    };
  _alSourceStop.sig = 'vi';

  var _alSourceStopv = (count, pSourceIds) => {
      if (!AL.currentCtx) {
        return;
      }
      if (!pSourceIds) {
        AL.currentCtx.err = 40963;
      }
      for (var i = 0; i < count; ++i) {
        if (!AL.currentCtx.sources[HEAP32[(((pSourceIds)+(i*4))>>2)]]) {
          AL.currentCtx.err = 40961;
          return;
        }
      }
  
      for (var i = 0; i < count; ++i) {
        var srcId = HEAP32[(((pSourceIds)+(i*4))>>2)];
        AL.setSourceState(AL.currentCtx.sources[srcId], 4116);
      }
    };
  _alSourceStopv.sig = 'vip';

  var _alSourceUnqueueBuffers = (sourceId, count, pBufferIds) => {
      if (!AL.currentCtx) {
        return;
      }
      var src = AL.currentCtx.sources[sourceId];
      if (!src) {
        AL.currentCtx.err = 40961;
        return;
      }
      if (count > (src.bufQueue.length === 1 && src.bufQueue[0].id === 0 ? 0 : src.bufsProcessed)) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      if (count === 0) {
        return;
      }
  
      for (var i = 0; i < count; i++) {
        var buf = src.bufQueue.shift();
        buf.refCount--;
        // Write the buffers index out to the return list.
        HEAP32[(((pBufferIds)+(i*4))>>2)] = buf.id;
        src.bufsProcessed--;
      }
  
      /// If the queue is empty, put the zero buffer back in
      if (src.bufQueue.length === 0) {
        src.bufQueue.push(AL.buffers[0]);
      }
  
      AL.initSourcePanner(src);
      AL.scheduleSourceAudio(src);
    };
  _alSourceUnqueueBuffers.sig = 'viip';

  var _alSourcef = (sourceId, param, value) => {
      switch (param) {
      case 0x1001 /* AL_CONE_INNER_ANGLE */:
      case 0x1002 /* AL_CONE_OUTER_ANGLE */:
      case 0x1003 /* AL_PITCH */:
      case 4106:
      case 0x100D /* AL_MIN_GAIN */:
      case 0x100E /* AL_MAX_GAIN */:
      case 0x1020 /* AL_REFERENCE_DISTANCE */:
      case 0x1021 /* AL_ROLLOFF_FACTOR */:
      case 0x1022 /* AL_CONE_OUTER_GAIN */:
      case 0x1023 /* AL_MAX_DISTANCE */:
      case 0x1024 /* AL_SEC_OFFSET */:
      case 0x1025 /* AL_SAMPLE_OFFSET */:
      case 0x1026 /* AL_BYTE_OFFSET */:
      case 0x200B /* AL_SEC_LENGTH_SOFT */:
        AL.setSourceParam('alSourcef', sourceId, param, value);
        break;
      default:
        AL.setSourceParam('alSourcef', sourceId, param, null);
        break;
      }
    };
  _alSourcef.sig = 'viif';

  var _alSourcefv = (sourceId, param, pValues) => {
      if (!AL.currentCtx) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      switch (param) {
      case 0x1001 /* AL_CONE_INNER_ANGLE */:
      case 0x1002 /* AL_CONE_OUTER_ANGLE */:
      case 0x1003 /* AL_PITCH */:
      case 4106:
      case 0x100D /* AL_MIN_GAIN */:
      case 0x100E /* AL_MAX_GAIN */:
      case 0x1020 /* AL_REFERENCE_DISTANCE */:
      case 0x1021 /* AL_ROLLOFF_FACTOR */:
      case 0x1022 /* AL_CONE_OUTER_GAIN */:
      case 0x1023 /* AL_MAX_DISTANCE */:
      case 0x1024 /* AL_SEC_OFFSET */:
      case 0x1025 /* AL_SAMPLE_OFFSET */:
      case 0x1026 /* AL_BYTE_OFFSET */:
      case 0x200B /* AL_SEC_LENGTH_SOFT */:
        var val = HEAPF32[((pValues)>>2)];
        AL.setSourceParam('alSourcefv', sourceId, param, val);
        break;
      case 4100:
      case 4101:
      case 4102:
        AL.paramArray[0] = HEAPF32[((pValues)>>2)];
        AL.paramArray[1] = HEAPF32[(((pValues)+(4))>>2)];
        AL.paramArray[2] = HEAPF32[(((pValues)+(8))>>2)];
        AL.setSourceParam('alSourcefv', sourceId, param, AL.paramArray);
        break;
      default:
        AL.setSourceParam('alSourcefv', sourceId, param, null);
        break;
      }
    };
  _alSourcefv.sig = 'viip';


  var _alSourceiv = (sourceId, param, pValues) => {
      if (!AL.currentCtx) {
        return;
      }
      if (!pValues) {
        AL.currentCtx.err = 40963;
        return;
      }
  
      switch (param) {
      case 0x202 /* AL_SOURCE_RELATIVE */:
      case 0x1001 /* AL_CONE_INNER_ANGLE */:
      case 0x1002 /* AL_CONE_OUTER_ANGLE */:
      case 0x1007 /* AL_LOOPING */:
      case 0x1009 /* AL_BUFFER */:
      case 0x1020 /* AL_REFERENCE_DISTANCE */:
      case 0x1021 /* AL_ROLLOFF_FACTOR */:
      case 0x1023 /* AL_MAX_DISTANCE */:
      case 0x1024 /* AL_SEC_OFFSET */:
      case 0x1025 /* AL_SAMPLE_OFFSET */:
      case 0x1026 /* AL_BYTE_OFFSET */:
      case 0x1214 /* AL_SOURCE_SPATIALIZE_SOFT */:
      case 0x2009 /* AL_BYTE_LENGTH_SOFT */:
      case 0x200A /* AL_SAMPLE_LENGTH_SOFT */:
      case 53248:
        var val = HEAP32[((pValues)>>2)];
        AL.setSourceParam('alSourceiv', sourceId, param, val);
        break;
      case 4100:
      case 4101:
      case 4102:
        AL.paramArray[0] = HEAP32[((pValues)>>2)];
        AL.paramArray[1] = HEAP32[(((pValues)+(4))>>2)];
        AL.paramArray[2] = HEAP32[(((pValues)+(8))>>2)];
        AL.setSourceParam('alSourceiv', sourceId, param, AL.paramArray);
        break;
      default:
        AL.setSourceParam('alSourceiv', sourceId, param, null);
        break;
      }
    };
  _alSourceiv.sig = 'viip';

  var _alSpeedOfSound = (value) => {
      AL.setGlobalParam('alSpeedOfSound', 49155, value);
    };
  _alSpeedOfSound.sig = 'vf';

  var _alcCaptureCloseDevice = (deviceId) => {
      var c = AL.requireValidCaptureDevice(deviceId, 'alcCaptureCloseDevice');
      if (!c) return false;
  
      delete AL.captures[deviceId];
      AL.freeIds.push(deviceId);
  
      // This clean-up might be unnecessary (paranoid) ?
  
      // May happen if user hasn't decided to grant or deny input
      c.mediaStreamSourceNode?.disconnect();
      c.mergerNode?.disconnect();
      c.splitterNode?.disconnect();
      // May happen if user hasn't decided to grant or deny input
      c.scriptProcessorNode?.disconnect();
      if (c.mediaStream) {
        // Disabling the microphone of the browser.
        // Without this operation, the red dot on the browser tab page will remain.
        c.mediaStream.getTracks().forEach((track) => track.stop());
      }
  
      delete c.buffers;
  
      c.capturedFrameCount = 0;
      c.isCapturing = false;
  
      return true;
    };
  _alcCaptureCloseDevice.sig = 'ip';

  var listenOnce = (object, event, func) =>
      object.addEventListener(event, func, { 'once': true });
  /** @param {Object=} elements */
  var autoResumeAudioContext = (ctx, elements) => {
      if (!elements) {
        elements = [document, document.getElementById('canvas')];
      }
      ['keydown', 'mousedown', 'touchstart'].forEach((event) => {
        elements.forEach((element) => {
          if (element) {
            listenOnce(element, event, () => {
              if (ctx.state === 'suspended') ctx.resume();
            });
          }
        });
      });
    };
  
  
  var _alcCaptureOpenDevice = (pDeviceName, requestedSampleRate, format, bufferFrameCapacity) => {
  
      var resolvedDeviceName = AL.CAPTURE_DEVICE_NAME;
  
      // NULL is a valid device name here (resolves to default);
      if (pDeviceName !== 0) {
        resolvedDeviceName = UTF8ToString(pDeviceName);
        if (resolvedDeviceName !== AL.CAPTURE_DEVICE_NAME) {
          // ALC_OUT_OF_MEMORY
          // From the programmer's guide, ALC_OUT_OF_MEMORY's meaning is
          // overloaded here, to mean:
          // 'The specified device is invalid, or can not capture audio.'
          // This may be misleading to API users, but well...
          AL.alcErr = 0xA005 /* ALC_OUT_OF_MEMORY */;
          return 0;
        }
      }
  
      // Otherwise it's probably okay (though useless) for bufferFrameCapacity to be zero.
      if (bufferFrameCapacity < 0) { // ALCsizei is signed int
        AL.alcErr = 40964;
        return 0;
      }
  
      navigator.getUserMedia = navigator.getUserMedia
        || navigator.webkitGetUserMedia
        || navigator.mozGetUserMedia
        || navigator.msGetUserMedia;
      var has_getUserMedia = navigator.getUserMedia
        || (navigator.mediaDevices
        &&  navigator.mediaDevices.getUserMedia);
  
      if (!has_getUserMedia) {
        // See previously mentioned rationale for ALC_OUT_OF_MEMORY
        AL.alcErr = 0xA005 /* ALC_OUT_OF_MEMORY */;
        return 0;
      }
  
      var AudioContext = window.AudioContext || window.webkitAudioContext;
  
      if (!AL.sharedCaptureAudioCtx) {
        try {
          AL.sharedCaptureAudioCtx = new AudioContext();
        } catch(e) {
          // See previously mentioned rationale for ALC_OUT_OF_MEMORY
          AL.alcErr = 0xA005 /* ALC_OUT_OF_MEMORY */;
          return 0;
        }
      }
  
      autoResumeAudioContext(AL.sharedCaptureAudioCtx);
  
      var outputChannelCount;
  
      switch (format) {
      case 0x10010: /* AL_FORMAT_MONO_FLOAT32 */
      case 0x1101:  /* AL_FORMAT_MONO16 */
      case 0x1100:  /* AL_FORMAT_MONO8 */
        outputChannelCount = 1;
        break;
      case 0x10011: /* AL_FORMAT_STEREO_FLOAT32 */
      case 0x1103:  /* AL_FORMAT_STEREO16 */
      case 0x1102:  /* AL_FORMAT_STEREO8 */
        outputChannelCount = 2;
        break;
      default:
        AL.alcErr = 40964;
        return 0;
      }
  
      function newF32Array(cap) { return new Float32Array(cap);}
      function newI16Array(cap) { return new Int16Array(cap);  }
      function newU8Array(cap)  { return new Uint8Array(cap);  }
  
      var requestedSampleType;
      var newSampleArray;
  
      switch (format) {
      case 0x10010: /* AL_FORMAT_MONO_FLOAT32 */
      case 0x10011: /* AL_FORMAT_STEREO_FLOAT32 */
        requestedSampleType = 'f32';
        newSampleArray = newF32Array;
        break;
      case 0x1101:  /* AL_FORMAT_MONO16 */
      case 0x1103:  /* AL_FORMAT_STEREO16 */
        requestedSampleType = 'i16';
        newSampleArray = newI16Array;
        break;
      case 0x1100:  /* AL_FORMAT_MONO8 */
      case 0x1102:  /* AL_FORMAT_STEREO8 */
        requestedSampleType = 'u8';
        newSampleArray = newU8Array;
        break;
      }
  
      var buffers = [];
      try {
        for (var chan=0; chan < outputChannelCount; ++chan) {
          buffers[chan] = newSampleArray(bufferFrameCapacity);
        }
      } catch(e) {
        AL.alcErr = 0xA005 /* ALC_OUT_OF_MEMORY */;
        return 0;
      }
  
      // What we'll place into the `AL.captures` array in the end,
      // declared here for closures to access it
      var newCapture = {
        audioCtx: AL.sharedCaptureAudioCtx,
        deviceName: resolvedDeviceName,
        requestedSampleRate,
        requestedSampleType,
        outputChannelCount,
        inputChannelCount: null, // Not known until the getUserMedia() promise resolves
        mediaStreamError: null, // Used by other functions to return early and report an error.
        mediaStreamSourceNode: null,
        mediaStream: null,
        // Either one, or none of the below two, is active.
        mergerNode: null,
        splitterNode: null,
        scriptProcessorNode: null,
        isCapturing: false,
        buffers,
        get bufferFrameCapacity() {
          return buffers[0].length;
        },
        capturePlayhead: 0, // current write position, in sample frames
        captureReadhead: 0,
        capturedFrameCount: 0
      };
  
      // Preparing for getUserMedia()
  
      var onError = (mediaStreamError) => {
        newCapture.mediaStreamError = mediaStreamError;
      };
      var onSuccess = (mediaStream) => {
        newCapture.mediaStreamSourceNode = newCapture.audioCtx.createMediaStreamSource(mediaStream);
        newCapture.mediaStream = mediaStream;
  
        var inputChannelCount = 1;
        switch (newCapture.mediaStreamSourceNode.channelCountMode) {
        case 'max':
          inputChannelCount = outputChannelCount;
          break;
        case 'clamped-max':
          inputChannelCount = Math.min(outputChannelCount, newCapture.mediaStreamSourceNode.channelCount);
          break;
        case 'explicit':
          inputChannelCount = newCapture.mediaStreamSourceNode.channelCount;
          break;
        }
  
        newCapture.inputChannelCount = inputChannelCount;
  
        // Have to pick a size from 256, 512, 1024, 2048, 4096, 8192, 16384.
        // One can also set it to zero, which leaves the decision up to the impl.
        // An extension could allow specifying this value.
        var processorFrameCount = 512;
  
        newCapture.scriptProcessorNode = newCapture.audioCtx.createScriptProcessor(
          processorFrameCount, inputChannelCount, outputChannelCount
        );
  
        if (inputChannelCount > outputChannelCount) {
          newCapture.mergerNode = newCapture.audioCtx.createChannelMerger(inputChannelCount);
          newCapture.mediaStreamSourceNode.connect(newCapture.mergerNode);
          newCapture.mergerNode.connect(newCapture.scriptProcessorNode);
        } else if (inputChannelCount < outputChannelCount) {
          newCapture.splitterNode = newCapture.audioCtx.createChannelSplitter(outputChannelCount);
          newCapture.mediaStreamSourceNode.connect(newCapture.splitterNode);
          newCapture.splitterNode.connect(newCapture.scriptProcessorNode);
        } else {
          newCapture.mediaStreamSourceNode.connect(newCapture.scriptProcessorNode);
        }
  
        newCapture.scriptProcessorNode.connect(newCapture.audioCtx.destination);
  
        newCapture.scriptProcessorNode.onaudioprocess = (audioProcessingEvent) => {
          if (!newCapture.isCapturing) {
            return;
          }
  
          var c = newCapture;
          var srcBuf = audioProcessingEvent.inputBuffer;
  
          // Actually just copy srcBuf's channel data into
          // c.buffers, optimizing for each case.
          switch (format) {
          case 0x10010: /* AL_FORMAT_MONO_FLOAT32 */
            var channel0 = srcBuf.getChannelData(0);
            for (var i = 0 ; i < srcBuf.length; ++i) {
              var wi = (c.capturePlayhead + i) % c.bufferFrameCapacity;
              c.buffers[0][wi] = channel0[i];
            }
            break;
          case 0x10011: /* AL_FORMAT_STEREO_FLOAT32 */
            var channel0 = srcBuf.getChannelData(0);
            var channel1 = srcBuf.getChannelData(1);
            for (var i = 0 ; i < srcBuf.length; ++i) {
              var wi = (c.capturePlayhead + i) % c.bufferFrameCapacity;
              c.buffers[0][wi] = channel0[i];
              c.buffers[1][wi] = channel1[i];
            }
            break;
          case 0x1101:  /* AL_FORMAT_MONO16 */
            var channel0 = srcBuf.getChannelData(0);
            for (var i = 0 ; i < srcBuf.length; ++i) {
              var wi = (c.capturePlayhead + i) % c.bufferFrameCapacity;
              c.buffers[0][wi] = channel0[i] * 32767;
            }
            break;
          case 0x1103:  /* AL_FORMAT_STEREO16 */
            var channel0 = srcBuf.getChannelData(0);
            var channel1 = srcBuf.getChannelData(1);
            for (var i = 0 ; i < srcBuf.length; ++i) {
              var wi = (c.capturePlayhead + i) % c.bufferFrameCapacity;
              c.buffers[0][wi] = channel0[i] * 32767;
              c.buffers[1][wi] = channel1[i] * 32767;
            }
            break;
          case 0x1100:  /* AL_FORMAT_MONO8 */
            var channel0 = srcBuf.getChannelData(0);
            for (var i = 0 ; i < srcBuf.length; ++i) {
              var wi = (c.capturePlayhead + i) % c.bufferFrameCapacity;
              c.buffers[0][wi] = (channel0[i] + 1.0) * 127;
            }
            break;
          case 0x1102:  /* AL_FORMAT_STEREO8 */
            var channel0 = srcBuf.getChannelData(0);
            var channel1 = srcBuf.getChannelData(1);
            for (var i = 0 ; i < srcBuf.length; ++i) {
              var wi = (c.capturePlayhead + i) % c.bufferFrameCapacity;
              c.buffers[0][wi] = (channel0[i] + 1.0) * 127;
              c.buffers[1][wi] = (channel1[i] + 1.0) * 127;
            }
            break;
          }
  
          c.capturePlayhead += srcBuf.length;
          c.capturePlayhead %= c.bufferFrameCapacity;
          c.capturedFrameCount += srcBuf.length;
          c.capturedFrameCount = Math.min(c.capturedFrameCount, c.bufferFrameCapacity);
        };
      };
  
      // The latest way to call getUserMedia()
      if (navigator.mediaDevices?.getUserMedia) {
        navigator.mediaDevices
             .getUserMedia({audio: true})
             .then(onSuccess)
             .catch(onError);
      } else { // The usual (now deprecated) way
        navigator.getUserMedia({audio: true}, onSuccess, onError);
      }
  
      var id = AL.newId();
      AL.captures[id] = newCapture;
      return id;
    };
  _alcCaptureOpenDevice.sig = 'ppiii';

  var _alcCaptureSamples = (deviceId, pFrames, requestedFrameCount) => {
      var c = AL.requireValidCaptureDevice(deviceId, 'alcCaptureSamples');
      if (!c) return;
  
      // ALCsizei is actually 32-bit signed int, so could be negative
      // Also, spec says :
      //   Requesting more sample frames than are currently available is
      //   an error.
  
      var dstfreq = c.requestedSampleRate;
      var srcfreq = c.audioCtx.sampleRate;
  
      var fratio = srcfreq / dstfreq;
  
      if (requestedFrameCount < 0
      ||  requestedFrameCount > (c.capturedFrameCount / fratio))
      {
        AL.alcErr = 40964;
        return;
      }
  
      function setF32Sample(i, sample) {
        HEAPF32[(((pFrames)+(4*i))>>2)] = sample;
      }
      function setI16Sample(i, sample) {
        HEAP16[(((pFrames)+(2*i))>>1)] = sample;
      }
      function setU8Sample(i, sample) {
        HEAP8[(pFrames)+(i)] = sample;
      }
  
      var setSample;
  
      switch (c.requestedSampleType) {
      case 'f32': setSample = setF32Sample; break;
      case 'i16': setSample = setI16Sample; break;
      case 'u8' : setSample = setU8Sample ; break;
      default:
        return;
      }
  
      // If fratio is an integer we don't need linear resampling, just skip samples
      if (Math.floor(fratio) == fratio) {
        for (var i = 0, frame_i = 0; frame_i < requestedFrameCount; ++frame_i) {
          for (var chan = 0; chan < c.buffers.length; ++chan, ++i) {
            setSample(i, c.buffers[chan][c.captureReadhead]);
          }
          c.captureReadhead = (fratio + c.captureReadhead) % c.bufferFrameCapacity;
        }
      } else {
        // Perform linear resampling.
  
        // There is room for improvement - right now we're fine with linear resampling.
        // We don't use OfflineAudioContexts for this: See the discussion at
        // https://github.com/jpernst/emscripten/issues/2#issuecomment-312729735
        // if you're curious about why.
        for (var i = 0, frame_i = 0; frame_i < requestedFrameCount; ++frame_i) {
          var lefti = Math.floor(c.captureReadhead);
          var righti = Math.ceil(c.captureReadhead);
          var d = c.captureReadhead - lefti;
          for (var chan = 0; chan < c.buffers.length; ++chan, ++i) {
            var lefts = c.buffers[chan][lefti];
            var rights = c.buffers[chan][righti];
            setSample(i, (1 - d) * lefts + d * rights);
          }
          c.captureReadhead = (c.captureReadhead + fratio) % c.bufferFrameCapacity;
        }
      }
  
      // Spec doesn't say if alcCaptureSamples() must zero the number
      // of available captured sample-frames, but not only would it
      // be insane not to do, OpenAL-Soft happens to do that as well.
      c.capturedFrameCount = 0;
    };
  _alcCaptureSamples.sig = 'vppi';

  var _alcCaptureStart = (deviceId) => {
      var c = AL.requireValidCaptureDevice(deviceId, 'alcCaptureStart');
      if (!c) return;
  
      if (c.isCapturing) {
        // NOTE: Spec says (emphasis mine):
        //     The amount of audio samples available after **restarting** a
        //     stopped capture device is reset to zero.
        // So redundant calls to alcCaptureStart() must have no effect.
        return;
      }
      c.isCapturing = true;
      c.capturedFrameCount = 0;
      c.capturePlayhead = 0;
    };
  _alcCaptureStart.sig = 'vp';

  var _alcCaptureStop = (deviceId) => {
      var c = AL.requireValidCaptureDevice(deviceId, 'alcCaptureStop');
      if (!c) return;
  
      c.isCapturing = false;
    };
  _alcCaptureStop.sig = 'vp';

  var _alcCloseDevice = (deviceId) => {
      if (!(deviceId in AL.deviceRefCounts) || AL.deviceRefCounts[deviceId] > 0) {
        return 0;
      }
  
      delete AL.deviceRefCounts[deviceId];
      AL.freeIds.push(deviceId);
      return 1;
    };
  _alcCloseDevice.sig = 'ip';

  
  var _alcCreateContext = (deviceId, pAttrList) => {
      if (!(deviceId in AL.deviceRefCounts)) {
        AL.alcErr = 0xA001; /* ALC_INVALID_DEVICE */
        return 0;
      }
  
      var options = null;
      var attrs = [];
      var hrtf = null;
      pAttrList >>= 2;
      if (pAttrList) {
        var attr = 0;
        var val = 0;
        while (true) {
          attr = HEAP32[pAttrList++];
          attrs.push(attr);
          if (attr === 0) {
            break;
          }
          val = HEAP32[pAttrList++];
          attrs.push(val);
  
          switch (attr) {
          case 0x1007 /* ALC_FREQUENCY */:
            if (!options) {
              options = {};
            }
  
            options.sampleRate = val;
            break;
          case 0x1010 /* ALC_MONO_SOURCES */: // fallthrough
          case 0x1011 /* ALC_STEREO_SOURCES */:
            // Do nothing; these hints are satisfied by default
            break
          case 0x1992 /* ALC_HRTF_SOFT */:
            switch (val) {
              case 0:
                hrtf = false;
                break;
              case 1:
                hrtf = true;
                break;
              case 2 /* ALC_DONT_CARE_SOFT */:
                break;
              default:
                AL.alcErr = 40964;
                return 0;
            }
            break;
          case 0x1996 /* ALC_HRTF_ID_SOFT */:
            if (val !== 0) {
              AL.alcErr = 40964;
              return 0;
            }
            break;
          default:
            AL.alcErr = 0xA004; /* ALC_INVALID_VALUE */
            return 0;
          }
        }
      }
  
      var AudioContext = window.AudioContext || window.webkitAudioContext;
      var ac = null;
      try {
        // Only try to pass options if there are any, for compat with browsers that don't support this
        if (options) {
          ac = new AudioContext(options);
        } else {
          ac = new AudioContext();
        }
      } catch (e) {
        if (e.name === 'NotSupportedError') {
          AL.alcErr = 0xA004; /* ALC_INVALID_VALUE */
        } else {
          AL.alcErr = 0xA001; /* ALC_INVALID_DEVICE */
        }
  
        return 0;
      }
  
      autoResumeAudioContext(ac);
  
      // Old Web Audio API (e.g. Safari 6.0.5) had an inconsistently named createGainNode function.
      if (typeof ac.createGain == 'undefined') {
        ac.createGain = ac.createGainNode;
      }
  
      var gain = ac.createGain();
      gain.connect(ac.destination);
      var ctx = {
        deviceId,
        id: AL.newId(),
        attrs,
        audioCtx: ac,
        listener: {
          position: [0.0, 0.0, 0.0],
          velocity: [0.0, 0.0, 0.0],
          direction: [0.0, 0.0, 0.0],
          up: [0.0, 0.0, 0.0]
        },
        sources: [],
        interval: setInterval(() => AL.scheduleContextAudio(ctx), AL.QUEUE_INTERVAL),
        gain,
        distanceModel: 0xd002 /* AL_INVERSE_DISTANCE_CLAMPED */,
        speedOfSound: 343.3,
        dopplerFactor: 1.0,
        sourceDistanceModel: false,
        hrtf: hrtf || false,
  
        _err: 0,
        get err() {
          return this._err;
        },
        set err(val) {
          // Errors should not be overwritten by later errors until they are cleared by a query.
          if (this._err === 0 || val === 0) {
            this._err = val;
          }
        }
      };
      AL.deviceRefCounts[deviceId]++;
      AL.contexts[ctx.id] = ctx;
  
      if (hrtf !== null) {
        // Apply hrtf attrib to all contexts for this device
        for (var ctxId in AL.contexts) {
          var c = AL.contexts[ctxId];
          if (c.deviceId === deviceId) {
            c.hrtf = hrtf;
            AL.updateContextGlobal(c);
          }
        }
      }
  
      return ctx.id;
    };
  _alcCreateContext.sig = 'ppp';

  var _alcDestroyContext = (contextId) => {
      var ctx = AL.contexts[contextId];
      if (AL.currentCtx === ctx) {
        AL.alcErr = 0xA002 /* ALC_INVALID_CONTEXT */;
        return;
      }
  
      // Stop playback, etc
      if (AL.contexts[contextId].interval) {
        clearInterval(AL.contexts[contextId].interval);
      }
      AL.deviceRefCounts[ctx.deviceId]--;
      delete AL.contexts[contextId];
      AL.freeIds.push(contextId);
    };
  _alcDestroyContext.sig = 'vp';

  var _alcGetContextsDevice = (contextId) => {
      if (contextId in AL.contexts) {
        return AL.contexts[contextId].deviceId;
      }
      return 0;
    };
  _alcGetContextsDevice.sig = 'pp';

  var _alcGetCurrentContext = () => {
      if (AL.currentCtx !== null) {
        return AL.currentCtx.id;
      }
      return 0;
    };
  _alcGetCurrentContext.sig = 'p';

  
  var _alcGetEnumValue = (deviceId, pEnumName) => {
      // Spec says :
      // Using a NULL handle is legal, but only the
      // tokens defined by the AL core are guaranteed.
      if (deviceId !== 0 && !(deviceId in AL.deviceRefCounts)) {
        // ALC_INVALID_DEVICE is not listed as a possible error state for
        // this function, sadly.
        return 0;
      } else if (!pEnumName) {
        AL.alcErr = 40964;
        return 0;
      }
      var name = UTF8ToString(pEnumName);
      // See alGetEnumValue(), but basically behave the same as OpenAL-Soft
      switch (name) {
      case 'ALC_NO_ERROR': return 0;
      case 'ALC_INVALID_DEVICE': return 0xA001;
      case 'ALC_INVALID_CONTEXT': return 0xA002;
      case 'ALC_INVALID_ENUM': return 0xA003;
      case 'ALC_INVALID_VALUE': return 0xA004;
      case 'ALC_OUT_OF_MEMORY': return 0xA005;
      case 'ALC_MAJOR_VERSION': return 0x1000;
      case 'ALC_MINOR_VERSION': return 0x1001;
      case 'ALC_ATTRIBUTES_SIZE': return 0x1002;
      case 'ALC_ALL_ATTRIBUTES': return 0x1003;
      case 'ALC_DEFAULT_DEVICE_SPECIFIER': return 0x1004;
      case 'ALC_DEVICE_SPECIFIER': return 0x1005;
      case 'ALC_EXTENSIONS': return 0x1006;
      case 'ALC_FREQUENCY': return 0x1007;
      case 'ALC_REFRESH': return 0x1008;
      case 'ALC_SYNC': return 0x1009;
      case 'ALC_MONO_SOURCES': return 0x1010;
      case 'ALC_STEREO_SOURCES': return 0x1011;
      case 'ALC_CAPTURE_DEVICE_SPECIFIER': return 0x310;
      case 'ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER': return 0x311;
      case 'ALC_CAPTURE_SAMPLES': return 0x312;
  
      /* Extensions */
      case 'ALC_HRTF_SOFT': return 0x1992;
      case 'ALC_HRTF_ID_SOFT': return 0x1996;
      case 'ALC_DONT_CARE_SOFT': return 0x0002;
      case 'ALC_HRTF_STATUS_SOFT': return 0x1993;
      case 'ALC_NUM_HRTF_SPECIFIERS_SOFT': return 0x1994;
      case 'ALC_HRTF_SPECIFIER_SOFT': return 0x1995;
      case 'ALC_HRTF_DISABLED_SOFT': return 0x0000;
      case 'ALC_HRTF_ENABLED_SOFT': return 0x0001;
      case 'ALC_HRTF_DENIED_SOFT': return 0x0002;
      case 'ALC_HRTF_REQUIRED_SOFT': return 0x0003;
      case 'ALC_HRTF_HEADPHONES_DETECTED_SOFT': return 0x0004;
      case 'ALC_HRTF_UNSUPPORTED_FORMAT_SOFT': return 0x0005;
  
      default:
        AL.alcErr = 40964;
        return 0;
      }
    };
  _alcGetEnumValue.sig = 'ipp';

  var _alcGetError = (deviceId) => {
      var err = AL.alcErr;
      AL.alcErr = 0;
      return err;
    };
  _alcGetError.sig = 'ip';

  var _alcGetIntegerv = (deviceId, param, size, pValues) => {
      if (size === 0 || !pValues) {
        // Ignore the query, per the spec
        return;
      }
  
      switch (param) {
      case 0x1000 /* ALC_MAJOR_VERSION */:
        HEAP32[((pValues)>>2)] = 1;
        break;
      case 0x1001 /* ALC_MINOR_VERSION */:
        HEAP32[((pValues)>>2)] = 1;
        break;
      case 0x1002 /* ALC_ATTRIBUTES_SIZE */:
        if (!(deviceId in AL.deviceRefCounts)) {
          AL.alcErr = 40961;
          return;
        }
        if (!AL.currentCtx) {
          AL.alcErr = 0xA002 /* ALC_INVALID_CONTEXT */;
          return;
        }
  
        HEAP32[((pValues)>>2)] = AL.currentCtx.attrs.length;
        break;
      case 0x1003 /* ALC_ALL_ATTRIBUTES */:
        if (!(deviceId in AL.deviceRefCounts)) {
          AL.alcErr = 40961;
          return;
        }
        if (!AL.currentCtx) {
          AL.alcErr = 0xA002 /* ALC_INVALID_CONTEXT */;
          return;
        }
  
        for (var i = 0; i < AL.currentCtx.attrs.length; i++) {
          HEAP32[(((pValues)+(i*4))>>2)] = AL.currentCtx.attrs[i];
        }
        break;
      case 0x1007 /* ALC_FREQUENCY */:
        if (!(deviceId in AL.deviceRefCounts)) {
          AL.alcErr = 40961;
          return;
        }
        if (!AL.currentCtx) {
          AL.alcErr = 0xA002 /* ALC_INVALID_CONTEXT */;
          return;
        }
  
        HEAP32[((pValues)>>2)] = AL.currentCtx.audioCtx.sampleRate;
        break;
      case 0x1010 /* ALC_MONO_SOURCES */:
      case 0x1011 /* ALC_STEREO_SOURCES */:
        if (!(deviceId in AL.deviceRefCounts)) {
          AL.alcErr = 40961;
          return;
        }
        if (!AL.currentCtx) {
          AL.alcErr = 0xA002 /* ALC_INVALID_CONTEXT */;
          return;
        }
  
        HEAP32[((pValues)>>2)] = 0x7FFFFFFF;
        break;
      case 0x1992 /* ALC_HRTF_SOFT */:
      case 0x1993 /* ALC_HRTF_STATUS_SOFT */:
        if (!(deviceId in AL.deviceRefCounts)) {
          AL.alcErr = 40961;
          return;
        }
  
        var hrtfStatus = 0 /* ALC_HRTF_DISABLED_SOFT */;
        for (var ctxId in AL.contexts) {
          var ctx = AL.contexts[ctxId];
          if (ctx.deviceId === deviceId) {
            hrtfStatus = ctx.hrtf ? 1 /* ALC_HRTF_ENABLED_SOFT */ : 0 /* ALC_HRTF_DISABLED_SOFT */;
          }
        }
        HEAP32[((pValues)>>2)] = hrtfStatus;
        break;
      case 0x1994 /* ALC_NUM_HRTF_SPECIFIERS_SOFT */:
        if (!(deviceId in AL.deviceRefCounts)) {
          AL.alcErr = 40961;
          return;
        }
        HEAP32[((pValues)>>2)] = 1;
        break;
      case 0x20003 /* ALC_MAX_AUXILIARY_SENDS */:
        if (!(deviceId in AL.deviceRefCounts)) {
          AL.alcErr = 40961;
          return;
        }
        if (!AL.currentCtx) {
          AL.alcErr = 0xA002 /* ALC_INVALID_CONTEXT */;
          return;
        }
  
        HEAP32[((pValues)>>2)] = 1;
      case 0x312 /* ALC_CAPTURE_SAMPLES */:
        var c = AL.requireValidCaptureDevice(deviceId, 'alcGetIntegerv');
        if (!c) {
          return;
        }
        var n = c.capturedFrameCount;
        var dstfreq = c.requestedSampleRate;
        var srcfreq = c.audioCtx.sampleRate;
        var nsamples = Math.floor(n * (dstfreq/srcfreq));
        HEAP32[((pValues)>>2)] = nsamples;
        break;
      default:
        AL.alcErr = 40963;
        return;
      }
    };
  _alcGetIntegerv.sig = 'vpiip';

  
  var _alcGetString = (deviceId, param) => {
      if (AL.alcStringCache[param]) {
        return AL.alcStringCache[param];
      }
  
      var ret;
      switch (param) {
      case 0:
        ret = 'No Error';
        break;
      case 40961:
        ret = 'Invalid Device';
        break;
      case 0xA002 /* ALC_INVALID_CONTEXT */:
        ret = 'Invalid Context';
        break;
      case 40963:
        ret = 'Invalid Enum';
        break;
      case 40964:
        ret = 'Invalid Value';
        break;
      case 0xA005 /* ALC_OUT_OF_MEMORY */:
        ret = 'Out of Memory';
        break;
      case 0x1004 /* ALC_DEFAULT_DEVICE_SPECIFIER */:
        if (typeof AudioContext != 'undefined' ||
            typeof webkitAudioContext != 'undefined') {
          ret = AL.DEVICE_NAME;
        } else {
          return 0;
        }
        break;
      case 0x1005 /* ALC_DEVICE_SPECIFIER */:
        if (typeof AudioContext != 'undefined' ||
            typeof webkitAudioContext != 'undefined') {
          ret = AL.DEVICE_NAME + '\0';
        } else {
          ret = '\0';
        }
        break;
      case 0x311 /* ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER */:
        ret = AL.CAPTURE_DEVICE_NAME;
        break;
      case 0x310 /* ALC_CAPTURE_DEVICE_SPECIFIER */:
        if (deviceId === 0) {
          ret = AL.CAPTURE_DEVICE_NAME + '\0';
        } else {
          var c = AL.requireValidCaptureDevice(deviceId, 'alcGetString');
          if (!c) {
            return 0;
          }
          ret = c.deviceName;
        }
        break;
      case 0x1006 /* ALC_EXTENSIONS */:
        if (!deviceId) {
          AL.alcErr = 40961;
          return 0;
        }
  
        ret = Object.keys(AL.ALC_EXTENSIONS).join(' ')
        break;
      default:
        AL.alcErr = 40963;
        return 0;
      }
  
      ret = stringToNewUTF8(ret);
      AL.alcStringCache[param] = ret;
      return ret;
    };
  _alcGetString.sig = 'ppi';

  
  var _alcIsExtensionPresent = (deviceId, pExtName) => {
      var name = UTF8ToString(pExtName);
  
      return AL.ALC_EXTENSIONS[name] ? 1 : 0;
    };
  _alcIsExtensionPresent.sig = 'ipp';

  var _alcMakeContextCurrent = (contextId) => {
      if (contextId === 0) {
        AL.currentCtx = null;
      } else {
        AL.currentCtx = AL.contexts[contextId];
      }
      return 1;
    };
  _alcMakeContextCurrent.sig = 'ip';

  
  var _alcOpenDevice = (pDeviceName) => {
      if (pDeviceName) {
        var name = UTF8ToString(pDeviceName);
        if (name !== AL.DEVICE_NAME) {
          return 0;
        }
      }
  
      if (typeof AudioContext != 'undefined' || typeof webkitAudioContext != 'undefined') {
        var deviceId = AL.newId();
        AL.deviceRefCounts[deviceId] = 0;
        return deviceId;
      }
      return 0;
    };
  _alcOpenDevice.sig = 'pp';

  var _alcProcessContext = (contextId) => {};
  _alcProcessContext.sig = 'vp';

  var _alcSuspendContext = (contextId) => {};
  _alcSuspendContext.sig = 'vp';

  
  var _emscripten_get_now_res = () => { // return resolution of get_now, in nanoseconds
      // Modern environment where performance.now() is supported:
      return 1000; // microseconds (1/1000 of a millisecond)
    };
  _emscripten_get_now_res.sig = 'd';
  
  var nowIsMonotonic = 1;
  
  var checkWasiClock = (clock_id) => clock_id >= 0 && clock_id <= 3;
  var _clock_res_get = (clk_id, pres) => {
      if (!checkWasiClock(clk_id)) {
        return 28;
      }
      var nsec;
      // all wasi clocks but realtime are monotonic
      if (clk_id === 0) {
        nsec = 1000 * 1000; // educated guess that it's milliseconds
      } else if (nowIsMonotonic) {
        nsec = _emscripten_get_now_res();
      } else {
        return 52;
      }
      HEAP64[((pres)>>3)] = BigInt(nsec);
      return 0;
    };
  _clock_res_get.sig = 'iip';

  
  var _emscripten_date_now = () => Date.now();
  _emscripten_date_now.sig = 'd';
  
  
  
  function _clock_time_get(clk_id, ignored_precision, ptime) {
    ignored_precision = bigintToI53Checked(ignored_precision);
  
    
      if (!checkWasiClock(clk_id)) {
        return 28;
      }
      var now;
      // all wasi clocks but realtime are monotonic
      if (clk_id === 0) {
        now = _emscripten_date_now();
      } else if (nowIsMonotonic) {
        now = _emscripten_get_now();
      } else {
        return 52;
      }
      // "now" is in ms, and wasi times are in ns.
      var nsec = Math.round(now * 1000 * 1000);
      HEAP64[((ptime)>>3)] = BigInt(nsec);
      return 0;
    ;
  }
  _clock_time_get.sig = 'iijp';

  
  var EGL = {
  errorCode:12288,
  defaultDisplayInitialized:false,
  currentContext:0,
  currentReadSurface:0,
  currentDrawSurface:0,
  contextAttributes:{
  alpha:false,
  depth:false,
  stencil:false,
  antialias:false,
  },
  stringCache:{
  },
  setErrorCode(code) {
        EGL.errorCode = code;
      },
  chooseConfig(display, attribList, config, config_size, numConfigs) {
        if (display != 62000) {
          EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
          return 0;
        }
  
        if (attribList) {
          // read attribList if it is non-null
          for (;;) {
            var param = HEAP32[((attribList)>>2)];
            if (param == 0x3021 /*EGL_ALPHA_SIZE*/) {
              var alphaSize = HEAP32[(((attribList)+(4))>>2)];
              EGL.contextAttributes.alpha = (alphaSize > 0);
            } else if (param == 0x3025 /*EGL_DEPTH_SIZE*/) {
              var depthSize = HEAP32[(((attribList)+(4))>>2)];
              EGL.contextAttributes.depth = (depthSize > 0);
            } else if (param == 0x3026 /*EGL_STENCIL_SIZE*/) {
              var stencilSize = HEAP32[(((attribList)+(4))>>2)];
              EGL.contextAttributes.stencil = (stencilSize > 0);
            } else if (param == 0x3031 /*EGL_SAMPLES*/) {
              var samples = HEAP32[(((attribList)+(4))>>2)];
              EGL.contextAttributes.antialias = (samples > 0);
            } else if (param == 0x3032 /*EGL_SAMPLE_BUFFERS*/) {
              var samples = HEAP32[(((attribList)+(4))>>2)];
              EGL.contextAttributes.antialias = (samples == 1);
            } else if (param == 0x3100 /*EGL_CONTEXT_PRIORITY_LEVEL_IMG*/) {
              var requestedPriority = HEAP32[(((attribList)+(4))>>2)];
              EGL.contextAttributes.lowLatency = (requestedPriority != 0x3103 /*EGL_CONTEXT_PRIORITY_LOW_IMG*/);
            } else if (param == 0x3038 /*EGL_NONE*/) {
                break;
            }
            attribList += 8;
          }
        }
  
        if ((!config || !config_size) && !numConfigs) {
          EGL.setErrorCode(0x300C /* EGL_BAD_PARAMETER */);
          return 0;
        }
        if (numConfigs) {
          HEAP32[((numConfigs)>>2)] = 1; // Total number of supported configs: 1.
        }
        if (config && config_size > 0) {
          HEAPU32[((config)>>2)] = 62002;
        }
  
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
        return 1;
      },
  };
  var _eglChooseConfig = (display, attrib_list, configs, config_size, numConfigs) =>
      EGL.chooseConfig(display, attrib_list, configs, config_size, numConfigs);
  _eglChooseConfig.sig = 'ipppip';

  var _eglGetCurrentDisplay = () => EGL.currentContext ? 62000 : 0;
  _eglGetCurrentDisplay.sig = 'p';

  var _eglGetDisplay = (nativeDisplayType) => {
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      // Emscripten EGL implementation "emulates" X11, and eglGetDisplay is
      // expected to accept/receive a pointer to an X11 Display object (or
      // EGL_DEFAULT_DISPLAY).
      if (nativeDisplayType != 0 /* EGL_DEFAULT_DISPLAY */ && nativeDisplayType != 1 /* see library_xlib.js */) {
        return 0; // EGL_NO_DISPLAY
      }
      return 62000;
    };
  _eglGetDisplay.sig = 'pp';

  var _emscripten_alcDevicePauseSOFT = (deviceId) => {
      if (!(deviceId in AL.deviceRefCounts)) {
        AL.alcErr = 40961;
        return;
      }
  
      if (AL.paused) {
        return;
      }
      AL.paused = true;
  
      for (var ctxId in AL.contexts) {
        var ctx = AL.contexts[ctxId];
        if (ctx.deviceId !== deviceId) {
          continue;
        }
  
        ctx.audioCtx.suspend();
        clearInterval(ctx.interval);
        ctx.interval = null;
      }
    };
  _emscripten_alcDevicePauseSOFT.sig = 'vi';

  var _emscripten_alcDeviceResumeSOFT = (deviceId) => {
      if (!(deviceId in AL.deviceRefCounts)) {
        AL.alcErr = 40961;
        return;
      }
  
      if (!AL.paused) {
        return;
      }
      AL.paused = false;
  
      for (var ctxId in AL.contexts) {
        var ctx = AL.contexts[ctxId];
        if (ctx.deviceId !== deviceId) {
          continue;
        }
  
        ctx.interval = setInterval(() => AL.scheduleContextAudio(ctx), AL.QUEUE_INTERVAL);
        ctx.audioCtx.resume();
      }
    };
  _emscripten_alcDeviceResumeSOFT.sig = 'vi';

  
  
  var _emscripten_alcGetStringiSOFT = (deviceId, param, index) => {
      if (!(deviceId in AL.deviceRefCounts)) {
        AL.alcErr = 40961;
        return 0;
      }
  
      if (AL.alcStringCache[param]) {
        return AL.alcStringCache[param];
      }
  
      var ret;
      switch (param) {
      case 0x1995 /* ALC_HRTF_SPECIFIER_SOFT */:
        if (index === 0) {
          ret = 'Web Audio HRTF';
        } else {
          AL.alcErr = 40964;
          return 0;
        }
        break;
      default:
        if (index !== 0) {
          AL.alcErr = 40963;
          return 0;
        }
        return _alcGetString(deviceId, param);
      }
  
      ret = stringToNewUTF8(ret);
      AL.alcStringCache[param] = ret;
      return ret;
    };
  _emscripten_alcGetStringiSOFT.sig = 'iiii';

  var _emscripten_alcResetDeviceSOFT = (deviceId, pAttrList) => {
      if (!(deviceId in AL.deviceRefCounts)) {
        AL.alcErr = 40961;
        return 0;
      }
  
      var hrtf = null;
      pAttrList >>= 2;
      if (pAttrList) {
        var attr = 0;
        var val = 0;
        while (true) {
          attr = HEAP32[pAttrList++];
          if (attr === 0) {
            break;
          }
          val = HEAP32[pAttrList++];
  
          switch (attr) {
          case 0x1992 /* ALC_HRTF_SOFT */:
            if (val === 1) {
              hrtf = true;
            } else if (val === 0) {
              hrtf = false;
            }
            break;
          }
        }
      }
  
      if (hrtf !== null) {
        // Apply hrtf attrib to all contexts for this device
        for (var ctxId in AL.contexts) {
          var ctx = AL.contexts[ctxId];
          if (ctx.deviceId === deviceId) {
            ctx.hrtf = hrtf;
            AL.updateContextGlobal(ctx);
          }
        }
      }
  
      return 1;
    };
  _emscripten_alcResetDeviceSOFT.sig = 'iii';

  var readEmAsmArgsArray = [];
  var readEmAsmArgs = (sigPtr, buf) => {
      readEmAsmArgsArray.length = 0;
      var ch;
      // Most arguments are i32s, so shift the buffer pointer so it is a plain
      // index into HEAP32.
      while (ch = HEAPU8[sigPtr++]) {
        // Floats are always passed as doubles, so all types except for 'i'
        // are 8 bytes and require alignment.
        var wide = (ch != 105);
        wide &= (ch != 112);
        buf += wide && (buf % 8) ? 4 : 0;
        readEmAsmArgsArray.push(
          // Special case for pointers under wasm64 or CAN_ADDRESS_2GB mode.
          ch == 112 ? HEAPU32[((buf)>>2)] :
          ch == 106 ? HEAP64[((buf)>>3)] :
          ch == 105 ?
            HEAP32[((buf)>>2)] :
            HEAPF64[((buf)>>3)]
        );
        buf += wide ? 8 : 4;
      }
      return readEmAsmArgsArray;
    };
  var runEmAsmFunction = (code, sigPtr, argbuf) => {
      var args = readEmAsmArgs(sigPtr, argbuf);
      return ASM_CONSTS[code](...args);
    };
  var _emscripten_asm_const_int = (code, sigPtr, argbuf) => {
      return runEmAsmFunction(code, sigPtr, argbuf);
    };
  _emscripten_asm_const_int.sig = 'ippp';

  
  var safeRequestAnimationFrame = (func) => {
      
      return MainLoop.requestAnimationFrame(() => {
        
        callUserCallback(func);
      });
    };
  
  var _emscripten_async_call = (func, arg, millis) => {
      var wrapper = () => getWasmTableEntry(func)(arg);
  
      if (millis >= 0
      ) {
        safeSetTimeout(wrapper, millis);
      } else {
        safeRequestAnimationFrame(wrapper);
      }
    };
  _emscripten_async_call.sig = 'vppi';

  var _emscripten_run_script = (ptr) => {
      eval(UTF8ToString(ptr));
    };
  _emscripten_run_script.sig = 'vp';
  
  
  var _emscripten_async_run_script = (script, millis) => {
      // TODO: cache these to avoid generating garbage
      safeSetTimeout(() => _emscripten_run_script(script), millis);
    };
  _emscripten_async_run_script.sig = 'vpi';

  
  var wget = {
  wgetRequests:{
  },
  nextWgetRequestHandle:0,
  getNextWgetRequestHandle() {
        var handle = wget.nextWgetRequestHandle;
        wget.nextWgetRequestHandle++;
        return handle;
      },
  };
  
  
  
  
  var _emscripten_async_wget2 = (url, file, request, param, userdata, onload, onerror, onprogress) => {
      
  
      var _url = UTF8ToString(url);
      var _file = UTF8ToString(file);
      _file = PATH_FS.resolve(_file);
      var _request = UTF8ToString(request);
      var _param = UTF8ToString(param);
      var index = _file.lastIndexOf('/');
  
      var http = new XMLHttpRequest();
      http.open(_request, _url, true);
      http.responseType = 'arraybuffer';
  
      var handle = wget.getNextWgetRequestHandle();
  
      var destinationDirectory = PATH.dirname(_file);
  
      // LOAD
      http.onload = (e) => {
        
        if (http.status >= 200 && http.status < 300) {
          // if a file exists there, we overwrite it
          try {
            FS.unlink(_file);
          } catch (e) {}
          // if the destination directory does not yet exist, create it
          FS.mkdirTree(destinationDirectory);
  
          FS.createDataFile( _file.substr(0, index), _file.substr(index + 1), new Uint8Array(/** @type{ArrayBuffer}*/(http.response)), true, true, false);
          if (onload) {
            var sp = stackSave();
            getWasmTableEntry(onload)(handle, userdata, stringToUTF8OnStack(_file));
            stackRestore(sp);
          }
        } else {
          if (onerror) getWasmTableEntry(onerror)(handle, userdata, http.status);
        }
  
        delete wget.wgetRequests[handle];
      };
  
      // ERROR
      http.onerror = (e) => {
        
        if (onerror) getWasmTableEntry(onerror)(handle, userdata, http.status);
        delete wget.wgetRequests[handle];
      };
  
      // PROGRESS
      http.onprogress = (e) => {
        if (e.lengthComputable || (e.lengthComputable === undefined && e.total != 0)) {
          var percentComplete = (e.loaded / e.total)*100;
          if (onprogress) getWasmTableEntry(onprogress)(handle, userdata, percentComplete);
        }
      };
  
      // ABORT
      http.onabort = (e) => {
        
        delete wget.wgetRequests[handle];
      };
  
      if (_request == "POST") {
        //Send the proper header information along with the request
        http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        http.send(_param);
      } else {
        http.send(null);
      }
  
      wget.wgetRequests[handle] = http;
  
      return handle;
    };
  _emscripten_async_wget2.sig = 'ipppppppp';

  var _emscripten_async_wget2_abort = (handle) => {
      var http = wget.wgetRequests[handle];
      http?.abort();
    };
  _emscripten_async_wget2_abort.sig = 'vi';

  
  
  
  
  var _emscripten_async_wget2_data = (url, request, param, userdata, free, onload, onerror, onprogress) => {
      var _url = UTF8ToString(url);
      var _request = UTF8ToString(request);
      var _param = UTF8ToString(param);
  
      var http = new XMLHttpRequest();
      http.open(_request, _url, true);
      http.responseType = 'arraybuffer';
  
      var handle = wget.getNextWgetRequestHandle();
  
      function onerrorjs() {
        if (onerror) {
          var sp = stackSave();
          var statusText = 0;
          if (http.statusText) {
            statusText = stringToUTF8OnStack(http.statusText);
          }
          getWasmTableEntry(onerror)(handle, userdata, http.status, statusText);
          stackRestore(sp);
        }
      }
  
      // LOAD
      http.onload = (e) => {
        if (http.status >= 200 && http.status < 300 || (http.status === 0 && _url.substr(0,4).toLowerCase() != "http")) {
          var byteArray = new Uint8Array(/** @type{ArrayBuffer} */(http.response));
          var buffer = _malloc(byteArray.length);
          HEAPU8.set(byteArray, buffer);
          if (onload) getWasmTableEntry(onload)(handle, userdata, buffer, byteArray.length);
          if (free) _free(buffer);
        } else {
          onerrorjs();
        }
        delete wget.wgetRequests[handle];
      };
  
      // ERROR
      http.onerror = (e) => {
        onerrorjs();
        delete wget.wgetRequests[handle];
      };
  
      // PROGRESS
      http.onprogress = (e) => {
        if (onprogress) getWasmTableEntry(onprogress)(handle, userdata, e.loaded, e.lengthComputable || e.lengthComputable === undefined ? e.total : 0);
      };
  
      // ABORT
      http.onabort = (e) => {
        delete wget.wgetRequests[handle];
      };
  
      if (_request == "POST") {
        //Send the proper header information along with the request
        http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        http.send(_param);
      } else {
        http.send(null);
      }
  
      wget.wgetRequests[handle] = http;
  
      return handle;
    };
  _emscripten_async_wget2_data.sig = 'ippppippp';

  var _emscripten_cancel_main_loop = () => {
      MainLoop.pause();
      MainLoop.func = null;
    };
  _emscripten_cancel_main_loop.sig = 'v';

  var _emscripten_console_error = (str) => {
      console.error(UTF8ToString(str));
    };
  _emscripten_console_error.sig = 'vp';

  var _emscripten_console_log = (str) => {
      console.log(UTF8ToString(str));
    };
  _emscripten_console_log.sig = 'vp';

  var _emscripten_console_trace = (str) => {
      console.trace(UTF8ToString(str));
    };
  _emscripten_console_trace.sig = 'vp';

  var _emscripten_console_warn = (str) => {
      console.warn(UTF8ToString(str));
    };
  _emscripten_console_warn.sig = 'vp';

  
  
  
  
  var _emscripten_create_worker = (url) => {
      url = UTF8ToString(url);
      var id = Browser.workers.length;
      var info = {
        worker: new Worker(url),
        callbacks: [],
        awaited: 0,
        buffer: 0,
        bufferSize: 0
      };
      info.worker.onmessage = function info_worker_onmessage(msg) {
        if (ABORT) return;
        var info = Browser.workers[id];
        if (!info) return; // worker was destroyed meanwhile
        var callbackId = msg.data['callbackId'];
        var callbackInfo = info.callbacks[callbackId];
        if (!callbackInfo) return; // no callback or callback removed meanwhile
        // Don't trash our callback state if we expect additional calls.
        if (msg.data['finalResponse']) {
          info.awaited--;
          info.callbacks[callbackId] = null; // TODO: reuse callbackIds, compress this
          
        }
        var data = msg.data['data'];
        if (data) {
          if (!data.byteLength) data = new Uint8Array(data);
          if (!info.buffer || info.bufferSize < data.length) {
            if (info.buffer) _free(info.buffer);
            info.bufferSize = data.length;
            info.buffer = _malloc(data.length);
          }
          HEAPU8.set(data, info.buffer);
          callbackInfo.func(info.buffer, data.length, callbackInfo.arg);
        } else {
          callbackInfo.func(0, 0, callbackInfo.arg);
        }
      };
      Browser.workers.push(info);
      return id;
    };
  _emscripten_create_worker.sig = 'ip';


  var _emscripten_debugger = () => { debugger };
  _emscripten_debugger.sig = 'v';

  
  var _emscripten_destroy_worker = (id) => {
      var info = Browser.workers[id];
      info.worker.terminate();
      if (info.buffer) _free(info.buffer);
      Browser.workers[id] = null;
    };
  _emscripten_destroy_worker.sig = 'vi';

  var _emscripten_err = (str) => err(UTF8ToString(str));
  _emscripten_err.sig = 'vp';

  var _emscripten_exit_with_live_runtime = () => {
      
      throw 'unwind';
    };
  _emscripten_exit_with_live_runtime.sig = 'v';

  
  var _emscripten_force_exit = (status) => {
      __emscripten_runtime_keepalive_clear();
      _exit(status);
    };
  _emscripten_force_exit.sig = 'vi';

  var jsStackTrace = () => new Error().stack.toString();
  
  /** @param {number=} flags */
  var getCallstack = (flags) => {
      var callstack = jsStackTrace();
  
      // Find the symbols in the callstack that corresponds to the functions that
      // report callstack information, and remove everything up to these from the
      // output.
      var iThisFunc = callstack.lastIndexOf('_emscripten_log');
      var iThisFunc2 = callstack.lastIndexOf('_emscripten_get_callstack');
      var iNextLine = callstack.indexOf('\n', Math.max(iThisFunc, iThisFunc2))+1;
      callstack = callstack.slice(iNextLine);
  
      // If user requested to see the original source stack, but no source map
      // information is available, just fall back to showing the JS stack.
      if (flags & 8 && typeof emscripten_source_map == 'undefined') {
        warnOnce('Source map information is not available, emscripten_log with EM_LOG_C_STACK will be ignored. Build with "--pre-js $EMSCRIPTEN/src/emscripten-source-map.min.js" linker flag to add source map loading to code.');
        flags ^= 8;
        flags |= 16;
      }
  
      // Process all lines:
      var lines = callstack.split('\n');
      callstack = '';
      // New FF30 with column info: extract components of form:
      // '       Object._main@http://server.com:4324:12'
      var newFirefoxRe = new RegExp('\\s*(.*?)@(.*?):([0-9]+):([0-9]+)');
      // Old FF without column info: extract components of form:
      // '       Object._main@http://server.com:4324'
      var firefoxRe = new RegExp('\\s*(.*?)@(.*):(.*)(:(.*))?');
      // Extract components of form:
      // '    at Object._main (http://server.com/file.html:4324:12)'
      var chromeRe = new RegExp('\\s*at (.*?) \\\((.*):(.*):(.*)\\\)');
  
      for (var l in lines) {
        var line = lines[l];
  
        var symbolName = '';
        var file = '';
        var lineno = 0;
        var column = 0;
  
        var parts = chromeRe.exec(line);
        if (parts && parts.length == 5) {
          symbolName = parts[1];
          file = parts[2];
          lineno = parts[3];
          column = parts[4];
        } else {
          parts = newFirefoxRe.exec(line) || firefoxRe.exec(line);
          if (parts && parts.length >= 4) {
            symbolName = parts[1];
            file = parts[2];
            lineno = parts[3];
            // Old Firefox doesn't carry column information, but in new FF30, it
            // is present. See https://bugzilla.mozilla.org/show_bug.cgi?id=762556
            column = parts[4]|0;
          } else {
            // Was not able to extract this line for demangling/sourcemapping
            // purposes. Output it as-is.
            callstack += line + '\n';
            continue;
          }
        }
  
        var haveSourceMap = false;
  
        if (flags & 8) {
          var orig = emscripten_source_map.originalPositionFor({line: lineno, column: column});
          haveSourceMap = orig?.source;
          if (haveSourceMap) {
            if (flags & 64) {
              orig.source = orig.source.substring(orig.source.replace(/\\/g, "/").lastIndexOf('/')+1);
            }
            callstack += `    at ${symbolName} (${orig.source}:${orig.line}:${orig.column})\n`;
          }
        }
        if ((flags & 16) || !haveSourceMap) {
          if (flags & 64) {
            file = file.substring(file.replace(/\\/g, "/").lastIndexOf('/')+1);
          }
          callstack += (haveSourceMap ? (`     = ${symbolName}`) : (`    at ${symbolName}`)) + ` (${file}:${lineno}:${column})\n`;
        }
      }
      // Trim extra whitespace at the end of the output.
      callstack = callstack.replace(/\s+$/, '');
      return callstack;
    };
  
  
  var _emscripten_get_callstack = (flags, str, maxbytes) => {
      var callstack = getCallstack(flags);
      // User can query the required amount of bytes to hold the callstack.
      if (!str || maxbytes <= 0) {
        return lengthBytesUTF8(callstack)+1;
      }
      // Output callstack string as C string to HEAP.
      var bytesWrittenExcludingNull = stringToUTF8(callstack, str, maxbytes);
  
      // Return number of bytes written, including null.
      return bytesWrittenExcludingNull+1;
    };
  _emscripten_get_callstack.sig = 'iipi';

  var _emscripten_get_compiler_setting = (name) => {
      throw 'You must build with -sRETAIN_COMPILER_SETTINGS for getCompilerSetting or emscripten_get_compiler_setting to work';
    };
  _emscripten_get_compiler_setting.sig = 'pp';

  var _emscripten_get_device_pixel_ratio = () => {
      return devicePixelRatio;
    };
  _emscripten_get_device_pixel_ratio.sig = 'd';

  var getHeapMax = () =>
      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
      // for any code that deals with heap sizes, which would require special
      // casing all heap size related code to treat 0 specially.
      2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  _emscripten_get_heap_max.sig = 'p';


  var _emscripten_get_screen_size = (width, height) => {
      HEAP32[((width)>>2)] = screen.width;
      HEAP32[((height)>>2)] = screen.height;
    };
  _emscripten_get_screen_size.sig = 'vpp';

  var _emscripten_get_window_title = () => {
      var buflen = 256;
  
      if (!_emscripten_get_window_title.buffer) {
        _emscripten_get_window_title.buffer = _malloc(buflen);
      }
  
      stringToUTF8(document.title, _emscripten_get_window_title.buffer, buflen);
  
      return _emscripten_get_window_title.buffer;
    };
  _emscripten_get_window_title.sig = 'p';

  var _emscripten_get_worker_queue_size = (id) => {
      var info = Browser.workers[id];
      if (!info) return -1;
      return info.awaited;
    };
  _emscripten_get_worker_queue_size.sig = 'ii';

  var GLctx;
  
  var webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance = (ctx) =>
      // Closure is expected to be allowed to minify the '.dibvbi' property, so not accessing it quoted.
      !!(ctx.dibvbi = ctx.getExtension('WEBGL_draw_instanced_base_vertex_base_instance'));
  
  var webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance = (ctx) => {
      // Closure is expected to be allowed to minify the '.mdibvbi' property, so not accessing it quoted.
      return !!(ctx.mdibvbi = ctx.getExtension('WEBGL_multi_draw_instanced_base_vertex_base_instance'));
    };
  
  var webgl_enable_EXT_polygon_offset_clamp = (ctx) =>
      !!(ctx.extPolygonOffsetClamp = ctx.getExtension('EXT_polygon_offset_clamp'));
  
  var webgl_enable_EXT_clip_control = (ctx) =>
      !!(ctx.extClipControl = ctx.getExtension('EXT_clip_control'));
  
  var webgl_enable_WEBGL_polygon_mode = (ctx) =>
      !!(ctx.webglPolygonMode = ctx.getExtension('WEBGL_polygon_mode'));
  
  var webgl_enable_WEBGL_multi_draw = (ctx) =>
      // Closure is expected to be allowed to minify the '.multiDrawWebgl' property, so not accessing it quoted.
      !!(ctx.multiDrawWebgl = ctx.getExtension('WEBGL_multi_draw'));
  
  var getEmscriptenSupportedExtensions = (ctx) => {
      // Restrict the list of advertised extensions to those that we actually
      // support.
      var supportedExtensions = [
        // WebGL 2 extensions
        'EXT_color_buffer_float',
        'EXT_conservative_depth',
        'EXT_disjoint_timer_query_webgl2',
        'EXT_texture_norm16',
        'NV_shader_noperspective_interpolation',
        'WEBGL_clip_cull_distance',
        // WebGL 1 and WebGL 2 extensions
        'EXT_clip_control',
        'EXT_color_buffer_half_float',
        'EXT_depth_clamp',
        'EXT_float_blend',
        'EXT_polygon_offset_clamp',
        'EXT_texture_compression_bptc',
        'EXT_texture_compression_rgtc',
        'EXT_texture_filter_anisotropic',
        'KHR_parallel_shader_compile',
        'OES_texture_float_linear',
        'WEBGL_blend_func_extended',
        'WEBGL_compressed_texture_astc',
        'WEBGL_compressed_texture_etc',
        'WEBGL_compressed_texture_etc1',
        'WEBGL_compressed_texture_s3tc',
        'WEBGL_compressed_texture_s3tc_srgb',
        'WEBGL_debug_renderer_info',
        'WEBGL_debug_shaders',
        'WEBGL_lose_context',
        'WEBGL_multi_draw',
        'WEBGL_polygon_mode'
      ];
      // .getSupportedExtensions() can return null if context is lost, so coerce to empty array.
      return (ctx.getSupportedExtensions() || []).filter(ext => supportedExtensions.includes(ext));
    };
  
  var registerPreMainLoop = (f) => {
      // Does nothing unless $MainLoop is included/used.
      typeof MainLoop != 'undefined' && MainLoop.preMainLoop.push(f);
    };
  
  
  var GL = {
  counter:1,
  buffers:[],
  mappedBuffers:{
  },
  programs:[],
  framebuffers:[],
  renderbuffers:[],
  textures:[],
  shaders:[],
  vaos:[],
  contexts:[],
  offscreenCanvases:{
  },
  queries:[],
  samplers:[],
  transformFeedbacks:[],
  syncs:[],
  byteSizeByTypeRoot:5120,
  byteSizeByType:[1,1,2,2,4,4,4,2,3,4,8],
  stringCache:{
  },
  stringiCache:{
  },
  unpackAlignment:4,
  unpackRowLength:0,
  recordError:(errorCode) => {
        if (!GL.lastError) {
          GL.lastError = errorCode;
        }
      },
  getNewId:(table) => {
        var ret = GL.counter++;
        for (var i = table.length; i < ret; i++) {
          table[i] = null;
        }
        return ret;
      },
  genObject:(n, buffers, createFunction, objectTable
        ) => {
        for (var i = 0; i < n; i++) {
          var buffer = GLctx[createFunction]();
          var id = buffer && GL.getNewId(objectTable);
          if (buffer) {
            buffer.name = id;
            objectTable[id] = buffer;
          } else {
            GL.recordError(0x502 /* GL_INVALID_OPERATION */);
          }
          HEAP32[(((buffers)+(i*4))>>2)] = id;
        }
      },
  MAX_TEMP_BUFFER_SIZE:2097152,
  numTempVertexBuffersPerSize:64,
  log2ceilLookup:(i) => 32 - Math.clz32(i === 0 ? 0 : i - 1),
  generateTempBuffers:(quads, context) => {
        var largestIndex = GL.log2ceilLookup(GL.MAX_TEMP_BUFFER_SIZE);
        context.tempVertexBufferCounters1 = [];
        context.tempVertexBufferCounters2 = [];
        context.tempVertexBufferCounters1.length = context.tempVertexBufferCounters2.length = largestIndex+1;
        context.tempVertexBuffers1 = [];
        context.tempVertexBuffers2 = [];
        context.tempVertexBuffers1.length = context.tempVertexBuffers2.length = largestIndex+1;
        context.tempIndexBuffers = [];
        context.tempIndexBuffers.length = largestIndex+1;
        for (var i = 0; i <= largestIndex; ++i) {
          context.tempIndexBuffers[i] = null; // Created on-demand
          context.tempVertexBufferCounters1[i] = context.tempVertexBufferCounters2[i] = 0;
          var ringbufferLength = GL.numTempVertexBuffersPerSize;
          context.tempVertexBuffers1[i] = [];
          context.tempVertexBuffers2[i] = [];
          var ringbuffer1 = context.tempVertexBuffers1[i];
          var ringbuffer2 = context.tempVertexBuffers2[i];
          ringbuffer1.length = ringbuffer2.length = ringbufferLength;
          for (var j = 0; j < ringbufferLength; ++j) {
            ringbuffer1[j] = ringbuffer2[j] = null; // Created on-demand
          }
        }
  
        if (quads) {
          // GL_QUAD indexes can be precalculated
          context.tempQuadIndexBuffer = GLctx.createBuffer();
          context.GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, context.tempQuadIndexBuffer);
          var numIndexes = GL.MAX_TEMP_BUFFER_SIZE >> 1;
          var quadIndexes = new Uint16Array(numIndexes);
          var i = 0, v = 0;
          while (1) {
            quadIndexes[i++] = v;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v+1;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v+2;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v+2;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v+3;
            if (i >= numIndexes) break;
            v += 4;
          }
          context.GLctx.bufferData(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, quadIndexes, 0x88E4 /*GL_STATIC_DRAW*/);
          context.GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, null);
        }
      },
  getTempVertexBuffer:(sizeBytes) => {
        var idx = GL.log2ceilLookup(sizeBytes);
        var ringbuffer = GL.currentContext.tempVertexBuffers1[idx];
        var nextFreeBufferIndex = GL.currentContext.tempVertexBufferCounters1[idx];
        GL.currentContext.tempVertexBufferCounters1[idx] = (GL.currentContext.tempVertexBufferCounters1[idx]+1) & (GL.numTempVertexBuffersPerSize-1);
        var vbo = ringbuffer[nextFreeBufferIndex];
        if (vbo) {
          return vbo;
        }
        var prevVBO = GLctx.getParameter(0x8894 /*GL_ARRAY_BUFFER_BINDING*/);
        ringbuffer[nextFreeBufferIndex] = GLctx.createBuffer();
        GLctx.bindBuffer(0x8892 /*GL_ARRAY_BUFFER*/, ringbuffer[nextFreeBufferIndex]);
        GLctx.bufferData(0x8892 /*GL_ARRAY_BUFFER*/, 1 << idx, 0x88E8 /*GL_DYNAMIC_DRAW*/);
        GLctx.bindBuffer(0x8892 /*GL_ARRAY_BUFFER*/, prevVBO);
        return ringbuffer[nextFreeBufferIndex];
      },
  getTempIndexBuffer:(sizeBytes) => {
        var idx = GL.log2ceilLookup(sizeBytes);
        var ibo = GL.currentContext.tempIndexBuffers[idx];
        if (ibo) {
          return ibo;
        }
        var prevIBO = GLctx.getParameter(0x8895 /*ELEMENT_ARRAY_BUFFER_BINDING*/);
        GL.currentContext.tempIndexBuffers[idx] = GLctx.createBuffer();
        GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, GL.currentContext.tempIndexBuffers[idx]);
        GLctx.bufferData(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, 1 << idx, 0x88E8 /*GL_DYNAMIC_DRAW*/);
        GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, prevIBO);
        return GL.currentContext.tempIndexBuffers[idx];
      },
  newRenderingFrameStarted:() => {
        if (!GL.currentContext) {
          return;
        }
        var vb = GL.currentContext.tempVertexBuffers1;
        GL.currentContext.tempVertexBuffers1 = GL.currentContext.tempVertexBuffers2;
        GL.currentContext.tempVertexBuffers2 = vb;
        vb = GL.currentContext.tempVertexBufferCounters1;
        GL.currentContext.tempVertexBufferCounters1 = GL.currentContext.tempVertexBufferCounters2;
        GL.currentContext.tempVertexBufferCounters2 = vb;
        var largestIndex = GL.log2ceilLookup(GL.MAX_TEMP_BUFFER_SIZE);
        for (var i = 0; i <= largestIndex; ++i) {
          GL.currentContext.tempVertexBufferCounters1[i] = 0;
        }
      },
  getSource:(shader, count, string, length) => {
        var source = '';
        for (var i = 0; i < count; ++i) {
          var len = length ? HEAPU32[(((length)+(i*4))>>2)] : undefined;
          source += UTF8ToString(HEAPU32[(((string)+(i*4))>>2)], len);
        }
        return source;
      },
  calcBufLength:(size, type, stride, count) => {
        if (stride > 0) {
          return count * stride;  // XXXvlad this is not exactly correct I don't think
        }
        var typeSize = GL.byteSizeByType[type - GL.byteSizeByTypeRoot];
        return size * typeSize * count;
      },
  usedTempBuffers:[],
  preDrawHandleClientVertexAttribBindings:(count) => {
        GL.resetBufferBinding = false;
  
        // TODO: initial pass to detect ranges we need to upload, might not need
        // an upload per attrib
        for (var i = 0; i < GL.currentContext.maxVertexAttribs; ++i) {
          var cb = GL.currentContext.clientBuffers[i];
          if (!cb.clientside || !cb.enabled) continue;
  
          GL.resetBufferBinding = true;
  
          var size = GL.calcBufLength(cb.size, cb.type, cb.stride, count);
          var buf = GL.getTempVertexBuffer(size);
          GLctx.bindBuffer(0x8892 /*GL_ARRAY_BUFFER*/, buf);
          GLctx.bufferSubData(0x8892 /*GL_ARRAY_BUFFER*/,
                                   0,
                                   HEAPU8.subarray(cb.ptr, cb.ptr + size));
          cb.vertexAttribPointerAdaptor.call(GLctx, i, cb.size, cb.type, cb.normalized, cb.stride, 0);
        }
      },
  postDrawHandleClientVertexAttribBindings:() => {
        if (GL.resetBufferBinding) {
          GLctx.bindBuffer(0x8892 /*GL_ARRAY_BUFFER*/, GL.buffers[GLctx.currentArrayBufferBinding]);
        }
      },
  createContext:(/** @type {HTMLCanvasElement} */ canvas, webGLContextAttributes) => {
  
        // BUG: Workaround Safari WebGL issue: After successfully acquiring WebGL
        // context on a canvas, calling .getContext() will always return that
        // context independent of which 'webgl' or 'webgl2'
        // context version was passed. See:
        //   https://bugs.webkit.org/show_bug.cgi?id=222758
        // and:
        //   https://github.com/emscripten-core/emscripten/issues/13295.
        // TODO: Once the bug is fixed and shipped in Safari, adjust the Safari
        // version field in above check.
        if (!canvas.getContextSafariWebGL2Fixed) {
          canvas.getContextSafariWebGL2Fixed = canvas.getContext;
          /** @type {function(this:HTMLCanvasElement, string, (Object|null)=): (Object|null)} */
          function fixedGetContext(ver, attrs) {
            var gl = canvas.getContextSafariWebGL2Fixed(ver, attrs);
            return ((ver == 'webgl') == (gl instanceof WebGLRenderingContext)) ? gl : null;
          }
          canvas.getContext = fixedGetContext;
        }
  
        var ctx = canvas.getContext("webgl2", webGLContextAttributes);
  
        if (!ctx) return 0;
  
        var handle = GL.registerContext(ctx, webGLContextAttributes);
  
        return handle;
      },
  registerContext:(ctx, webGLContextAttributes) => {
        // without pthreads a context is just an integer ID
        var handle = GL.getNewId(GL.contexts);
  
        var context = {
          handle,
          attributes: webGLContextAttributes,
          version: webGLContextAttributes.majorVersion,
          GLctx: ctx
        };
  
        // Store the created context object so that we can access the context
        // given a canvas without having to pass the parameters again.
        if (ctx.canvas) ctx.canvas.GLctxObject = context;
        GL.contexts[handle] = context;
        if (typeof webGLContextAttributes.enableExtensionsByDefault == 'undefined' || webGLContextAttributes.enableExtensionsByDefault) {
          GL.initExtensions(context);
        }
  
        context.maxVertexAttribs = context.GLctx.getParameter(0x8869 /*GL_MAX_VERTEX_ATTRIBS*/);
        context.clientBuffers = [];
        for (var i = 0; i < context.maxVertexAttribs; i++) {
          context.clientBuffers[i] = {
            enabled: false,
            clientside: false,
            size: 0,
            type: 0,
            normalized: 0,
            stride: 0,
            ptr: 0,
            vertexAttribPointerAdaptor: null,
          };
        }
  
        GL.generateTempBuffers(false, context);
  
        return handle;
      },
  makeContextCurrent:(contextHandle) => {
  
        // Active Emscripten GL layer context object.
        GL.currentContext = GL.contexts[contextHandle];
        // Active WebGL context object.
        Module['ctx'] = GLctx = GL.currentContext?.GLctx;
        return !(contextHandle && !GLctx);
      },
  getContext:(contextHandle) => {
        return GL.contexts[contextHandle];
      },
  deleteContext:(contextHandle) => {
        if (GL.currentContext === GL.contexts[contextHandle]) {
          GL.currentContext = null;
        }
        if (typeof JSEvents == 'object') {
          // Release all JS event handlers on the DOM element that the GL context is
          // associated with since the context is now deleted.
          JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);
        }
        // Make sure the canvas object no longer refers to the context object so
        // there are no GC surprises.
        if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas) {
          GL.contexts[contextHandle].GLctx.canvas.GLctxObject = undefined;
        }
        GL.contexts[contextHandle] = null;
      },
  initExtensions:(context) => {
        // If this function is called without a specific context object, init the
        // extensions of the currently active context.
        context ||= GL.currentContext;
  
        if (context.initExtensionsDone) return;
        context.initExtensionsDone = true;
  
        var GLctx = context.GLctx;
  
        // Detect the presence of a few extensions manually, ction GL interop
        // layer itself will need to know if they exist.
  
        // Extensions that are available in both WebGL 1 and WebGL 2
        webgl_enable_WEBGL_multi_draw(GLctx);
        webgl_enable_EXT_polygon_offset_clamp(GLctx);
        webgl_enable_EXT_clip_control(GLctx);
        webgl_enable_WEBGL_polygon_mode(GLctx);
        // Extensions that are available from WebGL >= 2 (no-op if called on a WebGL 1 context active)
        webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance(GLctx);
        webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance(GLctx);
  
        // On WebGL 2, EXT_disjoint_timer_query is replaced with an alternative
        // that's based on core APIs, and exposes only the queryCounterEXT()
        // entrypoint.
        if (context.version >= 2) {
          GLctx.disjointTimerQueryExt = GLctx.getExtension("EXT_disjoint_timer_query_webgl2");
        }
  
        // However, Firefox exposes the WebGL 1 version on WebGL 2 as well and
        // thus we look for the WebGL 1 version again if the WebGL 2 version
        // isn't present. https://bugzilla.mozilla.org/show_bug.cgi?id=1328882
        if (context.version < 2 || !GLctx.disjointTimerQueryExt)
        {
          GLctx.disjointTimerQueryExt = GLctx.getExtension("EXT_disjoint_timer_query");
        }
  
        getEmscriptenSupportedExtensions(GLctx).forEach((ext) => {
          // WEBGL_lose_context, WEBGL_debug_renderer_info and WEBGL_debug_shaders
          // are not enabled by default.
          if (!ext.includes('lose_context') && !ext.includes('debug')) {
            // Call .getExtension() to enable that extension permanently.
            GLctx.getExtension(ext);
          }
        });
      },
  };
  /** @suppress {duplicate } */
  var _glActiveTexture = (x0) => GLctx.activeTexture(x0);
  _glActiveTexture.sig = 'vi';
  var _emscripten_glActiveTexture = _glActiveTexture;
  _emscripten_glActiveTexture.sig = 'vi';

  /** @suppress {duplicate } */
  var _glAttachShader = (program, shader) => {
      GLctx.attachShader(GL.programs[program], GL.shaders[shader]);
    };
  _glAttachShader.sig = 'vii';
  var _emscripten_glAttachShader = _glAttachShader;
  _emscripten_glAttachShader.sig = 'vii';

  /** @suppress {duplicate } */
  var _glBeginQuery = (target, id) => {
      GLctx.beginQuery(target, GL.queries[id]);
    };
  _glBeginQuery.sig = 'vii';
  var _emscripten_glBeginQuery = _glBeginQuery;
  _emscripten_glBeginQuery.sig = 'vii';

  /** @suppress {duplicate } */
  var _glBeginQueryEXT = (target, id) => {
      GLctx.disjointTimerQueryExt['beginQueryEXT'](target, GL.queries[id]);
    };
  _glBeginQueryEXT.sig = 'vii';
  var _emscripten_glBeginQueryEXT = _glBeginQueryEXT;

  /** @suppress {duplicate } */
  var _glBeginTransformFeedback = (x0) => GLctx.beginTransformFeedback(x0);
  _glBeginTransformFeedback.sig = 'vi';
  var _emscripten_glBeginTransformFeedback = _glBeginTransformFeedback;
  _emscripten_glBeginTransformFeedback.sig = 'vi';

  
  /** @suppress {duplicate } */
  var _glBindAttribLocation = (program, index, name) => {
      GLctx.bindAttribLocation(GL.programs[program], index, UTF8ToString(name));
    };
  _glBindAttribLocation.sig = 'viip';
  var _emscripten_glBindAttribLocation = _glBindAttribLocation;
  _emscripten_glBindAttribLocation.sig = 'viip';

  /** @suppress {duplicate } */
  var _glBindBuffer = (target, buffer) => {
      if (target == 0x8892 /*GL_ARRAY_BUFFER*/) {
        GLctx.currentArrayBufferBinding = buffer;
      } else if (target == 0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/) {
        GLctx.currentElementArrayBufferBinding = buffer;
      }
  
      if (target == 0x88EB /*GL_PIXEL_PACK_BUFFER*/) {
        // In WebGL 2 glReadPixels entry point, we need to use a different WebGL 2
        // API function call when a buffer is bound to
        // GL_PIXEL_PACK_BUFFER_BINDING point, so must keep track whether that
        // binding point is non-null to know what is the proper API function to
        // call.
        GLctx.currentPixelPackBufferBinding = buffer;
      } else if (target == 0x88EC /*GL_PIXEL_UNPACK_BUFFER*/) {
        // In WebGL 2 gl(Compressed)Tex(Sub)Image[23]D entry points, we need to
        // use a different WebGL 2 API function call when a buffer is bound to
        // GL_PIXEL_UNPACK_BUFFER_BINDING point, so must keep track whether that
        // binding point is non-null to know what is the proper API function to
        // call.
        GLctx.currentPixelUnpackBufferBinding = buffer;
      }
      GLctx.bindBuffer(target, GL.buffers[buffer]);
    };
  _glBindBuffer.sig = 'vii';
  var _emscripten_glBindBuffer = _glBindBuffer;
  _emscripten_glBindBuffer.sig = 'vii';

  /** @suppress {duplicate } */
  var _glBindBufferBase = (target, index, buffer) => {
      GLctx.bindBufferBase(target, index, GL.buffers[buffer]);
    };
  _glBindBufferBase.sig = 'viii';
  var _emscripten_glBindBufferBase = _glBindBufferBase;
  _emscripten_glBindBufferBase.sig = 'viii';

  /** @suppress {duplicate } */
  var _glBindBufferRange = (target, index, buffer, offset, ptrsize) => {
      GLctx.bindBufferRange(target, index, GL.buffers[buffer], offset, ptrsize);
    };
  _glBindBufferRange.sig = 'viiipp';
  var _emscripten_glBindBufferRange = _glBindBufferRange;
  _emscripten_glBindBufferRange.sig = 'viiipp';

  /** @suppress {duplicate } */
  var _glBindFramebuffer = (target, framebuffer) => {
  
      GLctx.bindFramebuffer(target, GL.framebuffers[framebuffer]);
  
    };
  _glBindFramebuffer.sig = 'vii';
  var _emscripten_glBindFramebuffer = _glBindFramebuffer;
  _emscripten_glBindFramebuffer.sig = 'vii';

  /** @suppress {duplicate } */
  var _glBindRenderbuffer = (target, renderbuffer) => {
      GLctx.bindRenderbuffer(target, GL.renderbuffers[renderbuffer]);
    };
  _glBindRenderbuffer.sig = 'vii';
  var _emscripten_glBindRenderbuffer = _glBindRenderbuffer;
  _emscripten_glBindRenderbuffer.sig = 'vii';

  /** @suppress {duplicate } */
  var _glBindSampler = (unit, sampler) => {
      GLctx.bindSampler(unit, GL.samplers[sampler]);
    };
  _glBindSampler.sig = 'vii';
  var _emscripten_glBindSampler = _glBindSampler;
  _emscripten_glBindSampler.sig = 'vii';

  /** @suppress {duplicate } */
  var _glBindTexture = (target, texture) => {
      GLctx.bindTexture(target, GL.textures[texture]);
    };
  _glBindTexture.sig = 'vii';
  var _emscripten_glBindTexture = _glBindTexture;
  _emscripten_glBindTexture.sig = 'vii';

  /** @suppress {duplicate } */
  var _glBindTransformFeedback = (target, id) => {
      GLctx.bindTransformFeedback(target, GL.transformFeedbacks[id]);
    };
  _glBindTransformFeedback.sig = 'vii';
  var _emscripten_glBindTransformFeedback = _glBindTransformFeedback;
  _emscripten_glBindTransformFeedback.sig = 'vii';

  /** @suppress {duplicate } */
  var _glBindVertexArray = (vao) => {
      GLctx.bindVertexArray(GL.vaos[vao]);
      var ibo = GLctx.getParameter(0x8895 /*ELEMENT_ARRAY_BUFFER_BINDING*/);
      GLctx.currentElementArrayBufferBinding = ibo ? (ibo.name | 0) : 0;
    };
  _glBindVertexArray.sig = 'vi';
  var _emscripten_glBindVertexArray = _glBindVertexArray;
  _emscripten_glBindVertexArray.sig = 'vi';

  
  /** @suppress {duplicate } */
  var _glBindVertexArrayOES = _glBindVertexArray;
  _glBindVertexArrayOES.sig = 'vi';
  var _emscripten_glBindVertexArrayOES = _glBindVertexArrayOES;
  _emscripten_glBindVertexArrayOES.sig = 'vi';

  /** @suppress {duplicate } */
  var _glBlendColor = (x0, x1, x2, x3) => GLctx.blendColor(x0, x1, x2, x3);
  _glBlendColor.sig = 'vffff';
  var _emscripten_glBlendColor = _glBlendColor;
  _emscripten_glBlendColor.sig = 'vffff';

  /** @suppress {duplicate } */
  var _glBlendEquation = (x0) => GLctx.blendEquation(x0);
  _glBlendEquation.sig = 'vi';
  var _emscripten_glBlendEquation = _glBlendEquation;
  _emscripten_glBlendEquation.sig = 'vi';

  /** @suppress {duplicate } */
  var _glBlendEquationSeparate = (x0, x1) => GLctx.blendEquationSeparate(x0, x1);
  _glBlendEquationSeparate.sig = 'vii';
  var _emscripten_glBlendEquationSeparate = _glBlendEquationSeparate;
  _emscripten_glBlendEquationSeparate.sig = 'vii';

  /** @suppress {duplicate } */
  var _glBlendFunc = (x0, x1) => GLctx.blendFunc(x0, x1);
  _glBlendFunc.sig = 'vii';
  var _emscripten_glBlendFunc = _glBlendFunc;
  _emscripten_glBlendFunc.sig = 'vii';

  /** @suppress {duplicate } */
  var _glBlendFuncSeparate = (x0, x1, x2, x3) => GLctx.blendFuncSeparate(x0, x1, x2, x3);
  _glBlendFuncSeparate.sig = 'viiii';
  var _emscripten_glBlendFuncSeparate = _glBlendFuncSeparate;
  _emscripten_glBlendFuncSeparate.sig = 'viiii';

  /** @suppress {duplicate } */
  var _glBlitFramebuffer = (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9) => GLctx.blitFramebuffer(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
  _glBlitFramebuffer.sig = 'viiiiiiiiii';
  var _emscripten_glBlitFramebuffer = _glBlitFramebuffer;
  _emscripten_glBlitFramebuffer.sig = 'viiiiiiiiii';

  /** @suppress {duplicate } */
  var _glBufferData = (target, size, data, usage) => {
  
      if (true) {
        // If size is zero, WebGL would interpret uploading the whole input
        // arraybuffer (starting from given offset), which would not make sense in
        // WebAssembly, so avoid uploading if size is zero. However we must still
        // call bufferData to establish a backing storage of zero bytes.
        if (data && size) {
          GLctx.bufferData(target, HEAPU8, usage, data, size);
        } else {
          GLctx.bufferData(target, size, usage);
        }
        return;
      }
    };
  _glBufferData.sig = 'vippi';
  var _emscripten_glBufferData = _glBufferData;
  _emscripten_glBufferData.sig = 'vippi';

  /** @suppress {duplicate } */
  var _glBufferSubData = (target, offset, size, data) => {
      if (true) {
        size && GLctx.bufferSubData(target, offset, HEAPU8, data, size);
        return;
      }
    };
  _glBufferSubData.sig = 'vippp';
  var _emscripten_glBufferSubData = _glBufferSubData;
  _emscripten_glBufferSubData.sig = 'vippp';

  /** @suppress {duplicate } */
  var _glCheckFramebufferStatus = (x0) => GLctx.checkFramebufferStatus(x0);
  _glCheckFramebufferStatus.sig = 'ii';
  var _emscripten_glCheckFramebufferStatus = _glCheckFramebufferStatus;
  _emscripten_glCheckFramebufferStatus.sig = 'ii';

  /** @suppress {duplicate } */
  var _glClear = (x0) => GLctx.clear(x0);
  _glClear.sig = 'vi';
  var _emscripten_glClear = _glClear;
  _emscripten_glClear.sig = 'vi';

  /** @suppress {duplicate } */
  var _glClearBufferfi = (x0, x1, x2, x3) => GLctx.clearBufferfi(x0, x1, x2, x3);
  _glClearBufferfi.sig = 'viifi';
  var _emscripten_glClearBufferfi = _glClearBufferfi;
  _emscripten_glClearBufferfi.sig = 'viifi';

  /** @suppress {duplicate } */
  var _glClearBufferfv = (buffer, drawbuffer, value) => {
  
      GLctx.clearBufferfv(buffer, drawbuffer, HEAPF32, ((value)>>2));
    };
  _glClearBufferfv.sig = 'viip';
  var _emscripten_glClearBufferfv = _glClearBufferfv;
  _emscripten_glClearBufferfv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glClearBufferiv = (buffer, drawbuffer, value) => {
  
      GLctx.clearBufferiv(buffer, drawbuffer, HEAP32, ((value)>>2));
    };
  _glClearBufferiv.sig = 'viip';
  var _emscripten_glClearBufferiv = _glClearBufferiv;
  _emscripten_glClearBufferiv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glClearBufferuiv = (buffer, drawbuffer, value) => {
  
      GLctx.clearBufferuiv(buffer, drawbuffer, HEAPU32, ((value)>>2));
    };
  _glClearBufferuiv.sig = 'viip';
  var _emscripten_glClearBufferuiv = _glClearBufferuiv;
  _emscripten_glClearBufferuiv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glClearColor = (x0, x1, x2, x3) => GLctx.clearColor(x0, x1, x2, x3);
  _glClearColor.sig = 'vffff';
  var _emscripten_glClearColor = _glClearColor;
  _emscripten_glClearColor.sig = 'vffff';

  /** @suppress {duplicate } */
  var _glClearDepthf = (x0) => GLctx.clearDepth(x0);
  _glClearDepthf.sig = 'vf';
  var _emscripten_glClearDepthf = _glClearDepthf;
  _emscripten_glClearDepthf.sig = 'vf';

  /** @suppress {duplicate } */
  var _glClearStencil = (x0) => GLctx.clearStencil(x0);
  _glClearStencil.sig = 'vi';
  var _emscripten_glClearStencil = _glClearStencil;
  _emscripten_glClearStencil.sig = 'vi';

  /** @suppress {duplicate } */
  var _glClientWaitSync = (sync, flags, timeout) => {
      // WebGL2 vs GLES3 differences: in GLES3, the timeout parameter is a uint64, where 0xFFFFFFFFFFFFFFFFULL means GL_TIMEOUT_IGNORED.
      // In JS, there's no 64-bit value types, so instead timeout is taken to be signed, and GL_TIMEOUT_IGNORED is given value -1.
      // Inherently the value accepted in the timeout is lossy, and can't take in arbitrary u64 bit pattern (but most likely doesn't matter)
      // See https://www.khronos.org/registry/webgl/specs/latest/2.0/#5.15
      timeout = Number(timeout);
      return GLctx.clientWaitSync(GL.syncs[sync], flags, timeout);
    };
  _glClientWaitSync.sig = 'ipij';
  var _emscripten_glClientWaitSync = _glClientWaitSync;
  _emscripten_glClientWaitSync.sig = 'ipij';

  /** @suppress {duplicate } */
  var _glClipControlEXT = (origin, depth) => {
      GLctx.extClipControl['clipControlEXT'](origin, depth);
    };
  _glClipControlEXT.sig = 'vii';
  var _emscripten_glClipControlEXT = _glClipControlEXT;

  /** @suppress {duplicate } */
  var _glColorMask = (red, green, blue, alpha) => {
      GLctx.colorMask(!!red, !!green, !!blue, !!alpha);
    };
  _glColorMask.sig = 'viiii';
  var _emscripten_glColorMask = _glColorMask;
  _emscripten_glColorMask.sig = 'viiii';

  /** @suppress {duplicate } */
  var _glCompileShader = (shader) => {
      GLctx.compileShader(GL.shaders[shader]);
    };
  _glCompileShader.sig = 'vi';
  var _emscripten_glCompileShader = _glCompileShader;
  _emscripten_glCompileShader.sig = 'vi';

  /** @suppress {duplicate } */
  var _glCompressedTexImage2D = (target, level, internalFormat, width, height, border, imageSize, data) => {
      // `data` may be null here, which means "allocate uniniitalized space but
      // don't upload" in GLES parlance, but `compressedTexImage2D` requires the
      // final data parameter, so we simply pass a heap view starting at zero
      // effectively uploading whatever happens to be near address zero.  See
      // https://github.com/emscripten-core/emscripten/issues/19300.
      if (true) {
        if (GLctx.currentPixelUnpackBufferBinding || !imageSize) {
          GLctx.compressedTexImage2D(target, level, internalFormat, width, height, border, imageSize, data);
          return;
        }
        GLctx.compressedTexImage2D(target, level, internalFormat, width, height, border, HEAPU8, data, imageSize);
        return;
      }
    };
  _glCompressedTexImage2D.sig = 'viiiiiiip';
  var _emscripten_glCompressedTexImage2D = _glCompressedTexImage2D;
  _emscripten_glCompressedTexImage2D.sig = 'viiiiiiip';

  /** @suppress {duplicate } */
  var _glCompressedTexImage3D = (target, level, internalFormat, width, height, depth, border, imageSize, data) => {
      if (GLctx.currentPixelUnpackBufferBinding) {
        GLctx.compressedTexImage3D(target, level, internalFormat, width, height, depth, border, imageSize, data);
      } else {
        GLctx.compressedTexImage3D(target, level, internalFormat, width, height, depth, border, HEAPU8, data, imageSize);
      }
    };
  _glCompressedTexImage3D.sig = 'viiiiiiiip';
  var _emscripten_glCompressedTexImage3D = _glCompressedTexImage3D;
  _emscripten_glCompressedTexImage3D.sig = 'viiiiiiiip';

  /** @suppress {duplicate } */
  var _glCompressedTexSubImage2D = (target, level, xoffset, yoffset, width, height, format, imageSize, data) => {
      if (true) {
        if (GLctx.currentPixelUnpackBufferBinding || !imageSize) {
          GLctx.compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
          return;
        }
        GLctx.compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, HEAPU8, data, imageSize);
        return;
      }
    };
  _glCompressedTexSubImage2D.sig = 'viiiiiiiip';
  var _emscripten_glCompressedTexSubImage2D = _glCompressedTexSubImage2D;
  _emscripten_glCompressedTexSubImage2D.sig = 'viiiiiiiip';

  /** @suppress {duplicate } */
  var _glCompressedTexSubImage3D = (target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data) => {
      if (GLctx.currentPixelUnpackBufferBinding) {
        GLctx.compressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
      } else {
        GLctx.compressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, HEAPU8, data, imageSize);
      }
    };
  _glCompressedTexSubImage3D.sig = 'viiiiiiiiiip';
  var _emscripten_glCompressedTexSubImage3D = _glCompressedTexSubImage3D;
  _emscripten_glCompressedTexSubImage3D.sig = 'viiiiiiiiiip';

  /** @suppress {duplicate } */
  var _glCopyBufferSubData = (x0, x1, x2, x3, x4) => GLctx.copyBufferSubData(x0, x1, x2, x3, x4);
  _glCopyBufferSubData.sig = 'viippp';
  var _emscripten_glCopyBufferSubData = _glCopyBufferSubData;
  _emscripten_glCopyBufferSubData.sig = 'viippp';

  /** @suppress {duplicate } */
  var _glCopyTexImage2D = (x0, x1, x2, x3, x4, x5, x6, x7) => GLctx.copyTexImage2D(x0, x1, x2, x3, x4, x5, x6, x7);
  _glCopyTexImage2D.sig = 'viiiiiiii';
  var _emscripten_glCopyTexImage2D = _glCopyTexImage2D;
  _emscripten_glCopyTexImage2D.sig = 'viiiiiiii';

  /** @suppress {duplicate } */
  var _glCopyTexSubImage2D = (x0, x1, x2, x3, x4, x5, x6, x7) => GLctx.copyTexSubImage2D(x0, x1, x2, x3, x4, x5, x6, x7);
  _glCopyTexSubImage2D.sig = 'viiiiiiii';
  var _emscripten_glCopyTexSubImage2D = _glCopyTexSubImage2D;
  _emscripten_glCopyTexSubImage2D.sig = 'viiiiiiii';

  /** @suppress {duplicate } */
  var _glCopyTexSubImage3D = (x0, x1, x2, x3, x4, x5, x6, x7, x8) => GLctx.copyTexSubImage3D(x0, x1, x2, x3, x4, x5, x6, x7, x8);
  _glCopyTexSubImage3D.sig = 'viiiiiiiii';
  var _emscripten_glCopyTexSubImage3D = _glCopyTexSubImage3D;
  _emscripten_glCopyTexSubImage3D.sig = 'viiiiiiiii';

  /** @suppress {duplicate } */
  var _glCreateProgram = () => {
      var id = GL.getNewId(GL.programs);
      var program = GLctx.createProgram();
      // Store additional information needed for each shader program:
      program.name = id;
      // Lazy cache results of
      // glGetProgramiv(GL_ACTIVE_UNIFORM_MAX_LENGTH/GL_ACTIVE_ATTRIBUTE_MAX_LENGTH/GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH)
      program.maxUniformLength = program.maxAttributeLength = program.maxUniformBlockNameLength = 0;
      program.uniformIdCounter = 1;
      GL.programs[id] = program;
      return id;
    };
  _glCreateProgram.sig = 'i';
  var _emscripten_glCreateProgram = _glCreateProgram;
  _emscripten_glCreateProgram.sig = 'i';

  /** @suppress {duplicate } */
  var _glCreateShader = (shaderType) => {
      var id = GL.getNewId(GL.shaders);
      GL.shaders[id] = GLctx.createShader(shaderType);
  
      return id;
    };
  _glCreateShader.sig = 'ii';
  var _emscripten_glCreateShader = _glCreateShader;
  _emscripten_glCreateShader.sig = 'ii';

  /** @suppress {duplicate } */
  var _glCullFace = (x0) => GLctx.cullFace(x0);
  _glCullFace.sig = 'vi';
  var _emscripten_glCullFace = _glCullFace;
  _emscripten_glCullFace.sig = 'vi';

  /** @suppress {duplicate } */
  var _glDeleteBuffers = (n, buffers) => {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((buffers)+(i*4))>>2)];
        var buffer = GL.buffers[id];
  
        // From spec: "glDeleteBuffers silently ignores 0's and names that do not
        // correspond to existing buffer objects."
        if (!buffer) continue;
  
        GLctx.deleteBuffer(buffer);
        buffer.name = 0;
        GL.buffers[id] = null;
  
        if (id == GLctx.currentArrayBufferBinding) GLctx.currentArrayBufferBinding = 0;
        if (id == GLctx.currentElementArrayBufferBinding) GLctx.currentElementArrayBufferBinding = 0;
        if (id == GLctx.currentPixelPackBufferBinding) GLctx.currentPixelPackBufferBinding = 0;
        if (id == GLctx.currentPixelUnpackBufferBinding) GLctx.currentPixelUnpackBufferBinding = 0;
      }
    };
  _glDeleteBuffers.sig = 'vip';
  var _emscripten_glDeleteBuffers = _glDeleteBuffers;
  _emscripten_glDeleteBuffers.sig = 'vip';

  /** @suppress {duplicate } */
  var _glDeleteFramebuffers = (n, framebuffers) => {
      for (var i = 0; i < n; ++i) {
        var id = HEAP32[(((framebuffers)+(i*4))>>2)];
        var framebuffer = GL.framebuffers[id];
        if (!framebuffer) continue; // GL spec: "glDeleteFramebuffers silently ignores 0s and names that do not correspond to existing framebuffer objects".
        GLctx.deleteFramebuffer(framebuffer);
        framebuffer.name = 0;
        GL.framebuffers[id] = null;
      }
    };
  _glDeleteFramebuffers.sig = 'vip';
  var _emscripten_glDeleteFramebuffers = _glDeleteFramebuffers;
  _emscripten_glDeleteFramebuffers.sig = 'vip';

  /** @suppress {duplicate } */
  var _glDeleteProgram = (id) => {
      if (!id) return;
      var program = GL.programs[id];
      if (!program) {
        // glDeleteProgram actually signals an error when deleting a nonexisting
        // object, unlike some other GL delete functions.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      GLctx.deleteProgram(program);
      program.name = 0;
      GL.programs[id] = null;
    };
  _glDeleteProgram.sig = 'vi';
  var _emscripten_glDeleteProgram = _glDeleteProgram;
  _emscripten_glDeleteProgram.sig = 'vi';

  /** @suppress {duplicate } */
  var _glDeleteQueries = (n, ids) => {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((ids)+(i*4))>>2)];
        var query = GL.queries[id];
        if (!query) continue; // GL spec: "unused names in ids are ignored, as is the name zero."
        GLctx.deleteQuery(query);
        GL.queries[id] = null;
      }
    };
  _glDeleteQueries.sig = 'vip';
  var _emscripten_glDeleteQueries = _glDeleteQueries;
  _emscripten_glDeleteQueries.sig = 'vip';

  /** @suppress {duplicate } */
  var _glDeleteQueriesEXT = (n, ids) => {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((ids)+(i*4))>>2)];
        var query = GL.queries[id];
        if (!query) continue; // GL spec: "unused names in ids are ignored, as is the name zero."
        GLctx.disjointTimerQueryExt['deleteQueryEXT'](query);
        GL.queries[id] = null;
      }
    };
  _glDeleteQueriesEXT.sig = 'vip';
  var _emscripten_glDeleteQueriesEXT = _glDeleteQueriesEXT;

  /** @suppress {duplicate } */
  var _glDeleteRenderbuffers = (n, renderbuffers) => {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((renderbuffers)+(i*4))>>2)];
        var renderbuffer = GL.renderbuffers[id];
        if (!renderbuffer) continue; // GL spec: "glDeleteRenderbuffers silently ignores 0s and names that do not correspond to existing renderbuffer objects".
        GLctx.deleteRenderbuffer(renderbuffer);
        renderbuffer.name = 0;
        GL.renderbuffers[id] = null;
      }
    };
  _glDeleteRenderbuffers.sig = 'vip';
  var _emscripten_glDeleteRenderbuffers = _glDeleteRenderbuffers;
  _emscripten_glDeleteRenderbuffers.sig = 'vip';

  /** @suppress {duplicate } */
  var _glDeleteSamplers = (n, samplers) => {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((samplers)+(i*4))>>2)];
        var sampler = GL.samplers[id];
        if (!sampler) continue;
        GLctx.deleteSampler(sampler);
        sampler.name = 0;
        GL.samplers[id] = null;
      }
    };
  _glDeleteSamplers.sig = 'vip';
  var _emscripten_glDeleteSamplers = _glDeleteSamplers;
  _emscripten_glDeleteSamplers.sig = 'vip';

  /** @suppress {duplicate } */
  var _glDeleteShader = (id) => {
      if (!id) return;
      var shader = GL.shaders[id];
      if (!shader) {
        // glDeleteShader actually signals an error when deleting a nonexisting
        // object, unlike some other GL delete functions.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      GLctx.deleteShader(shader);
      GL.shaders[id] = null;
    };
  _glDeleteShader.sig = 'vi';
  var _emscripten_glDeleteShader = _glDeleteShader;
  _emscripten_glDeleteShader.sig = 'vi';

  /** @suppress {duplicate } */
  var _glDeleteSync = (id) => {
      if (!id) return;
      var sync = GL.syncs[id];
      if (!sync) { // glDeleteSync signals an error when deleting a nonexisting object, unlike some other GL delete functions.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      GLctx.deleteSync(sync);
      sync.name = 0;
      GL.syncs[id] = null;
    };
  _glDeleteSync.sig = 'vp';
  var _emscripten_glDeleteSync = _glDeleteSync;
  _emscripten_glDeleteSync.sig = 'vp';

  /** @suppress {duplicate } */
  var _glDeleteTextures = (n, textures) => {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((textures)+(i*4))>>2)];
        var texture = GL.textures[id];
        // GL spec: "glDeleteTextures silently ignores 0s and names that do not
        // correspond to existing textures".
        if (!texture) continue;
        GLctx.deleteTexture(texture);
        texture.name = 0;
        GL.textures[id] = null;
      }
    };
  _glDeleteTextures.sig = 'vip';
  var _emscripten_glDeleteTextures = _glDeleteTextures;
  _emscripten_glDeleteTextures.sig = 'vip';

  /** @suppress {duplicate } */
  var _glDeleteTransformFeedbacks = (n, ids) => {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((ids)+(i*4))>>2)];
        var transformFeedback = GL.transformFeedbacks[id];
        if (!transformFeedback) continue; // GL spec: "unused names in ids are ignored, as is the name zero."
        GLctx.deleteTransformFeedback(transformFeedback);
        transformFeedback.name = 0;
        GL.transformFeedbacks[id] = null;
      }
    };
  _glDeleteTransformFeedbacks.sig = 'vip';
  var _emscripten_glDeleteTransformFeedbacks = _glDeleteTransformFeedbacks;
  _emscripten_glDeleteTransformFeedbacks.sig = 'vip';

  /** @suppress {duplicate } */
  var _glDeleteVertexArrays = (n, vaos) => {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((vaos)+(i*4))>>2)];
        GLctx.deleteVertexArray(GL.vaos[id]);
        GL.vaos[id] = null;
      }
    };
  _glDeleteVertexArrays.sig = 'vip';
  var _emscripten_glDeleteVertexArrays = _glDeleteVertexArrays;
  _emscripten_glDeleteVertexArrays.sig = 'vip';

  
  /** @suppress {duplicate } */
  var _glDeleteVertexArraysOES = _glDeleteVertexArrays;
  _glDeleteVertexArraysOES.sig = 'vip';
  var _emscripten_glDeleteVertexArraysOES = _glDeleteVertexArraysOES;
  _emscripten_glDeleteVertexArraysOES.sig = 'vip';

  /** @suppress {duplicate } */
  var _glDepthFunc = (x0) => GLctx.depthFunc(x0);
  _glDepthFunc.sig = 'vi';
  var _emscripten_glDepthFunc = _glDepthFunc;
  _emscripten_glDepthFunc.sig = 'vi';

  /** @suppress {duplicate } */
  var _glDepthMask = (flag) => {
      GLctx.depthMask(!!flag);
    };
  _glDepthMask.sig = 'vi';
  var _emscripten_glDepthMask = _glDepthMask;
  _emscripten_glDepthMask.sig = 'vi';

  /** @suppress {duplicate } */
  var _glDepthRangef = (x0, x1) => GLctx.depthRange(x0, x1);
  _glDepthRangef.sig = 'vff';
  var _emscripten_glDepthRangef = _glDepthRangef;
  _emscripten_glDepthRangef.sig = 'vff';

  /** @suppress {duplicate } */
  var _glDetachShader = (program, shader) => {
      GLctx.detachShader(GL.programs[program], GL.shaders[shader]);
    };
  _glDetachShader.sig = 'vii';
  var _emscripten_glDetachShader = _glDetachShader;
  _emscripten_glDetachShader.sig = 'vii';

  /** @suppress {duplicate } */
  var _glDisable = (x0) => GLctx.disable(x0);
  _glDisable.sig = 'vi';
  var _emscripten_glDisable = _glDisable;
  _emscripten_glDisable.sig = 'vi';

  /** @suppress {duplicate } */
  var _glDisableVertexAttribArray = (index) => {
      var cb = GL.currentContext.clientBuffers[index];
      cb.enabled = false;
      GLctx.disableVertexAttribArray(index);
    };
  _glDisableVertexAttribArray.sig = 'vi';
  var _emscripten_glDisableVertexAttribArray = _glDisableVertexAttribArray;
  _emscripten_glDisableVertexAttribArray.sig = 'vi';

  /** @suppress {duplicate } */
  var _glDrawArrays = (mode, first, count) => {
      // bind any client-side buffers
      GL.preDrawHandleClientVertexAttribBindings(first + count);
  
      GLctx.drawArrays(mode, first, count);
  
      GL.postDrawHandleClientVertexAttribBindings();
    };
  _glDrawArrays.sig = 'viii';
  var _emscripten_glDrawArrays = _glDrawArrays;
  _emscripten_glDrawArrays.sig = 'viii';

  /** @suppress {duplicate } */
  var _glDrawArraysInstanced = (mode, first, count, primcount) => {
      GLctx.drawArraysInstanced(mode, first, count, primcount);
    };
  _glDrawArraysInstanced.sig = 'viiii';
  var _emscripten_glDrawArraysInstanced = _glDrawArraysInstanced;
  _emscripten_glDrawArraysInstanced.sig = 'viiii';

  
  /** @suppress {duplicate } */
  var _glDrawArraysInstancedANGLE = _glDrawArraysInstanced;
  var _emscripten_glDrawArraysInstancedANGLE = _glDrawArraysInstancedANGLE;

  
  /** @suppress {duplicate } */
  var _glDrawArraysInstancedARB = _glDrawArraysInstanced;
  var _emscripten_glDrawArraysInstancedARB = _glDrawArraysInstancedARB;

  
  /** @suppress {duplicate } */
  var _glDrawArraysInstancedEXT = _glDrawArraysInstanced;
  var _emscripten_glDrawArraysInstancedEXT = _glDrawArraysInstancedEXT;

  
  /** @suppress {duplicate } */
  var _glDrawArraysInstancedNV = _glDrawArraysInstanced;
  var _emscripten_glDrawArraysInstancedNV = _glDrawArraysInstancedNV;

  var tempFixedLengthArray = [];
  
  /** @suppress {duplicate } */
  var _glDrawBuffers = (n, bufs) => {
  
      var bufArray = tempFixedLengthArray[n];
      for (var i = 0; i < n; i++) {
        bufArray[i] = HEAP32[(((bufs)+(i*4))>>2)];
      }
  
      GLctx.drawBuffers(bufArray);
    };
  _glDrawBuffers.sig = 'vip';
  var _emscripten_glDrawBuffers = _glDrawBuffers;
  _emscripten_glDrawBuffers.sig = 'vip';

  
  /** @suppress {duplicate } */
  var _glDrawBuffersEXT = _glDrawBuffers;
  var _emscripten_glDrawBuffersEXT = _glDrawBuffersEXT;

  
  /** @suppress {duplicate } */
  var _glDrawBuffersWEBGL = _glDrawBuffers;
  var _emscripten_glDrawBuffersWEBGL = _glDrawBuffersWEBGL;

  /** @suppress {duplicate } */
  var _glDrawElements = (mode, count, type, indices) => {
      var buf;
      var vertexes = 0;
      if (!GLctx.currentElementArrayBufferBinding) {
        var size = GL.calcBufLength(1, type, 0, count);
        buf = GL.getTempIndexBuffer(size);
        GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, buf);
        GLctx.bufferSubData(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/,
                            0,
                            HEAPU8.subarray(indices, indices + size));
        
        // Calculating vertex count if shader's attribute data is on client side
        if (count > 0) {
          for (var i = 0; i < GL.currentContext.maxVertexAttribs; ++i) {
            var cb = GL.currentContext.clientBuffers[i];
            if (cb.clientside && cb.enabled) {
              let arrayClass;
              switch(type) {
                case 0x1401 /* GL_UNSIGNED_BYTE */: arrayClass = Uint8Array; break;
                case 0x1403 /* GL_UNSIGNED_SHORT */: arrayClass = Uint16Array; break;
                case 0x1405 /* GL_UNSIGNED_INT */: arrayClass = Uint32Array; break;
                default:
                  GL.recordError(0x502 /* GL_INVALID_OPERATION */);
                  return;
              }
  
              vertexes = new arrayClass(HEAPU8.buffer, indices, count).reduce((max, current) => Math.max(max, current)) + 1;
              break;
            }
          }
        }
  
        // the index is now 0
        indices = 0;
      }
  
      // bind any client-side buffers
      GL.preDrawHandleClientVertexAttribBindings(vertexes);
  
      GLctx.drawElements(mode, count, type, indices);
  
      GL.postDrawHandleClientVertexAttribBindings(count);
  
      if (!GLctx.currentElementArrayBufferBinding) {
        GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, null);
      }
    };
  _glDrawElements.sig = 'viiip';
  var _emscripten_glDrawElements = _glDrawElements;
  _emscripten_glDrawElements.sig = 'viiip';

  /** @suppress {duplicate } */
  var _glDrawElementsInstanced = (mode, count, type, indices, primcount) => {
      GLctx.drawElementsInstanced(mode, count, type, indices, primcount);
    };
  _glDrawElementsInstanced.sig = 'viiipi';
  var _emscripten_glDrawElementsInstanced = _glDrawElementsInstanced;
  _emscripten_glDrawElementsInstanced.sig = 'viiipi';

  
  /** @suppress {duplicate } */
  var _glDrawElementsInstancedANGLE = _glDrawElementsInstanced;
  var _emscripten_glDrawElementsInstancedANGLE = _glDrawElementsInstancedANGLE;

  
  /** @suppress {duplicate } */
  var _glDrawElementsInstancedARB = _glDrawElementsInstanced;
  var _emscripten_glDrawElementsInstancedARB = _glDrawElementsInstancedARB;

  
  /** @suppress {duplicate } */
  var _glDrawElementsInstancedEXT = _glDrawElementsInstanced;
  var _emscripten_glDrawElementsInstancedEXT = _glDrawElementsInstancedEXT;

  
  /** @suppress {duplicate } */
  var _glDrawElementsInstancedNV = _glDrawElementsInstanced;
  var _emscripten_glDrawElementsInstancedNV = _glDrawElementsInstancedNV;

  /** @suppress {duplicate } */
  var _glDrawRangeElements = (mode, start, end, count, type, indices) => {
      // TODO: This should be a trivial pass-though function registered at the bottom of this page as
      // glFuncs[6][1] += ' drawRangeElements';
      // but due to https://bugzilla.mozilla.org/show_bug.cgi?id=1202427,
      // we work around by ignoring the range.
      _glDrawElements(mode, count, type, indices);
    };
  _glDrawRangeElements.sig = 'viiiiip';
  var _emscripten_glDrawRangeElements = _glDrawRangeElements;
  _emscripten_glDrawRangeElements.sig = 'viiiiip';

  /** @suppress {duplicate } */
  var _glEnable = (x0) => GLctx.enable(x0);
  _glEnable.sig = 'vi';
  var _emscripten_glEnable = _glEnable;
  _emscripten_glEnable.sig = 'vi';

  /** @suppress {duplicate } */
  var _glEnableVertexAttribArray = (index) => {
      var cb = GL.currentContext.clientBuffers[index];
      cb.enabled = true;
      GLctx.enableVertexAttribArray(index);
    };
  _glEnableVertexAttribArray.sig = 'vi';
  var _emscripten_glEnableVertexAttribArray = _glEnableVertexAttribArray;
  _emscripten_glEnableVertexAttribArray.sig = 'vi';

  /** @suppress {duplicate } */
  var _glEndQuery = (x0) => GLctx.endQuery(x0);
  _glEndQuery.sig = 'vi';
  var _emscripten_glEndQuery = _glEndQuery;
  _emscripten_glEndQuery.sig = 'vi';

  /** @suppress {duplicate } */
  var _glEndQueryEXT = (target) => {
      GLctx.disjointTimerQueryExt['endQueryEXT'](target);
    };
  _glEndQueryEXT.sig = 'vi';
  var _emscripten_glEndQueryEXT = _glEndQueryEXT;

  /** @suppress {duplicate } */
  var _glEndTransformFeedback = () => GLctx.endTransformFeedback();
  _glEndTransformFeedback.sig = 'v';
  var _emscripten_glEndTransformFeedback = _glEndTransformFeedback;
  _emscripten_glEndTransformFeedback.sig = 'v';

  /** @suppress {duplicate } */
  var _glFenceSync = (condition, flags) => {
      var sync = GLctx.fenceSync(condition, flags);
      if (sync) {
        var id = GL.getNewId(GL.syncs);
        sync.name = id;
        GL.syncs[id] = sync;
        return id;
      }
      return 0; // Failed to create a sync object
    };
  _glFenceSync.sig = 'pii';
  var _emscripten_glFenceSync = _glFenceSync;
  _emscripten_glFenceSync.sig = 'pii';

  /** @suppress {duplicate } */
  var _glFinish = () => GLctx.finish();
  _glFinish.sig = 'v';
  var _emscripten_glFinish = _glFinish;
  _emscripten_glFinish.sig = 'v';

  /** @suppress {duplicate } */
  var _glFlush = () => GLctx.flush();
  _glFlush.sig = 'v';
  var _emscripten_glFlush = _glFlush;
  _emscripten_glFlush.sig = 'v';

  var emscriptenWebGLGetBufferBinding = (target) => {
      switch (target) {
        case 0x8892 /*GL_ARRAY_BUFFER*/: target = 0x8894 /*GL_ARRAY_BUFFER_BINDING*/; break;
        case 0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/: target = 0x8895 /*GL_ELEMENT_ARRAY_BUFFER_BINDING*/; break;
        case 0x88EB /*GL_PIXEL_PACK_BUFFER*/: target = 0x88ED /*GL_PIXEL_PACK_BUFFER_BINDING*/; break;
        case 0x88EC /*GL_PIXEL_UNPACK_BUFFER*/: target = 0x88EF /*GL_PIXEL_UNPACK_BUFFER_BINDING*/; break;
        case 0x8C8E /*GL_TRANSFORM_FEEDBACK_BUFFER*/: target = 0x8C8F /*GL_TRANSFORM_FEEDBACK_BUFFER_BINDING*/; break;
        case 0x8F36 /*GL_COPY_READ_BUFFER*/: target = 0x8F36 /*GL_COPY_READ_BUFFER_BINDING*/; break;
        case 0x8F37 /*GL_COPY_WRITE_BUFFER*/: target = 0x8F37 /*GL_COPY_WRITE_BUFFER_BINDING*/; break;
        case 0x8A11 /*GL_UNIFORM_BUFFER*/: target = 0x8A28 /*GL_UNIFORM_BUFFER_BINDING*/; break;
        // In default case, fall through and assume passed one of the _BINDING enums directly.
      }
      var buffer = GLctx.getParameter(target);
      if (buffer) return buffer.name|0;
      else return 0;
    };
  
  var emscriptenWebGLValidateMapBufferTarget = (target) => {
      switch (target) {
        case 0x8892: // GL_ARRAY_BUFFER
        case 0x8893: // GL_ELEMENT_ARRAY_BUFFER
        case 0x8F36: // GL_COPY_READ_BUFFER
        case 0x8F37: // GL_COPY_WRITE_BUFFER
        case 0x88EB: // GL_PIXEL_PACK_BUFFER
        case 0x88EC: // GL_PIXEL_UNPACK_BUFFER
        case 0x8C2A: // GL_TEXTURE_BUFFER
        case 0x8C8E: // GL_TRANSFORM_FEEDBACK_BUFFER
        case 0x8A11: // GL_UNIFORM_BUFFER
          return true;
        default:
          return false;
      }
    };
  
  /** @suppress {duplicate } */
  var _glFlushMappedBufferRange = (target, offset, length) => {
      if (!emscriptenWebGLValidateMapBufferTarget(target)) {
        GL.recordError(0x500/*GL_INVALID_ENUM*/);
        err('GL_INVALID_ENUM in glFlushMappedBufferRange');
        return;
      }
  
      var mapping = GL.mappedBuffers[emscriptenWebGLGetBufferBinding(target)];
      if (!mapping) {
        GL.recordError(0x502 /* GL_INVALID_OPERATION */);
        err('buffer was never mapped in glFlushMappedBufferRange');
        return;
      }
  
      if (!(mapping.access & 0x10)) {
        GL.recordError(0x502 /* GL_INVALID_OPERATION */);
        err('buffer was not mapped with GL_MAP_FLUSH_EXPLICIT_BIT in glFlushMappedBufferRange');
        return;
      }
      if (offset < 0 || length < 0 || offset + length > mapping.length) {
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        err('invalid range in glFlushMappedBufferRange');
        return;
      }
  
      GLctx.bufferSubData(
        target,
        mapping.offset,
        HEAPU8.subarray(mapping.mem + offset, mapping.mem + offset + length));
    };
  _glFlushMappedBufferRange.sig = 'vipp';
  var _emscripten_glFlushMappedBufferRange = _glFlushMappedBufferRange;
  _emscripten_glFlushMappedBufferRange.sig = 'vipp';

  /** @suppress {duplicate } */
  var _glFramebufferRenderbuffer = (target, attachment, renderbuffertarget, renderbuffer) => {
      GLctx.framebufferRenderbuffer(target, attachment, renderbuffertarget,
                                         GL.renderbuffers[renderbuffer]);
    };
  _glFramebufferRenderbuffer.sig = 'viiii';
  var _emscripten_glFramebufferRenderbuffer = _glFramebufferRenderbuffer;
  _emscripten_glFramebufferRenderbuffer.sig = 'viiii';

  /** @suppress {duplicate } */
  var _glFramebufferTexture2D = (target, attachment, textarget, texture, level) => {
      GLctx.framebufferTexture2D(target, attachment, textarget,
                                      GL.textures[texture], level);
    };
  _glFramebufferTexture2D.sig = 'viiiii';
  var _emscripten_glFramebufferTexture2D = _glFramebufferTexture2D;
  _emscripten_glFramebufferTexture2D.sig = 'viiiii';

  /** @suppress {duplicate } */
  var _glFramebufferTextureLayer = (target, attachment, texture, level, layer) => {
      GLctx.framebufferTextureLayer(target, attachment, GL.textures[texture], level, layer);
    };
  _glFramebufferTextureLayer.sig = 'viiiii';
  var _emscripten_glFramebufferTextureLayer = _glFramebufferTextureLayer;
  _emscripten_glFramebufferTextureLayer.sig = 'viiiii';

  /** @suppress {duplicate } */
  var _glFrontFace = (x0) => GLctx.frontFace(x0);
  _glFrontFace.sig = 'vi';
  var _emscripten_glFrontFace = _glFrontFace;
  _emscripten_glFrontFace.sig = 'vi';

  /** @suppress {duplicate } */
  var _glGenBuffers = (n, buffers) => {
      GL.genObject(n, buffers, 'createBuffer', GL.buffers
        );
    };
  _glGenBuffers.sig = 'vip';
  var _emscripten_glGenBuffers = _glGenBuffers;
  _emscripten_glGenBuffers.sig = 'vip';

  /** @suppress {duplicate } */
  var _glGenFramebuffers = (n, ids) => {
      GL.genObject(n, ids, 'createFramebuffer', GL.framebuffers
        );
    };
  _glGenFramebuffers.sig = 'vip';
  var _emscripten_glGenFramebuffers = _glGenFramebuffers;
  _emscripten_glGenFramebuffers.sig = 'vip';

  /** @suppress {duplicate } */
  var _glGenQueries = (n, ids) => {
      GL.genObject(n, ids, 'createQuery', GL.queries
        );
    };
  _glGenQueries.sig = 'vip';
  var _emscripten_glGenQueries = _glGenQueries;
  _emscripten_glGenQueries.sig = 'vip';

  /** @suppress {duplicate } */
  var _glGenQueriesEXT = (n, ids) => {
      for (var i = 0; i < n; i++) {
        var query = GLctx.disjointTimerQueryExt['createQueryEXT']();
        if (!query) {
          GL.recordError(0x502 /* GL_INVALID_OPERATION */);
          while (i < n) HEAP32[(((ids)+(i++*4))>>2)] = 0;
          return;
        }
        var id = GL.getNewId(GL.queries);
        query.name = id;
        GL.queries[id] = query;
        HEAP32[(((ids)+(i*4))>>2)] = id;
      }
    };
  _glGenQueriesEXT.sig = 'vip';
  var _emscripten_glGenQueriesEXT = _glGenQueriesEXT;

  /** @suppress {duplicate } */
  var _glGenRenderbuffers = (n, renderbuffers) => {
      GL.genObject(n, renderbuffers, 'createRenderbuffer', GL.renderbuffers
        );
    };
  _glGenRenderbuffers.sig = 'vip';
  var _emscripten_glGenRenderbuffers = _glGenRenderbuffers;
  _emscripten_glGenRenderbuffers.sig = 'vip';

  /** @suppress {duplicate } */
  var _glGenSamplers = (n, samplers) => {
      GL.genObject(n, samplers, 'createSampler', GL.samplers
        );
    };
  _glGenSamplers.sig = 'vip';
  var _emscripten_glGenSamplers = _glGenSamplers;
  _emscripten_glGenSamplers.sig = 'vip';

  /** @suppress {duplicate } */
  var _glGenTextures = (n, textures) => {
      GL.genObject(n, textures, 'createTexture', GL.textures
        );
    };
  _glGenTextures.sig = 'vip';
  var _emscripten_glGenTextures = _glGenTextures;
  _emscripten_glGenTextures.sig = 'vip';

  /** @suppress {duplicate } */
  var _glGenTransformFeedbacks = (n, ids) => {
      GL.genObject(n, ids, 'createTransformFeedback', GL.transformFeedbacks
        );
    };
  _glGenTransformFeedbacks.sig = 'vip';
  var _emscripten_glGenTransformFeedbacks = _glGenTransformFeedbacks;
  _emscripten_glGenTransformFeedbacks.sig = 'vip';

  /** @suppress {duplicate } */
  var _glGenVertexArrays = (n, arrays) => {
      GL.genObject(n, arrays, 'createVertexArray', GL.vaos
        );
    };
  _glGenVertexArrays.sig = 'vip';
  var _emscripten_glGenVertexArrays = _glGenVertexArrays;
  _emscripten_glGenVertexArrays.sig = 'vip';

  
  /** @suppress {duplicate } */
  var _glGenVertexArraysOES = _glGenVertexArrays;
  _glGenVertexArraysOES.sig = 'vip';
  var _emscripten_glGenVertexArraysOES = _glGenVertexArraysOES;
  _emscripten_glGenVertexArraysOES.sig = 'vip';

  /** @suppress {duplicate } */
  var _glGenerateMipmap = (x0) => GLctx.generateMipmap(x0);
  _glGenerateMipmap.sig = 'vi';
  var _emscripten_glGenerateMipmap = _glGenerateMipmap;
  _emscripten_glGenerateMipmap.sig = 'vi';

  
  var __glGetActiveAttribOrUniform = (funcName, program, index, bufSize, length, size, type, name) => {
      program = GL.programs[program];
      var info = GLctx[funcName](program, index);
      if (info) {
        // If an error occurs, nothing will be written to length, size and type and name.
        var numBytesWrittenExclNull = name && stringToUTF8(info.name, name, bufSize);
        if (length) HEAP32[((length)>>2)] = numBytesWrittenExclNull;
        if (size) HEAP32[((size)>>2)] = info.size;
        if (type) HEAP32[((type)>>2)] = info.type;
      }
    };
  
  /** @suppress {duplicate } */
  var _glGetActiveAttrib = (program, index, bufSize, length, size, type, name) =>
      __glGetActiveAttribOrUniform('getActiveAttrib', program, index, bufSize, length, size, type, name);
  _glGetActiveAttrib.sig = 'viiipppp';
  var _emscripten_glGetActiveAttrib = _glGetActiveAttrib;
  _emscripten_glGetActiveAttrib.sig = 'viiipppp';

  
  /** @suppress {duplicate } */
  var _glGetActiveUniform = (program, index, bufSize, length, size, type, name) =>
      __glGetActiveAttribOrUniform('getActiveUniform', program, index, bufSize, length, size, type, name);
  _glGetActiveUniform.sig = 'viiipppp';
  var _emscripten_glGetActiveUniform = _glGetActiveUniform;
  _emscripten_glGetActiveUniform.sig = 'viiipppp';

  /** @suppress {duplicate } */
  var _glGetActiveUniformBlockName = (program, uniformBlockIndex, bufSize, length, uniformBlockName) => {
      program = GL.programs[program];
  
      var result = GLctx.getActiveUniformBlockName(program, uniformBlockIndex);
      if (!result) return; // If an error occurs, nothing will be written to uniformBlockName or length.
      if (uniformBlockName && bufSize > 0) {
        var numBytesWrittenExclNull = stringToUTF8(result, uniformBlockName, bufSize);
        if (length) HEAP32[((length)>>2)] = numBytesWrittenExclNull;
      } else {
        if (length) HEAP32[((length)>>2)] = 0;
      }
    };
  _glGetActiveUniformBlockName.sig = 'viiipp';
  var _emscripten_glGetActiveUniformBlockName = _glGetActiveUniformBlockName;
  _emscripten_glGetActiveUniformBlockName.sig = 'viiipp';

  /** @suppress {duplicate } */
  var _glGetActiveUniformBlockiv = (program, uniformBlockIndex, pname, params) => {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if params == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      program = GL.programs[program];
  
      if (pname == 0x8A41 /* GL_UNIFORM_BLOCK_NAME_LENGTH */) {
        var name = GLctx.getActiveUniformBlockName(program, uniformBlockIndex);
        HEAP32[((params)>>2)] = name.length+1;
        return;
      }
  
      var result = GLctx.getActiveUniformBlockParameter(program, uniformBlockIndex, pname);
      if (result === null) return; // If an error occurs, nothing should be written to params.
      if (pname == 0x8A43 /*GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES*/) {
        for (var i = 0; i < result.length; i++) {
          HEAP32[(((params)+(i*4))>>2)] = result[i];
        }
      } else {
        HEAP32[((params)>>2)] = result;
      }
    };
  _glGetActiveUniformBlockiv.sig = 'viiip';
  var _emscripten_glGetActiveUniformBlockiv = _glGetActiveUniformBlockiv;
  _emscripten_glGetActiveUniformBlockiv.sig = 'viiip';

  /** @suppress {duplicate } */
  var _glGetActiveUniformsiv = (program, uniformCount, uniformIndices, pname, params) => {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if params == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      if (uniformCount > 0 && uniformIndices == 0) {
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      program = GL.programs[program];
      var ids = [];
      for (var i = 0; i < uniformCount; i++) {
        ids.push(HEAP32[(((uniformIndices)+(i*4))>>2)]);
      }
  
      var result = GLctx.getActiveUniforms(program, ids, pname);
      if (!result) return; // GL spec: If an error is generated, nothing is written out to params.
  
      var len = result.length;
      for (var i = 0; i < len; i++) {
        HEAP32[(((params)+(i*4))>>2)] = result[i];
      }
    };
  _glGetActiveUniformsiv.sig = 'viipip';
  var _emscripten_glGetActiveUniformsiv = _glGetActiveUniformsiv;
  _emscripten_glGetActiveUniformsiv.sig = 'viipip';

  /** @suppress {duplicate } */
  var _glGetAttachedShaders = (program, maxCount, count, shaders) => {
      var result = GLctx.getAttachedShaders(GL.programs[program]);
      var len = result.length;
      if (len > maxCount) {
        len = maxCount;
      }
      HEAP32[((count)>>2)] = len;
      for (var i = 0; i < len; ++i) {
        var id = GL.shaders.indexOf(result[i]);
        HEAP32[(((shaders)+(i*4))>>2)] = id;
      }
    };
  _glGetAttachedShaders.sig = 'viipp';
  var _emscripten_glGetAttachedShaders = _glGetAttachedShaders;
  _emscripten_glGetAttachedShaders.sig = 'viipp';

  
  /** @suppress {duplicate } */
  var _glGetAttribLocation = (program, name) =>
      GLctx.getAttribLocation(GL.programs[program], UTF8ToString(name));
  _glGetAttribLocation.sig = 'iip';
  var _emscripten_glGetAttribLocation = _glGetAttribLocation;
  _emscripten_glGetAttribLocation.sig = 'iip';

  var writeI53ToI64 = (ptr, num) => {
      HEAPU32[((ptr)>>2)] = num;
      var lower = HEAPU32[((ptr)>>2)];
      HEAPU32[(((ptr)+(4))>>2)] = (num - lower)/4294967296;
    };
  
  
  var webglGetExtensions = () => {
      var exts = getEmscriptenSupportedExtensions(GLctx);
      exts = exts.concat(exts.map((e) => "GL_" + e));
      return exts;
    };
  
  var emscriptenWebGLGet = (name_, p, type) => {
      // Guard against user passing a null pointer.
      // Note that GLES2 spec does not say anything about how passing a null
      // pointer should be treated.  Testing on desktop core GL 3, the application
      // crashes on glGetIntegerv to a null pointer, but better to report an error
      // instead of doing anything random.
      if (!p) {
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var ret = undefined;
      switch (name_) { // Handle a few trivial GLES values
        case 0x8DFA: // GL_SHADER_COMPILER
          ret = 1;
          break;
        case 0x8DF8: // GL_SHADER_BINARY_FORMATS
          if (type != 0 && type != 1) {
            GL.recordError(0x500); // GL_INVALID_ENUM
          }
          // Do not write anything to the out pointer, since no binary formats are
          // supported.
          return;
        case 0x87FE: // GL_NUM_PROGRAM_BINARY_FORMATS
        case 0x8DF9: // GL_NUM_SHADER_BINARY_FORMATS
          ret = 0;
          break;
        case 0x86A2: // GL_NUM_COMPRESSED_TEXTURE_FORMATS
          // WebGL doesn't have GL_NUM_COMPRESSED_TEXTURE_FORMATS (it's obsolete
          // since GL_COMPRESSED_TEXTURE_FORMATS returns a JS array that can be
          // queried for length), so implement it ourselves to allow C++ GLES2
          // code get the length.
          var formats = GLctx.getParameter(0x86A3 /*GL_COMPRESSED_TEXTURE_FORMATS*/);
          ret = formats ? formats.length : 0;
          break;
  
        case 0x821D: // GL_NUM_EXTENSIONS
          if (GL.currentContext.version < 2) {
            // Calling GLES3/WebGL2 function with a GLES2/WebGL1 context
            GL.recordError(0x502 /* GL_INVALID_OPERATION */);
            return;
          }
          ret = webglGetExtensions().length;
          break;
        case 0x821B: // GL_MAJOR_VERSION
        case 0x821C: // GL_MINOR_VERSION
          if (GL.currentContext.version < 2) {
            GL.recordError(0x500); // GL_INVALID_ENUM
            return;
          }
          ret = name_ == 0x821B ? 3 : 0; // return version 3.0
          break;
      }
  
      if (ret === undefined) {
        var result = GLctx.getParameter(name_);
        switch (typeof result) {
          case "number":
            ret = result;
            break;
          case "boolean":
            ret = result ? 1 : 0;
            break;
          case "string":
            GL.recordError(0x500); // GL_INVALID_ENUM
            return;
          case "object":
            if (result === null) {
              // null is a valid result for some (e.g., which buffer is bound -
              // perhaps nothing is bound), but otherwise can mean an invalid
              // name_, which we need to report as an error
              switch (name_) {
                case 0x8894: // ARRAY_BUFFER_BINDING
                case 0x8B8D: // CURRENT_PROGRAM
                case 0x8895: // ELEMENT_ARRAY_BUFFER_BINDING
                case 0x8CA6: // FRAMEBUFFER_BINDING or DRAW_FRAMEBUFFER_BINDING
                case 0x8CA7: // RENDERBUFFER_BINDING
                case 0x8069: // TEXTURE_BINDING_2D
                case 0x85B5: // WebGL 2 GL_VERTEX_ARRAY_BINDING, or WebGL 1 extension OES_vertex_array_object GL_VERTEX_ARRAY_BINDING_OES
                case 0x8F36: // COPY_READ_BUFFER_BINDING or COPY_READ_BUFFER
                case 0x8F37: // COPY_WRITE_BUFFER_BINDING or COPY_WRITE_BUFFER
                case 0x88ED: // PIXEL_PACK_BUFFER_BINDING
                case 0x88EF: // PIXEL_UNPACK_BUFFER_BINDING
                case 0x8CAA: // READ_FRAMEBUFFER_BINDING
                case 0x8919: // SAMPLER_BINDING
                case 0x8C1D: // TEXTURE_BINDING_2D_ARRAY
                case 0x806A: // TEXTURE_BINDING_3D
                case 0x8E25: // TRANSFORM_FEEDBACK_BINDING
                case 0x8C8F: // TRANSFORM_FEEDBACK_BUFFER_BINDING
                case 0x8A28: // UNIFORM_BUFFER_BINDING
                case 0x8514: { // TEXTURE_BINDING_CUBE_MAP
                  ret = 0;
                  break;
                }
                default: {
                  GL.recordError(0x500); // GL_INVALID_ENUM
                  return;
                }
              }
            } else if (result instanceof Float32Array ||
                       result instanceof Uint32Array ||
                       result instanceof Int32Array ||
                       result instanceof Array) {
              for (var i = 0; i < result.length; ++i) {
                switch (type) {
                  case 0: HEAP32[(((p)+(i*4))>>2)] = result[i]; break;
                  case 2: HEAPF32[(((p)+(i*4))>>2)] = result[i]; break;
                  case 4: HEAP8[(p)+(i)] = result[i] ? 1 : 0; break;
                }
              }
              return;
            } else {
              try {
                ret = result.name | 0;
              } catch(e) {
                GL.recordError(0x500); // GL_INVALID_ENUM
                err(`GL_INVALID_ENUM in glGet${type}v: Unknown object returned from WebGL getParameter(${name_})! (error: ${e})`);
                return;
              }
            }
            break;
          default:
            GL.recordError(0x500); // GL_INVALID_ENUM
            err(`GL_INVALID_ENUM in glGet${type}v: Native code calling glGet${type}v(${name_}) and it returns ${result} of type ${typeof(result)}!`);
            return;
        }
      }
  
      switch (type) {
        case 1: writeI53ToI64(p, ret); break;
        case 0: HEAP32[((p)>>2)] = ret; break;
        case 2:   HEAPF32[((p)>>2)] = ret; break;
        case 4: HEAP8[p] = ret ? 1 : 0; break;
      }
    };
  
  /** @suppress {duplicate } */
  var _glGetBooleanv = (name_, p) => emscriptenWebGLGet(name_, p, 4);
  _glGetBooleanv.sig = 'vip';
  var _emscripten_glGetBooleanv = _glGetBooleanv;
  _emscripten_glGetBooleanv.sig = 'vip';

  /** @suppress {duplicate } */
  var _glGetBufferParameteri64v = (target, value, data) => {
      if (!data) {
        // GLES2 specification does not specify how to behave if data is a null pointer. Since calling this function does not make sense
        // if data == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      writeI53ToI64(data, GLctx.getBufferParameter(target, value));
    };
  _glGetBufferParameteri64v.sig = 'viip';
  var _emscripten_glGetBufferParameteri64v = _glGetBufferParameteri64v;
  _emscripten_glGetBufferParameteri64v.sig = 'viip';

  /** @suppress {duplicate } */
  var _glGetBufferParameteriv = (target, value, data) => {
      if (!data) {
        // GLES2 specification does not specify how to behave if data is a null
        // pointer. Since calling this function does not make sense if data ==
        // null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((data)>>2)] = GLctx.getBufferParameter(target, value);
    };
  _glGetBufferParameteriv.sig = 'viip';
  var _emscripten_glGetBufferParameteriv = _glGetBufferParameteriv;
  _emscripten_glGetBufferParameteriv.sig = 'viip';

  
  /** @suppress {duplicate } */
  var _glGetBufferPointerv = (target, pname, params) => {
      if (pname == 0x88BD/*GL_BUFFER_MAP_POINTER*/) {
        var ptr = 0;
        var mappedBuffer = GL.mappedBuffers[emscriptenWebGLGetBufferBinding(target)];
        if (mappedBuffer) {
          ptr = mappedBuffer.mem;
        }
        HEAP32[((params)>>2)] = ptr;
      } else {
        GL.recordError(0x500/*GL_INVALID_ENUM*/);
        err('GL_INVALID_ENUM in glGetBufferPointerv');
      }
    };
  _glGetBufferPointerv.sig = 'viip';
  var _emscripten_glGetBufferPointerv = _glGetBufferPointerv;
  _emscripten_glGetBufferPointerv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glGetError = () => {
      var error = GLctx.getError() || GL.lastError;
      GL.lastError = 0/*GL_NO_ERROR*/;
      return error;
    };
  _glGetError.sig = 'i';
  var _emscripten_glGetError = _glGetError;
  _emscripten_glGetError.sig = 'i';

  
  /** @suppress {duplicate } */
  var _glGetFloatv = (name_, p) => emscriptenWebGLGet(name_, p, 2);
  _glGetFloatv.sig = 'vip';
  var _emscripten_glGetFloatv = _glGetFloatv;
  _emscripten_glGetFloatv.sig = 'vip';

  /** @suppress {duplicate } */
  var _glGetFragDataLocation = (program, name) => {
      return GLctx.getFragDataLocation(GL.programs[program], UTF8ToString(name));
    };
  _glGetFragDataLocation.sig = 'iip';
  var _emscripten_glGetFragDataLocation = _glGetFragDataLocation;
  _emscripten_glGetFragDataLocation.sig = 'iip';

  /** @suppress {duplicate } */
  var _glGetFramebufferAttachmentParameteriv = (target, attachment, pname, params) => {
      var result = GLctx.getFramebufferAttachmentParameter(target, attachment, pname);
      if (result instanceof WebGLRenderbuffer ||
          result instanceof WebGLTexture) {
        result = result.name | 0;
      }
      HEAP32[((params)>>2)] = result;
    };
  _glGetFramebufferAttachmentParameteriv.sig = 'viiip';
  var _emscripten_glGetFramebufferAttachmentParameteriv = _glGetFramebufferAttachmentParameteriv;
  _emscripten_glGetFramebufferAttachmentParameteriv.sig = 'viiip';

  var emscriptenWebGLGetIndexed = (target, index, data, type) => {
      if (!data) {
        // GLES2 specification does not specify how to behave if data is a null pointer. Since calling this function does not make sense
        // if data == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var result = GLctx.getIndexedParameter(target, index);
      var ret;
      switch (typeof result) {
        case 'boolean':
          ret = result ? 1 : 0;
          break;
        case 'number':
          ret = result;
          break;
        case 'object':
          if (result === null) {
            switch (target) {
              case 0x8C8F: // TRANSFORM_FEEDBACK_BUFFER_BINDING
              case 0x8A28: // UNIFORM_BUFFER_BINDING
                ret = 0;
                break;
              default: {
                GL.recordError(0x500); // GL_INVALID_ENUM
                return;
              }
            }
          } else if (result instanceof WebGLBuffer) {
            ret = result.name | 0;
          } else {
            GL.recordError(0x500); // GL_INVALID_ENUM
            return;
          }
          break;
        default:
          GL.recordError(0x500); // GL_INVALID_ENUM
          return;
      }
  
      switch (type) {
        case 1: writeI53ToI64(data, ret); break;
        case 0: HEAP32[((data)>>2)] = ret; break;
        case 2: HEAPF32[((data)>>2)] = ret; break;
        case 4: HEAP8[data] = ret ? 1 : 0; break;
        default: throw 'internal emscriptenWebGLGetIndexed() error, bad type: ' + type;
      }
    };
  /** @suppress {duplicate } */
  var _glGetInteger64i_v = (target, index, data) =>
      emscriptenWebGLGetIndexed(target, index, data, 1);
  _glGetInteger64i_v.sig = 'viip';
  var _emscripten_glGetInteger64i_v = _glGetInteger64i_v;
  _emscripten_glGetInteger64i_v.sig = 'viip';

  /** @suppress {duplicate } */
  var _glGetInteger64v = (name_, p) => {
      emscriptenWebGLGet(name_, p, 1);
    };
  _glGetInteger64v.sig = 'vip';
  var _emscripten_glGetInteger64v = _glGetInteger64v;
  _emscripten_glGetInteger64v.sig = 'vip';

  /** @suppress {duplicate } */
  var _glGetIntegeri_v = (target, index, data) =>
      emscriptenWebGLGetIndexed(target, index, data, 0);
  _glGetIntegeri_v.sig = 'viip';
  var _emscripten_glGetIntegeri_v = _glGetIntegeri_v;
  _emscripten_glGetIntegeri_v.sig = 'viip';

  
  /** @suppress {duplicate } */
  var _glGetIntegerv = (name_, p) => emscriptenWebGLGet(name_, p, 0);
  _glGetIntegerv.sig = 'vip';
  var _emscripten_glGetIntegerv = _glGetIntegerv;
  _emscripten_glGetIntegerv.sig = 'vip';

  /** @suppress {duplicate } */
  var _glGetInternalformativ = (target, internalformat, pname, bufSize, params) => {
      if (bufSize < 0) {
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      if (!params) {
        // GLES3 specification does not specify how to behave if values is a null pointer. Since calling this function does not make sense
        // if values == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var ret = GLctx.getInternalformatParameter(target, internalformat, pname);
      if (ret === null) return;
      for (var i = 0; i < ret.length && i < bufSize; ++i) {
        HEAP32[(((params)+(i*4))>>2)] = ret[i];
      }
    };
  _glGetInternalformativ.sig = 'viiiip';
  var _emscripten_glGetInternalformativ = _glGetInternalformativ;
  _emscripten_glGetInternalformativ.sig = 'viiiip';

  /** @suppress {duplicate } */
  var _glGetProgramBinary = (program, bufSize, length, binaryFormat, binary) => {
      GL.recordError(0x502/*GL_INVALID_OPERATION*/);
    };
  _glGetProgramBinary.sig = 'viippp';
  var _emscripten_glGetProgramBinary = _glGetProgramBinary;
  _emscripten_glGetProgramBinary.sig = 'viippp';

  /** @suppress {duplicate } */
  var _glGetProgramInfoLog = (program, maxLength, length, infoLog) => {
      var log = GLctx.getProgramInfoLog(GL.programs[program]);
      if (log === null) log = '(unknown error)';
      var numBytesWrittenExclNull = (maxLength > 0 && infoLog) ? stringToUTF8(log, infoLog, maxLength) : 0;
      if (length) HEAP32[((length)>>2)] = numBytesWrittenExclNull;
    };
  _glGetProgramInfoLog.sig = 'viipp';
  var _emscripten_glGetProgramInfoLog = _glGetProgramInfoLog;
  _emscripten_glGetProgramInfoLog.sig = 'viipp';

  /** @suppress {duplicate } */
  var _glGetProgramiv = (program, pname, p) => {
      if (!p) {
        // GLES2 specification does not specify how to behave if p is a null
        // pointer. Since calling this function does not make sense if p == null,
        // issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
  
      if (program >= GL.counter) {
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
  
      program = GL.programs[program];
  
      if (pname == 0x8B84) { // GL_INFO_LOG_LENGTH
        var log = GLctx.getProgramInfoLog(program);
        if (log === null) log = '(unknown error)';
        HEAP32[((p)>>2)] = log.length + 1;
      } else if (pname == 0x8B87 /* GL_ACTIVE_UNIFORM_MAX_LENGTH */) {
        if (!program.maxUniformLength) {
          var numActiveUniforms = GLctx.getProgramParameter(program, 0x8B86/*GL_ACTIVE_UNIFORMS*/);
          for (var i = 0; i < numActiveUniforms; ++i) {
            program.maxUniformLength = Math.max(program.maxUniformLength, GLctx.getActiveUniform(program, i).name.length+1);
          }
        }
        HEAP32[((p)>>2)] = program.maxUniformLength;
      } else if (pname == 0x8B8A /* GL_ACTIVE_ATTRIBUTE_MAX_LENGTH */) {
        if (!program.maxAttributeLength) {
          var numActiveAttributes = GLctx.getProgramParameter(program, 0x8B89/*GL_ACTIVE_ATTRIBUTES*/);
          for (var i = 0; i < numActiveAttributes; ++i) {
            program.maxAttributeLength = Math.max(program.maxAttributeLength, GLctx.getActiveAttrib(program, i).name.length+1);
          }
        }
        HEAP32[((p)>>2)] = program.maxAttributeLength;
      } else if (pname == 0x8A35 /* GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH */) {
        if (!program.maxUniformBlockNameLength) {
          var numActiveUniformBlocks = GLctx.getProgramParameter(program, 0x8A36/*GL_ACTIVE_UNIFORM_BLOCKS*/);
          for (var i = 0; i < numActiveUniformBlocks; ++i) {
            program.maxUniformBlockNameLength = Math.max(program.maxUniformBlockNameLength, GLctx.getActiveUniformBlockName(program, i).length+1);
          }
        }
        HEAP32[((p)>>2)] = program.maxUniformBlockNameLength;
      } else {
        HEAP32[((p)>>2)] = GLctx.getProgramParameter(program, pname);
      }
    };
  _glGetProgramiv.sig = 'viip';
  var _emscripten_glGetProgramiv = _glGetProgramiv;
  _emscripten_glGetProgramiv.sig = 'viip';

  
  /** @suppress {duplicate } */
  var _glGetQueryObjecti64vEXT = (id, pname, params) => {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var query = GL.queries[id];
      var param;
      if (GL.currentContext.version < 2)
      {
        param = GLctx.disjointTimerQueryExt['getQueryObjectEXT'](query, pname);
      }
      else {
        param = GLctx.getQueryParameter(query, pname);
      }
      var ret;
      if (typeof param == 'boolean') {
        ret = param ? 1 : 0;
      } else {
        ret = param;
      }
      writeI53ToI64(params, ret);
    };
  _glGetQueryObjecti64vEXT.sig = 'viip';
  var _emscripten_glGetQueryObjecti64vEXT = _glGetQueryObjecti64vEXT;

  /** @suppress {duplicate } */
  var _glGetQueryObjectivEXT = (id, pname, params) => {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var query = GL.queries[id];
      var param = GLctx.disjointTimerQueryExt['getQueryObjectEXT'](query, pname);
      var ret;
      if (typeof param == 'boolean') {
        ret = param ? 1 : 0;
      } else {
        ret = param;
      }
      HEAP32[((params)>>2)] = ret;
    };
  _glGetQueryObjectivEXT.sig = 'viip';
  var _emscripten_glGetQueryObjectivEXT = _glGetQueryObjectivEXT;

  
  /** @suppress {duplicate } */
  var _glGetQueryObjectui64vEXT = _glGetQueryObjecti64vEXT;
  var _emscripten_glGetQueryObjectui64vEXT = _glGetQueryObjectui64vEXT;

  /** @suppress {duplicate } */
  var _glGetQueryObjectuiv = (id, pname, params) => {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var query = GL.queries[id];
      var param = GLctx.getQueryParameter(query, pname);
      var ret;
      if (typeof param == 'boolean') {
        ret = param ? 1 : 0;
      } else {
        ret = param;
      }
      HEAP32[((params)>>2)] = ret;
    };
  _glGetQueryObjectuiv.sig = 'viip';
  var _emscripten_glGetQueryObjectuiv = _glGetQueryObjectuiv;
  _emscripten_glGetQueryObjectuiv.sig = 'viip';

  
  /** @suppress {duplicate } */
  var _glGetQueryObjectuivEXT = _glGetQueryObjectivEXT;
  var _emscripten_glGetQueryObjectuivEXT = _glGetQueryObjectuivEXT;

  /** @suppress {duplicate } */
  var _glGetQueryiv = (target, pname, params) => {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((params)>>2)] = GLctx.getQuery(target, pname);
    };
  _glGetQueryiv.sig = 'viip';
  var _emscripten_glGetQueryiv = _glGetQueryiv;
  _emscripten_glGetQueryiv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glGetQueryivEXT = (target, pname, params) => {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((params)>>2)] = GLctx.disjointTimerQueryExt['getQueryEXT'](target, pname);
    };
  _glGetQueryivEXT.sig = 'viip';
  var _emscripten_glGetQueryivEXT = _glGetQueryivEXT;

  /** @suppress {duplicate } */
  var _glGetRenderbufferParameteriv = (target, pname, params) => {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if params == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((params)>>2)] = GLctx.getRenderbufferParameter(target, pname);
    };
  _glGetRenderbufferParameteriv.sig = 'viip';
  var _emscripten_glGetRenderbufferParameteriv = _glGetRenderbufferParameteriv;
  _emscripten_glGetRenderbufferParameteriv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glGetSamplerParameterfv = (sampler, pname, params) => {
      if (!params) {
        // GLES3 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAPF32[((params)>>2)] = GLctx.getSamplerParameter(GL.samplers[sampler], pname);
    };
  _glGetSamplerParameterfv.sig = 'viip';
  var _emscripten_glGetSamplerParameterfv = _glGetSamplerParameterfv;
  _emscripten_glGetSamplerParameterfv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glGetSamplerParameteriv = (sampler, pname, params) => {
      if (!params) {
        // GLES3 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((params)>>2)] = GLctx.getSamplerParameter(GL.samplers[sampler], pname);
    };
  _glGetSamplerParameteriv.sig = 'viip';
  var _emscripten_glGetSamplerParameteriv = _glGetSamplerParameteriv;
  _emscripten_glGetSamplerParameteriv.sig = 'viip';

  
  /** @suppress {duplicate } */
  var _glGetShaderInfoLog = (shader, maxLength, length, infoLog) => {
      var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
      if (log === null) log = '(unknown error)';
      var numBytesWrittenExclNull = (maxLength > 0 && infoLog) ? stringToUTF8(log, infoLog, maxLength) : 0;
      if (length) HEAP32[((length)>>2)] = numBytesWrittenExclNull;
    };
  _glGetShaderInfoLog.sig = 'viipp';
  var _emscripten_glGetShaderInfoLog = _glGetShaderInfoLog;
  _emscripten_glGetShaderInfoLog.sig = 'viipp';

  /** @suppress {duplicate } */
  var _glGetShaderPrecisionFormat = (shaderType, precisionType, range, precision) => {
      var result = GLctx.getShaderPrecisionFormat(shaderType, precisionType);
      HEAP32[((range)>>2)] = result.rangeMin;
      HEAP32[(((range)+(4))>>2)] = result.rangeMax;
      HEAP32[((precision)>>2)] = result.precision;
    };
  _glGetShaderPrecisionFormat.sig = 'viipp';
  var _emscripten_glGetShaderPrecisionFormat = _glGetShaderPrecisionFormat;
  _emscripten_glGetShaderPrecisionFormat.sig = 'viipp';

  /** @suppress {duplicate } */
  var _glGetShaderSource = (shader, bufSize, length, source) => {
      var result = GLctx.getShaderSource(GL.shaders[shader]);
      if (!result) return; // If an error occurs, nothing will be written to length or source.
      var numBytesWrittenExclNull = (bufSize > 0 && source) ? stringToUTF8(result, source, bufSize) : 0;
      if (length) HEAP32[((length)>>2)] = numBytesWrittenExclNull;
    };
  _glGetShaderSource.sig = 'viipp';
  var _emscripten_glGetShaderSource = _glGetShaderSource;
  _emscripten_glGetShaderSource.sig = 'viipp';

  /** @suppress {duplicate } */
  var _glGetShaderiv = (shader, pname, p) => {
      if (!p) {
        // GLES2 specification does not specify how to behave if p is a null
        // pointer. Since calling this function does not make sense if p == null,
        // issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      if (pname == 0x8B84) { // GL_INFO_LOG_LENGTH
        var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
        if (log === null) log = '(unknown error)';
        // The GLES2 specification says that if the shader has an empty info log,
        // a value of 0 is returned. Otherwise the log has a null char appended.
        // (An empty string is falsey, so we can just check that instead of
        // looking at log.length.)
        var logLength = log ? log.length + 1 : 0;
        HEAP32[((p)>>2)] = logLength;
      } else if (pname == 0x8B88) { // GL_SHADER_SOURCE_LENGTH
        var source = GLctx.getShaderSource(GL.shaders[shader]);
        // source may be a null, or the empty string, both of which are falsey
        // values that we report a 0 length for.
        var sourceLength = source ? source.length + 1 : 0;
        HEAP32[((p)>>2)] = sourceLength;
      } else {
        HEAP32[((p)>>2)] = GLctx.getShaderParameter(GL.shaders[shader], pname);
      }
    };
  _glGetShaderiv.sig = 'viip';
  var _emscripten_glGetShaderiv = _glGetShaderiv;
  _emscripten_glGetShaderiv.sig = 'viip';

  
  
  /** @suppress {duplicate } */
  var _glGetString = (name_) => {
      var ret = GL.stringCache[name_];
      if (!ret) {
        switch (name_) {
          case 0x1F03 /* GL_EXTENSIONS */:
            ret = stringToNewUTF8(webglGetExtensions().join(' '));
            break;
          case 0x1F00 /* GL_VENDOR */:
          case 0x1F01 /* GL_RENDERER */:
          case 0x9245 /* UNMASKED_VENDOR_WEBGL */:
          case 0x9246 /* UNMASKED_RENDERER_WEBGL */:
            var s = GLctx.getParameter(name_);
            if (!s) {
              GL.recordError(0x500/*GL_INVALID_ENUM*/);
            }
            ret = s ? stringToNewUTF8(s) : 0;
            break;
  
          case 0x1F02 /* GL_VERSION */:
            var webGLVersion = GLctx.getParameter(0x1F02 /*GL_VERSION*/);
            // return GLES version string corresponding to the version of the WebGL context
            var glVersion = `OpenGL ES 2.0 (${webGLVersion})`;
            if (true) glVersion = `OpenGL ES 3.0 (${webGLVersion})`;
            ret = stringToNewUTF8(glVersion);
            break;
          case 0x8B8C /* GL_SHADING_LANGUAGE_VERSION */:
            var glslVersion = GLctx.getParameter(0x8B8C /*GL_SHADING_LANGUAGE_VERSION*/);
            // extract the version number 'N.M' from the string 'WebGL GLSL ES N.M ...'
            var ver_re = /^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/;
            var ver_num = glslVersion.match(ver_re);
            if (ver_num !== null) {
              if (ver_num[1].length == 3) ver_num[1] = ver_num[1] + '0'; // ensure minor version has 2 digits
              glslVersion = `OpenGL ES GLSL ES ${ver_num[1]} (${glslVersion})`;
            }
            ret = stringToNewUTF8(glslVersion);
            break;
          default:
            GL.recordError(0x500/*GL_INVALID_ENUM*/);
            // fall through
        }
        GL.stringCache[name_] = ret;
      }
      return ret;
    };
  _glGetString.sig = 'pi';
  var _emscripten_glGetString = _glGetString;
  _emscripten_glGetString.sig = 'pi';

  
  /** @suppress {duplicate } */
  var _glGetStringi = (name, index) => {
      if (GL.currentContext.version < 2) {
        GL.recordError(0x502 /* GL_INVALID_OPERATION */); // Calling GLES3/WebGL2 function with a GLES2/WebGL1 context
        return 0;
      }
      var stringiCache = GL.stringiCache[name];
      if (stringiCache) {
        if (index < 0 || index >= stringiCache.length) {
          GL.recordError(0x501/*GL_INVALID_VALUE*/);
          return 0;
        }
        return stringiCache[index];
      }
      switch (name) {
        case 0x1F03 /* GL_EXTENSIONS */:
          var exts = webglGetExtensions().map(stringToNewUTF8);
          stringiCache = GL.stringiCache[name] = exts;
          if (index < 0 || index >= stringiCache.length) {
            GL.recordError(0x501/*GL_INVALID_VALUE*/);
            return 0;
          }
          return stringiCache[index];
        default:
          GL.recordError(0x500/*GL_INVALID_ENUM*/);
          return 0;
      }
    };
  _glGetStringi.sig = 'pii';
  var _emscripten_glGetStringi = _glGetStringi;
  _emscripten_glGetStringi.sig = 'pii';

  /** @suppress {duplicate } */
  var _glGetSynciv = (sync, pname, bufSize, length, values) => {
      if (bufSize < 0) {
        // GLES3 specification does not specify how to behave if bufSize < 0, however in the spec wording for glGetInternalformativ, it does say that GL_INVALID_VALUE should be raised,
        // so raise GL_INVALID_VALUE here as well.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      if (!values) {
        // GLES3 specification does not specify how to behave if values is a null pointer. Since calling this function does not make sense
        // if values == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var ret = GLctx.getSyncParameter(GL.syncs[sync], pname);
      if (ret !== null) {
        HEAP32[((values)>>2)] = ret;
        if (length) HEAP32[((length)>>2)] = 1; // Report a single value outputted.
      }
    };
  _glGetSynciv.sig = 'vpiipp';
  var _emscripten_glGetSynciv = _glGetSynciv;
  _emscripten_glGetSynciv.sig = 'vpiipp';

  /** @suppress {duplicate } */
  var _glGetTexParameterfv = (target, pname, params) => {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null
        // pointer. Since calling this function does not make sense if p == null,
        // issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAPF32[((params)>>2)] = GLctx.getTexParameter(target, pname);
    };
  _glGetTexParameterfv.sig = 'viip';
  var _emscripten_glGetTexParameterfv = _glGetTexParameterfv;
  _emscripten_glGetTexParameterfv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glGetTexParameteriv = (target, pname, params) => {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null
        // pointer. Since calling this function does not make sense if p == null,
        // issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((params)>>2)] = GLctx.getTexParameter(target, pname);
    };
  _glGetTexParameteriv.sig = 'viip';
  var _emscripten_glGetTexParameteriv = _glGetTexParameteriv;
  _emscripten_glGetTexParameteriv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glGetTransformFeedbackVarying = (program, index, bufSize, length, size, type, name) => {
      program = GL.programs[program];
      var info = GLctx.getTransformFeedbackVarying(program, index);
      if (!info) return; // If an error occurred, the return parameters length, size, type and name will be unmodified.
  
      if (name && bufSize > 0) {
        var numBytesWrittenExclNull = stringToUTF8(info.name, name, bufSize);
        if (length) HEAP32[((length)>>2)] = numBytesWrittenExclNull;
      } else {
        if (length) HEAP32[((length)>>2)] = 0;
      }
  
      if (size) HEAP32[((size)>>2)] = info.size;
      if (type) HEAP32[((type)>>2)] = info.type;
    };
  _glGetTransformFeedbackVarying.sig = 'viiipppp';
  var _emscripten_glGetTransformFeedbackVarying = _glGetTransformFeedbackVarying;
  _emscripten_glGetTransformFeedbackVarying.sig = 'viiipppp';

  /** @suppress {duplicate } */
  var _glGetUniformBlockIndex = (program, uniformBlockName) => {
      return GLctx.getUniformBlockIndex(GL.programs[program], UTF8ToString(uniformBlockName));
    };
  _glGetUniformBlockIndex.sig = 'iip';
  var _emscripten_glGetUniformBlockIndex = _glGetUniformBlockIndex;
  _emscripten_glGetUniformBlockIndex.sig = 'iip';

  /** @suppress {duplicate } */
  var _glGetUniformIndices = (program, uniformCount, uniformNames, uniformIndices) => {
      if (!uniformIndices) {
        // GLES2 specification does not specify how to behave if uniformIndices is a null pointer. Since calling this function does not make sense
        // if uniformIndices == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      if (uniformCount > 0 && (uniformNames == 0 || uniformIndices == 0)) {
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      program = GL.programs[program];
      var names = [];
      for (var i = 0; i < uniformCount; i++)
        names.push(UTF8ToString(HEAP32[(((uniformNames)+(i*4))>>2)]));
  
      var result = GLctx.getUniformIndices(program, names);
      if (!result) return; // GL spec: If an error is generated, nothing is written out to uniformIndices.
  
      var len = result.length;
      for (var i = 0; i < len; i++) {
        HEAP32[(((uniformIndices)+(i*4))>>2)] = result[i];
      }
    };
  _glGetUniformIndices.sig = 'viipp';
  var _emscripten_glGetUniformIndices = _glGetUniformIndices;
  _emscripten_glGetUniformIndices.sig = 'viipp';

  
  /** @noinline */
  var webglGetLeftBracePos = (name) => name.slice(-1) == ']' && name.lastIndexOf('[');
  
  var webglPrepareUniformLocationsBeforeFirstUse = (program) => {
      var uniformLocsById = program.uniformLocsById, // Maps GLuint -> WebGLUniformLocation
        uniformSizeAndIdsByName = program.uniformSizeAndIdsByName, // Maps name -> [uniform array length, GLuint]
        i, j;
  
      // On the first time invocation of glGetUniformLocation on this shader program:
      // initialize cache data structures and discover which uniforms are arrays.
      if (!uniformLocsById) {
        // maps GLint integer locations to WebGLUniformLocations
        program.uniformLocsById = uniformLocsById = {};
        // maps integer locations back to uniform name strings, so that we can lazily fetch uniform array locations
        program.uniformArrayNamesById = {};
  
        var numActiveUniforms = GLctx.getProgramParameter(program, 0x8B86/*GL_ACTIVE_UNIFORMS*/);
        for (i = 0; i < numActiveUniforms; ++i) {
          var u = GLctx.getActiveUniform(program, i);
          var nm = u.name;
          var sz = u.size;
          var lb = webglGetLeftBracePos(nm);
          var arrayName = lb > 0 ? nm.slice(0, lb) : nm;
  
          // Assign a new location.
          var id = program.uniformIdCounter;
          program.uniformIdCounter += sz;
          // Eagerly get the location of the uniformArray[0] base element.
          // The remaining indices >0 will be left for lazy evaluation to
          // improve performance. Those may never be needed to fetch, if the
          // application fills arrays always in full starting from the first
          // element of the array.
          uniformSizeAndIdsByName[arrayName] = [sz, id];
  
          // Store placeholder integers in place that highlight that these
          // >0 index locations are array indices pending population.
          for (j = 0; j < sz; ++j) {
            uniformLocsById[id] = j;
            program.uniformArrayNamesById[id++] = arrayName;
          }
        }
      }
    };
  
  
  
  /** @suppress {duplicate } */
  var _glGetUniformLocation = (program, name) => {
  
      name = UTF8ToString(name);
  
      if (program = GL.programs[program]) {
        webglPrepareUniformLocationsBeforeFirstUse(program);
        var uniformLocsById = program.uniformLocsById; // Maps GLuint -> WebGLUniformLocation
        var arrayIndex = 0;
        var uniformBaseName = name;
  
        // Invariant: when populating integer IDs for uniform locations, we must
        // maintain the precondition that arrays reside in contiguous addresses,
        // i.e. for a 'vec4 colors[10];', colors[4] must be at location
        // colors[0]+4.  However, user might call glGetUniformLocation(program,
        // "colors") for an array, so we cannot discover based on the user input
        // arguments whether the uniform we are dealing with is an array. The only
        // way to discover which uniforms are arrays is to enumerate over all the
        // active uniforms in the program.
        var leftBrace = webglGetLeftBracePos(name);
  
        // If user passed an array accessor "[index]", parse the array index off the accessor.
        if (leftBrace > 0) {
          arrayIndex = jstoi_q(name.slice(leftBrace + 1)) >>> 0; // "index]", coerce parseInt(']') with >>>0 to treat "foo[]" as "foo[0]" and foo[-1] as unsigned out-of-bounds.
          uniformBaseName = name.slice(0, leftBrace);
        }
  
        // Have we cached the location of this uniform before?
        // A pair [array length, GLint of the uniform location]
        var sizeAndId = program.uniformSizeAndIdsByName[uniformBaseName];
  
        // If an uniform with this name exists, and if its index is within the
        // array limits (if it's even an array), query the WebGLlocation, or
        // return an existing cached location.
        if (sizeAndId && arrayIndex < sizeAndId[0]) {
          arrayIndex += sizeAndId[1]; // Add the base location of the uniform to the array index offset.
          if ((uniformLocsById[arrayIndex] = uniformLocsById[arrayIndex] || GLctx.getUniformLocation(program, name))) {
            return arrayIndex;
          }
        }
      }
      else {
        // N.b. we are currently unable to distinguish between GL program IDs that
        // never existed vs GL program IDs that have been deleted, so report
        // GL_INVALID_VALUE in both cases.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
      }
      return -1;
    };
  _glGetUniformLocation.sig = 'iip';
  var _emscripten_glGetUniformLocation = _glGetUniformLocation;
  _emscripten_glGetUniformLocation.sig = 'iip';

  var webglGetUniformLocation = (location) => {
      var p = GLctx.currentProgram;
  
      if (p) {
        var webglLoc = p.uniformLocsById[location];
        // p.uniformLocsById[location] stores either an integer, or a
        // WebGLUniformLocation.
        // If an integer, we have not yet bound the location, so do it now. The
        // integer value specifies the array index we should bind to.
        if (typeof webglLoc == 'number') {
          p.uniformLocsById[location] = webglLoc = GLctx.getUniformLocation(p, p.uniformArrayNamesById[location] + (webglLoc > 0 ? `[${webglLoc}]` : ''));
        }
        // Else an already cached WebGLUniformLocation, return it.
        return webglLoc;
      } else {
        GL.recordError(0x502/*GL_INVALID_OPERATION*/);
      }
    };
  
  
  /** @suppress{checkTypes} */
  var emscriptenWebGLGetUniform = (program, location, params, type) => {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null
        // pointer. Since calling this function does not make sense if params ==
        // null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      program = GL.programs[program];
      webglPrepareUniformLocationsBeforeFirstUse(program);
      var data = GLctx.getUniform(program, webglGetUniformLocation(location));
      if (typeof data == 'number' || typeof data == 'boolean') {
        switch (type) {
          case 0: HEAP32[((params)>>2)] = data; break;
          case 2: HEAPF32[((params)>>2)] = data; break;
        }
      } else {
        for (var i = 0; i < data.length; i++) {
          switch (type) {
            case 0: HEAP32[(((params)+(i*4))>>2)] = data[i]; break;
            case 2: HEAPF32[(((params)+(i*4))>>2)] = data[i]; break;
          }
        }
      }
    };
  
  /** @suppress {duplicate } */
  var _glGetUniformfv = (program, location, params) => {
      emscriptenWebGLGetUniform(program, location, params, 2);
    };
  _glGetUniformfv.sig = 'viip';
  var _emscripten_glGetUniformfv = _glGetUniformfv;
  _emscripten_glGetUniformfv.sig = 'viip';

  
  /** @suppress {duplicate } */
  var _glGetUniformiv = (program, location, params) => {
      emscriptenWebGLGetUniform(program, location, params, 0);
    };
  _glGetUniformiv.sig = 'viip';
  var _emscripten_glGetUniformiv = _glGetUniformiv;
  _emscripten_glGetUniformiv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glGetUniformuiv = (program, location, params) =>
      emscriptenWebGLGetUniform(program, location, params, 0);
  _glGetUniformuiv.sig = 'viip';
  var _emscripten_glGetUniformuiv = _glGetUniformuiv;
  _emscripten_glGetUniformuiv.sig = 'viip';

  /** @suppress{checkTypes} */
  var emscriptenWebGLGetVertexAttrib = (index, pname, params, type) => {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null
        // pointer. Since calling this function does not make sense if params ==
        // null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      if (GL.currentContext.clientBuffers[index].enabled) {
        err("glGetVertexAttrib*v on client-side array: not supported, bad data returned");
      }
      var data = GLctx.getVertexAttrib(index, pname);
      if (pname == 0x889F/*VERTEX_ATTRIB_ARRAY_BUFFER_BINDING*/) {
        HEAP32[((params)>>2)] = data && data["name"];
      } else if (typeof data == 'number' || typeof data == 'boolean') {
        switch (type) {
          case 0: HEAP32[((params)>>2)] = data; break;
          case 2: HEAPF32[((params)>>2)] = data; break;
          case 5: HEAP32[((params)>>2)] = Math.fround(data); break;
        }
      } else {
        for (var i = 0; i < data.length; i++) {
          switch (type) {
            case 0: HEAP32[(((params)+(i*4))>>2)] = data[i]; break;
            case 2: HEAPF32[(((params)+(i*4))>>2)] = data[i]; break;
            case 5: HEAP32[(((params)+(i*4))>>2)] = Math.fround(data[i]); break;
          }
        }
      }
    };
  /** @suppress {duplicate } */
  var _glGetVertexAttribIiv = (index, pname, params) => {
      // N.B. This function may only be called if the vertex attribute was specified using the function glVertexAttribI4iv(),
      // otherwise the results are undefined. (GLES3 spec 6.1.12)
      emscriptenWebGLGetVertexAttrib(index, pname, params, 0);
    };
  _glGetVertexAttribIiv.sig = 'viip';
  var _emscripten_glGetVertexAttribIiv = _glGetVertexAttribIiv;
  _emscripten_glGetVertexAttribIiv.sig = 'viip';

  
  /** @suppress {duplicate } */
  var _glGetVertexAttribIuiv = _glGetVertexAttribIiv;
  _glGetVertexAttribIuiv.sig = 'viip';
  var _emscripten_glGetVertexAttribIuiv = _glGetVertexAttribIuiv;
  _emscripten_glGetVertexAttribIuiv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glGetVertexAttribPointerv = (index, pname, pointer) => {
      if (!pointer) {
        // GLES2 specification does not specify how to behave if pointer is a null
        // pointer. Since calling this function does not make sense if pointer ==
        // null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      if (GL.currentContext.clientBuffers[index].enabled) {
        err("glGetVertexAttribPointer on client-side array: not supported, bad data returned");
      }
      HEAP32[((pointer)>>2)] = GLctx.getVertexAttribOffset(index, pname);
    };
  _glGetVertexAttribPointerv.sig = 'viip';
  var _emscripten_glGetVertexAttribPointerv = _glGetVertexAttribPointerv;
  _emscripten_glGetVertexAttribPointerv.sig = 'viip';

  
  /** @suppress {duplicate } */
  var _glGetVertexAttribfv = (index, pname, params) => {
      // N.B. This function may only be called if the vertex attribute was
      // specified using the function glVertexAttrib*f(), otherwise the results
      // are undefined. (GLES3 spec 6.1.12)
      emscriptenWebGLGetVertexAttrib(index, pname, params, 2);
    };
  _glGetVertexAttribfv.sig = 'viip';
  var _emscripten_glGetVertexAttribfv = _glGetVertexAttribfv;
  _emscripten_glGetVertexAttribfv.sig = 'viip';

  
  /** @suppress {duplicate } */
  var _glGetVertexAttribiv = (index, pname, params) => {
      // N.B. This function may only be called if the vertex attribute was
      // specified using the function glVertexAttrib*f(), otherwise the results
      // are undefined. (GLES3 spec 6.1.12)
      emscriptenWebGLGetVertexAttrib(index, pname, params, 5);
    };
  _glGetVertexAttribiv.sig = 'viip';
  var _emscripten_glGetVertexAttribiv = _glGetVertexAttribiv;
  _emscripten_glGetVertexAttribiv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glHint = (x0, x1) => GLctx.hint(x0, x1);
  _glHint.sig = 'vii';
  var _emscripten_glHint = _glHint;
  _emscripten_glHint.sig = 'vii';

  /** @suppress {duplicate } */
  var _glInvalidateFramebuffer = (target, numAttachments, attachments) => {
      var list = tempFixedLengthArray[numAttachments];
      for (var i = 0; i < numAttachments; i++) {
        list[i] = HEAP32[(((attachments)+(i*4))>>2)];
      }
  
      GLctx.invalidateFramebuffer(target, list);
    };
  _glInvalidateFramebuffer.sig = 'viip';
  var _emscripten_glInvalidateFramebuffer = _glInvalidateFramebuffer;
  _emscripten_glInvalidateFramebuffer.sig = 'viip';

  /** @suppress {duplicate } */
  var _glInvalidateSubFramebuffer = (target, numAttachments, attachments, x, y, width, height) => {
      var list = tempFixedLengthArray[numAttachments];
      for (var i = 0; i < numAttachments; i++) {
        list[i] = HEAP32[(((attachments)+(i*4))>>2)];
      }
  
      GLctx.invalidateSubFramebuffer(target, list, x, y, width, height);
    };
  _glInvalidateSubFramebuffer.sig = 'viipiiii';
  var _emscripten_glInvalidateSubFramebuffer = _glInvalidateSubFramebuffer;
  _emscripten_glInvalidateSubFramebuffer.sig = 'viipiiii';

  /** @suppress {duplicate } */
  var _glIsBuffer = (buffer) => {
      var b = GL.buffers[buffer];
      if (!b) return 0;
      return GLctx.isBuffer(b);
    };
  _glIsBuffer.sig = 'ii';
  var _emscripten_glIsBuffer = _glIsBuffer;
  _emscripten_glIsBuffer.sig = 'ii';

  /** @suppress {duplicate } */
  var _glIsEnabled = (x0) => GLctx.isEnabled(x0);
  _glIsEnabled.sig = 'ii';
  var _emscripten_glIsEnabled = _glIsEnabled;
  _emscripten_glIsEnabled.sig = 'ii';

  /** @suppress {duplicate } */
  var _glIsFramebuffer = (framebuffer) => {
      var fb = GL.framebuffers[framebuffer];
      if (!fb) return 0;
      return GLctx.isFramebuffer(fb);
    };
  _glIsFramebuffer.sig = 'ii';
  var _emscripten_glIsFramebuffer = _glIsFramebuffer;
  _emscripten_glIsFramebuffer.sig = 'ii';

  /** @suppress {duplicate } */
  var _glIsProgram = (program) => {
      program = GL.programs[program];
      if (!program) return 0;
      return GLctx.isProgram(program);
    };
  _glIsProgram.sig = 'ii';
  var _emscripten_glIsProgram = _glIsProgram;
  _emscripten_glIsProgram.sig = 'ii';

  /** @suppress {duplicate } */
  var _glIsQuery = (id) => {
      var query = GL.queries[id];
      if (!query) return 0;
      return GLctx.isQuery(query);
    };
  _glIsQuery.sig = 'ii';
  var _emscripten_glIsQuery = _glIsQuery;
  _emscripten_glIsQuery.sig = 'ii';

  /** @suppress {duplicate } */
  var _glIsQueryEXT = (id) => {
      var query = GL.queries[id];
      if (!query) return 0;
      return GLctx.disjointTimerQueryExt['isQueryEXT'](query);
    };
  _glIsQueryEXT.sig = 'ii';
  var _emscripten_glIsQueryEXT = _glIsQueryEXT;

  /** @suppress {duplicate } */
  var _glIsRenderbuffer = (renderbuffer) => {
      var rb = GL.renderbuffers[renderbuffer];
      if (!rb) return 0;
      return GLctx.isRenderbuffer(rb);
    };
  _glIsRenderbuffer.sig = 'ii';
  var _emscripten_glIsRenderbuffer = _glIsRenderbuffer;
  _emscripten_glIsRenderbuffer.sig = 'ii';

  /** @suppress {duplicate } */
  var _glIsSampler = (id) => {
      var sampler = GL.samplers[id];
      if (!sampler) return 0;
      return GLctx.isSampler(sampler);
    };
  _glIsSampler.sig = 'ii';
  var _emscripten_glIsSampler = _glIsSampler;
  _emscripten_glIsSampler.sig = 'ii';

  /** @suppress {duplicate } */
  var _glIsShader = (shader) => {
      var s = GL.shaders[shader];
      if (!s) return 0;
      return GLctx.isShader(s);
    };
  _glIsShader.sig = 'ii';
  var _emscripten_glIsShader = _glIsShader;
  _emscripten_glIsShader.sig = 'ii';

  /** @suppress {duplicate } */
  var _glIsSync = (sync) => GLctx.isSync(GL.syncs[sync]);
  _glIsSync.sig = 'ip';
  var _emscripten_glIsSync = _glIsSync;
  _emscripten_glIsSync.sig = 'ip';

  /** @suppress {duplicate } */
  var _glIsTexture = (id) => {
      var texture = GL.textures[id];
      if (!texture) return 0;
      return GLctx.isTexture(texture);
    };
  _glIsTexture.sig = 'ii';
  var _emscripten_glIsTexture = _glIsTexture;
  _emscripten_glIsTexture.sig = 'ii';

  /** @suppress {duplicate } */
  var _glIsTransformFeedback = (id) => GLctx.isTransformFeedback(GL.transformFeedbacks[id]);
  _glIsTransformFeedback.sig = 'ii';
  var _emscripten_glIsTransformFeedback = _glIsTransformFeedback;
  _emscripten_glIsTransformFeedback.sig = 'ii';

  /** @suppress {duplicate } */
  var _glIsVertexArray = (array) => {
  
      var vao = GL.vaos[array];
      if (!vao) return 0;
      return GLctx.isVertexArray(vao);
    };
  _glIsVertexArray.sig = 'ii';
  var _emscripten_glIsVertexArray = _glIsVertexArray;
  _emscripten_glIsVertexArray.sig = 'ii';

  
  /** @suppress {duplicate } */
  var _glIsVertexArrayOES = _glIsVertexArray;
  _glIsVertexArrayOES.sig = 'ii';
  var _emscripten_glIsVertexArrayOES = _glIsVertexArrayOES;
  _emscripten_glIsVertexArrayOES.sig = 'ii';

  /** @suppress {duplicate } */
  var _glLineWidth = (x0) => GLctx.lineWidth(x0);
  _glLineWidth.sig = 'vf';
  var _emscripten_glLineWidth = _glLineWidth;
  _emscripten_glLineWidth.sig = 'vf';

  /** @suppress {duplicate } */
  var _glLinkProgram = (program) => {
      program = GL.programs[program];
      GLctx.linkProgram(program);
      // Invalidate earlier computed uniform->ID mappings, those have now become stale
      program.uniformLocsById = 0; // Mark as null-like so that glGetUniformLocation() knows to populate this again.
      program.uniformSizeAndIdsByName = {};
  
    };
  _glLinkProgram.sig = 'vi';
  var _emscripten_glLinkProgram = _glLinkProgram;
  _emscripten_glLinkProgram.sig = 'vi';

  
  
  
  /** @suppress {duplicate } */
  var _glMapBufferRange = (target, offset, length, access) => {
      if ((access & (0x1/*GL_MAP_READ_BIT*/ | 0x20/*GL_MAP_UNSYNCHRONIZED_BIT*/)) != 0) {
        err("glMapBufferRange access does not support MAP_READ or MAP_UNSYNCHRONIZED");
        return 0;
      }
  
      if ((access & 0x2/*GL_MAP_WRITE_BIT*/) == 0) {
        err("glMapBufferRange access must include MAP_WRITE");
        return 0;
      }
  
      if ((access & (0x4/*GL_MAP_INVALIDATE_BUFFER_BIT*/ | 0x8/*GL_MAP_INVALIDATE_RANGE_BIT*/)) == 0) {
        err("glMapBufferRange access must include INVALIDATE_BUFFER or INVALIDATE_RANGE");
        return 0;
      }
  
      if (!emscriptenWebGLValidateMapBufferTarget(target)) {
        GL.recordError(0x500/*GL_INVALID_ENUM*/);
        err('GL_INVALID_ENUM in glMapBufferRange');
        return 0;
      }
  
      var mem = _malloc(length), binding = emscriptenWebGLGetBufferBinding(target);
      if (!mem) return 0;
  
      binding = GL.mappedBuffers[binding] ??= {};
      binding.offset = offset;
      binding.length = length;
      binding.mem = mem;
      binding.access = access;
      return mem;
    };
  _glMapBufferRange.sig = 'pippi';
  var _emscripten_glMapBufferRange = _glMapBufferRange;
  _emscripten_glMapBufferRange.sig = 'pippi';

  /** @suppress {duplicate } */
  var _glPauseTransformFeedback = () => GLctx.pauseTransformFeedback();
  _glPauseTransformFeedback.sig = 'v';
  var _emscripten_glPauseTransformFeedback = _glPauseTransformFeedback;
  _emscripten_glPauseTransformFeedback.sig = 'v';

  /** @suppress {duplicate } */
  var _glPixelStorei = (pname, param) => {
      if (pname == 3317) {
        GL.unpackAlignment = param;
      } else if (pname == 3314) {
        GL.unpackRowLength = param;
      }
      GLctx.pixelStorei(pname, param);
    };
  _glPixelStorei.sig = 'vii';
  var _emscripten_glPixelStorei = _glPixelStorei;
  _emscripten_glPixelStorei.sig = 'vii';

  /** @suppress {duplicate } */
  var _glPolygonModeWEBGL = (face, mode) => {
      GLctx.webglPolygonMode['polygonModeWEBGL'](face, mode);
    };
  _glPolygonModeWEBGL.sig = 'vii';
  var _emscripten_glPolygonModeWEBGL = _glPolygonModeWEBGL;

  /** @suppress {duplicate } */
  var _glPolygonOffset = (x0, x1) => GLctx.polygonOffset(x0, x1);
  _glPolygonOffset.sig = 'vff';
  var _emscripten_glPolygonOffset = _glPolygonOffset;
  _emscripten_glPolygonOffset.sig = 'vff';

  /** @suppress {duplicate } */
  var _glPolygonOffsetClampEXT = (factor, units, clamp) => {
      GLctx.extPolygonOffsetClamp['polygonOffsetClampEXT'](factor, units, clamp);
    };
  _glPolygonOffsetClampEXT.sig = 'vfff';
  var _emscripten_glPolygonOffsetClampEXT = _glPolygonOffsetClampEXT;

  /** @suppress {duplicate } */
  var _glProgramBinary = (program, binaryFormat, binary, length) => {
      GL.recordError(0x500/*GL_INVALID_ENUM*/);
    };
  _glProgramBinary.sig = 'viipi';
  var _emscripten_glProgramBinary = _glProgramBinary;
  _emscripten_glProgramBinary.sig = 'viipi';

  /** @suppress {duplicate } */
  var _glProgramParameteri = (program, pname, value) => {
      GL.recordError(0x500/*GL_INVALID_ENUM*/);
    };
  _glProgramParameteri.sig = 'viii';
  var _emscripten_glProgramParameteri = _glProgramParameteri;
  _emscripten_glProgramParameteri.sig = 'viii';

  /** @suppress {duplicate } */
  var _glQueryCounterEXT = (id, target) => {
      GLctx.disjointTimerQueryExt['queryCounterEXT'](GL.queries[id], target);
    };
  _glQueryCounterEXT.sig = 'vii';
  var _emscripten_glQueryCounterEXT = _glQueryCounterEXT;

  /** @suppress {duplicate } */
  var _glReadBuffer = (x0) => GLctx.readBuffer(x0);
  _glReadBuffer.sig = 'vi';
  var _emscripten_glReadBuffer = _glReadBuffer;
  _emscripten_glReadBuffer.sig = 'vi';

  var computeUnpackAlignedImageSize = (width, height, sizePerPixel) => {
      function roundedToNextMultipleOf(x, y) {
        return (x + y - 1) & -y;
      }
      var plainRowSize = (GL.unpackRowLength || width) * sizePerPixel;
      var alignedRowSize = roundedToNextMultipleOf(plainRowSize, GL.unpackAlignment);
      return height * alignedRowSize;
    };
  
  var colorChannelsInGlTextureFormat = (format) => {
      // Micro-optimizations for size: map format to size by subtracting smallest
      // enum value (0x1902) from all values first.  Also omit the most common
      // size value (1) from the list, which is assumed by formats not on the
      // list.
      var colorChannels = {
        // 0x1902 /* GL_DEPTH_COMPONENT */ - 0x1902: 1,
        // 0x1906 /* GL_ALPHA */ - 0x1902: 1,
        5: 3,
        6: 4,
        // 0x1909 /* GL_LUMINANCE */ - 0x1902: 1,
        8: 2,
        29502: 3,
        29504: 4,
        // 0x1903 /* GL_RED */ - 0x1902: 1,
        26917: 2,
        26918: 2,
        // 0x8D94 /* GL_RED_INTEGER */ - 0x1902: 1,
        29846: 3,
        29847: 4
      };
      return colorChannels[format - 0x1902]||1;
    };
  
  var heapObjectForWebGLType = (type) => {
      // Micro-optimization for size: Subtract lowest GL enum number (0x1400/* GL_BYTE */) from type to compare
      // smaller values for the heap, for shorter generated code size.
      // Also the type HEAPU16 is not tested for explicitly, but any unrecognized type will return out HEAPU16.
      // (since most types are HEAPU16)
      type -= 0x1400;
      if (type == 0) return HEAP8;
  
      if (type == 1) return HEAPU8;
  
      if (type == 2) return HEAP16;
  
      if (type == 4) return HEAP32;
  
      if (type == 6) return HEAPF32;
  
      if (type == 5
        || type == 28922
        || type == 28520
        || type == 30779
        || type == 30782
        )
        return HEAPU32;
  
      return HEAPU16;
    };
  
  var toTypedArrayIndex = (pointer, heap) =>
      pointer >>> (31 - Math.clz32(heap.BYTES_PER_ELEMENT));
  
  var emscriptenWebGLGetTexPixelData = (type, format, width, height, pixels, internalFormat) => {
      var heap = heapObjectForWebGLType(type);
      var sizePerPixel = colorChannelsInGlTextureFormat(format) * heap.BYTES_PER_ELEMENT;
      var bytes = computeUnpackAlignedImageSize(width, height, sizePerPixel);
      return heap.subarray(toTypedArrayIndex(pixels, heap), toTypedArrayIndex(pixels + bytes, heap));
    };
  
  
  
  /** @suppress {duplicate } */
  var _glReadPixels = (x, y, width, height, format, type, pixels) => {
      if (true) {
        if (GLctx.currentPixelPackBufferBinding) {
          GLctx.readPixels(x, y, width, height, format, type, pixels);
          return;
        }
        var heap = heapObjectForWebGLType(type);
        var target = toTypedArrayIndex(pixels, heap);
        GLctx.readPixels(x, y, width, height, format, type, heap, target);
        return;
      }
    };
  _glReadPixels.sig = 'viiiiiip';
  var _emscripten_glReadPixels = _glReadPixels;
  _emscripten_glReadPixels.sig = 'viiiiiip';

  /** @suppress {duplicate } */
  var _glReleaseShaderCompiler = () => {
      // NOP (as allowed by GLES 2.0 spec)
    };
  _glReleaseShaderCompiler.sig = 'v';
  var _emscripten_glReleaseShaderCompiler = _glReleaseShaderCompiler;
  _emscripten_glReleaseShaderCompiler.sig = 'v';

  /** @suppress {duplicate } */
  var _glRenderbufferStorage = (x0, x1, x2, x3) => GLctx.renderbufferStorage(x0, x1, x2, x3);
  _glRenderbufferStorage.sig = 'viiii';
  var _emscripten_glRenderbufferStorage = _glRenderbufferStorage;
  _emscripten_glRenderbufferStorage.sig = 'viiii';

  /** @suppress {duplicate } */
  var _glRenderbufferStorageMultisample = (x0, x1, x2, x3, x4) => GLctx.renderbufferStorageMultisample(x0, x1, x2, x3, x4);
  _glRenderbufferStorageMultisample.sig = 'viiiii';
  var _emscripten_glRenderbufferStorageMultisample = _glRenderbufferStorageMultisample;
  _emscripten_glRenderbufferStorageMultisample.sig = 'viiiii';

  /** @suppress {duplicate } */
  var _glResumeTransformFeedback = () => GLctx.resumeTransformFeedback();
  _glResumeTransformFeedback.sig = 'v';
  var _emscripten_glResumeTransformFeedback = _glResumeTransformFeedback;
  _emscripten_glResumeTransformFeedback.sig = 'v';

  /** @suppress {duplicate } */
  var _glSampleCoverage = (value, invert) => {
      GLctx.sampleCoverage(value, !!invert);
    };
  _glSampleCoverage.sig = 'vfi';
  var _emscripten_glSampleCoverage = _glSampleCoverage;
  _emscripten_glSampleCoverage.sig = 'vfi';

  /** @suppress {duplicate } */
  var _glSamplerParameterf = (sampler, pname, param) => {
      GLctx.samplerParameterf(GL.samplers[sampler], pname, param);
    };
  _glSamplerParameterf.sig = 'viif';
  var _emscripten_glSamplerParameterf = _glSamplerParameterf;
  _emscripten_glSamplerParameterf.sig = 'viif';

  /** @suppress {duplicate } */
  var _glSamplerParameterfv = (sampler, pname, params) => {
      var param = HEAPF32[((params)>>2)];
      GLctx.samplerParameterf(GL.samplers[sampler], pname, param);
    };
  _glSamplerParameterfv.sig = 'viip';
  var _emscripten_glSamplerParameterfv = _glSamplerParameterfv;
  _emscripten_glSamplerParameterfv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glSamplerParameteri = (sampler, pname, param) => {
      GLctx.samplerParameteri(GL.samplers[sampler], pname, param);
    };
  _glSamplerParameteri.sig = 'viii';
  var _emscripten_glSamplerParameteri = _glSamplerParameteri;
  _emscripten_glSamplerParameteri.sig = 'viii';

  /** @suppress {duplicate } */
  var _glSamplerParameteriv = (sampler, pname, params) => {
      var param = HEAP32[((params)>>2)];
      GLctx.samplerParameteri(GL.samplers[sampler], pname, param);
    };
  _glSamplerParameteriv.sig = 'viip';
  var _emscripten_glSamplerParameteriv = _glSamplerParameteriv;
  _emscripten_glSamplerParameteriv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glScissor = (x0, x1, x2, x3) => GLctx.scissor(x0, x1, x2, x3);
  _glScissor.sig = 'viiii';
  var _emscripten_glScissor = _glScissor;
  _emscripten_glScissor.sig = 'viiii';

  /** @suppress {duplicate } */
  var _glShaderBinary = (count, shaders, binaryformat, binary, length) => {
      GL.recordError(0x500/*GL_INVALID_ENUM*/);
    };
  _glShaderBinary.sig = 'vipipi';
  var _emscripten_glShaderBinary = _glShaderBinary;
  _emscripten_glShaderBinary.sig = 'vipipi';

  /** @suppress {duplicate } */
  var _glShaderSource = (shader, count, string, length) => {
      var source = GL.getSource(shader, count, string, length);
  
      GLctx.shaderSource(GL.shaders[shader], source);
    };
  _glShaderSource.sig = 'viipp';
  var _emscripten_glShaderSource = _glShaderSource;
  _emscripten_glShaderSource.sig = 'viipp';

  /** @suppress {duplicate } */
  var _glStencilFunc = (x0, x1, x2) => GLctx.stencilFunc(x0, x1, x2);
  _glStencilFunc.sig = 'viii';
  var _emscripten_glStencilFunc = _glStencilFunc;
  _emscripten_glStencilFunc.sig = 'viii';

  /** @suppress {duplicate } */
  var _glStencilFuncSeparate = (x0, x1, x2, x3) => GLctx.stencilFuncSeparate(x0, x1, x2, x3);
  _glStencilFuncSeparate.sig = 'viiii';
  var _emscripten_glStencilFuncSeparate = _glStencilFuncSeparate;
  _emscripten_glStencilFuncSeparate.sig = 'viiii';

  /** @suppress {duplicate } */
  var _glStencilMask = (x0) => GLctx.stencilMask(x0);
  _glStencilMask.sig = 'vi';
  var _emscripten_glStencilMask = _glStencilMask;
  _emscripten_glStencilMask.sig = 'vi';

  /** @suppress {duplicate } */
  var _glStencilMaskSeparate = (x0, x1) => GLctx.stencilMaskSeparate(x0, x1);
  _glStencilMaskSeparate.sig = 'vii';
  var _emscripten_glStencilMaskSeparate = _glStencilMaskSeparate;
  _emscripten_glStencilMaskSeparate.sig = 'vii';

  /** @suppress {duplicate } */
  var _glStencilOp = (x0, x1, x2) => GLctx.stencilOp(x0, x1, x2);
  _glStencilOp.sig = 'viii';
  var _emscripten_glStencilOp = _glStencilOp;
  _emscripten_glStencilOp.sig = 'viii';

  /** @suppress {duplicate } */
  var _glStencilOpSeparate = (x0, x1, x2, x3) => GLctx.stencilOpSeparate(x0, x1, x2, x3);
  _glStencilOpSeparate.sig = 'viiii';
  var _emscripten_glStencilOpSeparate = _glStencilOpSeparate;
  _emscripten_glStencilOpSeparate.sig = 'viiii';

  
  
  
  /** @suppress {duplicate } */
  var _glTexImage2D = (target, level, internalFormat, width, height, border, format, type, pixels) => {
      if (true) {
        if (GLctx.currentPixelUnpackBufferBinding) {
          GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels);
          return;
        }
        if (pixels) {
          var heap = heapObjectForWebGLType(type);
          var index = toTypedArrayIndex(pixels, heap);
          GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, heap, index);
          return;
        }
      }
      var pixelData = pixels ? emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) : null;
      GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixelData);
    };
  _glTexImage2D.sig = 'viiiiiiiip';
  var _emscripten_glTexImage2D = _glTexImage2D;
  _emscripten_glTexImage2D.sig = 'viiiiiiiip';

  
  /** @suppress {duplicate } */
  var _glTexImage3D = (target, level, internalFormat, width, height, depth, border, format, type, pixels) => {
      if (GLctx.currentPixelUnpackBufferBinding) {
        GLctx.texImage3D(target, level, internalFormat, width, height, depth, border, format, type, pixels);
      } else if (pixels) {
        var heap = heapObjectForWebGLType(type);
        GLctx.texImage3D(target, level, internalFormat, width, height, depth, border, format, type, heap, toTypedArrayIndex(pixels, heap));
      } else {
        GLctx.texImage3D(target, level, internalFormat, width, height, depth, border, format, type, null);
      }
    };
  _glTexImage3D.sig = 'viiiiiiiiip';
  var _emscripten_glTexImage3D = _glTexImage3D;
  _emscripten_glTexImage3D.sig = 'viiiiiiiiip';

  /** @suppress {duplicate } */
  var _glTexParameterf = (x0, x1, x2) => GLctx.texParameterf(x0, x1, x2);
  _glTexParameterf.sig = 'viif';
  var _emscripten_glTexParameterf = _glTexParameterf;
  _emscripten_glTexParameterf.sig = 'viif';

  /** @suppress {duplicate } */
  var _glTexParameterfv = (target, pname, params) => {
      var param = HEAPF32[((params)>>2)];
      GLctx.texParameterf(target, pname, param);
    };
  _glTexParameterfv.sig = 'viip';
  var _emscripten_glTexParameterfv = _glTexParameterfv;
  _emscripten_glTexParameterfv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glTexParameteri = (x0, x1, x2) => GLctx.texParameteri(x0, x1, x2);
  _glTexParameteri.sig = 'viii';
  var _emscripten_glTexParameteri = _glTexParameteri;
  _emscripten_glTexParameteri.sig = 'viii';

  /** @suppress {duplicate } */
  var _glTexParameteriv = (target, pname, params) => {
      var param = HEAP32[((params)>>2)];
      GLctx.texParameteri(target, pname, param);
    };
  _glTexParameteriv.sig = 'viip';
  var _emscripten_glTexParameteriv = _glTexParameteriv;
  _emscripten_glTexParameteriv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glTexStorage2D = (x0, x1, x2, x3, x4) => GLctx.texStorage2D(x0, x1, x2, x3, x4);
  _glTexStorage2D.sig = 'viiiii';
  var _emscripten_glTexStorage2D = _glTexStorage2D;
  _emscripten_glTexStorage2D.sig = 'viiiii';

  /** @suppress {duplicate } */
  var _glTexStorage3D = (x0, x1, x2, x3, x4, x5) => GLctx.texStorage3D(x0, x1, x2, x3, x4, x5);
  _glTexStorage3D.sig = 'viiiiii';
  var _emscripten_glTexStorage3D = _glTexStorage3D;
  _emscripten_glTexStorage3D.sig = 'viiiiii';

  
  
  
  /** @suppress {duplicate } */
  var _glTexSubImage2D = (target, level, xoffset, yoffset, width, height, format, type, pixels) => {
      if (true) {
        if (GLctx.currentPixelUnpackBufferBinding) {
          GLctx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
          return;
        }
        if (pixels) {
          var heap = heapObjectForWebGLType(type);
          GLctx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, heap, toTypedArrayIndex(pixels, heap));
          return;
        }
      }
      var pixelData = pixels ? emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, 0) : null;
      GLctx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixelData);
    };
  _glTexSubImage2D.sig = 'viiiiiiiip';
  var _emscripten_glTexSubImage2D = _glTexSubImage2D;
  _emscripten_glTexSubImage2D.sig = 'viiiiiiiip';

  
  /** @suppress {duplicate } */
  var _glTexSubImage3D = (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels) => {
      if (GLctx.currentPixelUnpackBufferBinding) {
        GLctx.texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
      } else if (pixels) {
        var heap = heapObjectForWebGLType(type);
        GLctx.texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, heap, toTypedArrayIndex(pixels, heap));
      } else {
        GLctx.texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, null);
      }
    };
  _glTexSubImage3D.sig = 'viiiiiiiiiip';
  var _emscripten_glTexSubImage3D = _glTexSubImage3D;
  _emscripten_glTexSubImage3D.sig = 'viiiiiiiiiip';

  /** @suppress {duplicate } */
  var _glTransformFeedbackVaryings = (program, count, varyings, bufferMode) => {
      program = GL.programs[program];
      var vars = [];
      for (var i = 0; i < count; i++)
        vars.push(UTF8ToString(HEAP32[(((varyings)+(i*4))>>2)]));
  
      GLctx.transformFeedbackVaryings(program, vars, bufferMode);
    };
  _glTransformFeedbackVaryings.sig = 'viipi';
  var _emscripten_glTransformFeedbackVaryings = _glTransformFeedbackVaryings;
  _emscripten_glTransformFeedbackVaryings.sig = 'viipi';

  
  /** @suppress {duplicate } */
  var _glUniform1f = (location, v0) => {
      GLctx.uniform1f(webglGetUniformLocation(location), v0);
    };
  _glUniform1f.sig = 'vif';
  var _emscripten_glUniform1f = _glUniform1f;
  _emscripten_glUniform1f.sig = 'vif';

  
  /** @suppress {duplicate } */
  var _glUniform1fv = (location, count, value) => {
  
      count && GLctx.uniform1fv(webglGetUniformLocation(location), HEAPF32, ((value)>>2), count);
    };
  _glUniform1fv.sig = 'viip';
  var _emscripten_glUniform1fv = _glUniform1fv;
  _emscripten_glUniform1fv.sig = 'viip';

  
  /** @suppress {duplicate } */
  var _glUniform1i = (location, v0) => {
      GLctx.uniform1i(webglGetUniformLocation(location), v0);
    };
  _glUniform1i.sig = 'vii';
  var _emscripten_glUniform1i = _glUniform1i;
  _emscripten_glUniform1i.sig = 'vii';

  
  /** @suppress {duplicate } */
  var _glUniform1iv = (location, count, value) => {
  
      count && GLctx.uniform1iv(webglGetUniformLocation(location), HEAP32, ((value)>>2), count);
    };
  _glUniform1iv.sig = 'viip';
  var _emscripten_glUniform1iv = _glUniform1iv;
  _emscripten_glUniform1iv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glUniform1ui = (location, v0) => {
      GLctx.uniform1ui(webglGetUniformLocation(location), v0);
    };
  _glUniform1ui.sig = 'vii';
  var _emscripten_glUniform1ui = _glUniform1ui;
  _emscripten_glUniform1ui.sig = 'vii';

  /** @suppress {duplicate } */
  var _glUniform1uiv = (location, count, value) => {
      count && GLctx.uniform1uiv(webglGetUniformLocation(location), HEAPU32, ((value)>>2), count);
    };
  _glUniform1uiv.sig = 'viip';
  var _emscripten_glUniform1uiv = _glUniform1uiv;
  _emscripten_glUniform1uiv.sig = 'viip';

  
  /** @suppress {duplicate } */
  var _glUniform2f = (location, v0, v1) => {
      GLctx.uniform2f(webglGetUniformLocation(location), v0, v1);
    };
  _glUniform2f.sig = 'viff';
  var _emscripten_glUniform2f = _glUniform2f;
  _emscripten_glUniform2f.sig = 'viff';

  
  /** @suppress {duplicate } */
  var _glUniform2fv = (location, count, value) => {
  
      count && GLctx.uniform2fv(webglGetUniformLocation(location), HEAPF32, ((value)>>2), count*2);
    };
  _glUniform2fv.sig = 'viip';
  var _emscripten_glUniform2fv = _glUniform2fv;
  _emscripten_glUniform2fv.sig = 'viip';

  
  /** @suppress {duplicate } */
  var _glUniform2i = (location, v0, v1) => {
      GLctx.uniform2i(webglGetUniformLocation(location), v0, v1);
    };
  _glUniform2i.sig = 'viii';
  var _emscripten_glUniform2i = _glUniform2i;
  _emscripten_glUniform2i.sig = 'viii';

  
  /** @suppress {duplicate } */
  var _glUniform2iv = (location, count, value) => {
  
      count && GLctx.uniform2iv(webglGetUniformLocation(location), HEAP32, ((value)>>2), count*2);
    };
  _glUniform2iv.sig = 'viip';
  var _emscripten_glUniform2iv = _glUniform2iv;
  _emscripten_glUniform2iv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glUniform2ui = (location, v0, v1) => {
      GLctx.uniform2ui(webglGetUniformLocation(location), v0, v1);
    };
  _glUniform2ui.sig = 'viii';
  var _emscripten_glUniform2ui = _glUniform2ui;
  _emscripten_glUniform2ui.sig = 'viii';

  /** @suppress {duplicate } */
  var _glUniform2uiv = (location, count, value) => {
      count && GLctx.uniform2uiv(webglGetUniformLocation(location), HEAPU32, ((value)>>2), count*2);
    };
  _glUniform2uiv.sig = 'viip';
  var _emscripten_glUniform2uiv = _glUniform2uiv;
  _emscripten_glUniform2uiv.sig = 'viip';

  
  /** @suppress {duplicate } */
  var _glUniform3f = (location, v0, v1, v2) => {
      GLctx.uniform3f(webglGetUniformLocation(location), v0, v1, v2);
    };
  _glUniform3f.sig = 'vifff';
  var _emscripten_glUniform3f = _glUniform3f;
  _emscripten_glUniform3f.sig = 'vifff';

  
  /** @suppress {duplicate } */
  var _glUniform3fv = (location, count, value) => {
  
      count && GLctx.uniform3fv(webglGetUniformLocation(location), HEAPF32, ((value)>>2), count*3);
    };
  _glUniform3fv.sig = 'viip';
  var _emscripten_glUniform3fv = _glUniform3fv;
  _emscripten_glUniform3fv.sig = 'viip';

  
  /** @suppress {duplicate } */
  var _glUniform3i = (location, v0, v1, v2) => {
      GLctx.uniform3i(webglGetUniformLocation(location), v0, v1, v2);
    };
  _glUniform3i.sig = 'viiii';
  var _emscripten_glUniform3i = _glUniform3i;
  _emscripten_glUniform3i.sig = 'viiii';

  
  /** @suppress {duplicate } */
  var _glUniform3iv = (location, count, value) => {
  
      count && GLctx.uniform3iv(webglGetUniformLocation(location), HEAP32, ((value)>>2), count*3);
    };
  _glUniform3iv.sig = 'viip';
  var _emscripten_glUniform3iv = _glUniform3iv;
  _emscripten_glUniform3iv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glUniform3ui = (location, v0, v1, v2) => {
      GLctx.uniform3ui(webglGetUniformLocation(location), v0, v1, v2);
    };
  _glUniform3ui.sig = 'viiii';
  var _emscripten_glUniform3ui = _glUniform3ui;
  _emscripten_glUniform3ui.sig = 'viiii';

  /** @suppress {duplicate } */
  var _glUniform3uiv = (location, count, value) => {
      count && GLctx.uniform3uiv(webglGetUniformLocation(location), HEAPU32, ((value)>>2), count*3);
    };
  _glUniform3uiv.sig = 'viip';
  var _emscripten_glUniform3uiv = _glUniform3uiv;
  _emscripten_glUniform3uiv.sig = 'viip';

  
  /** @suppress {duplicate } */
  var _glUniform4f = (location, v0, v1, v2, v3) => {
      GLctx.uniform4f(webglGetUniformLocation(location), v0, v1, v2, v3);
    };
  _glUniform4f.sig = 'viffff';
  var _emscripten_glUniform4f = _glUniform4f;
  _emscripten_glUniform4f.sig = 'viffff';

  
  /** @suppress {duplicate } */
  var _glUniform4fv = (location, count, value) => {
  
      count && GLctx.uniform4fv(webglGetUniformLocation(location), HEAPF32, ((value)>>2), count*4);
    };
  _glUniform4fv.sig = 'viip';
  var _emscripten_glUniform4fv = _glUniform4fv;
  _emscripten_glUniform4fv.sig = 'viip';

  
  /** @suppress {duplicate } */
  var _glUniform4i = (location, v0, v1, v2, v3) => {
      GLctx.uniform4i(webglGetUniformLocation(location), v0, v1, v2, v3);
    };
  _glUniform4i.sig = 'viiiii';
  var _emscripten_glUniform4i = _glUniform4i;
  _emscripten_glUniform4i.sig = 'viiiii';

  
  /** @suppress {duplicate } */
  var _glUniform4iv = (location, count, value) => {
  
      count && GLctx.uniform4iv(webglGetUniformLocation(location), HEAP32, ((value)>>2), count*4);
    };
  _glUniform4iv.sig = 'viip';
  var _emscripten_glUniform4iv = _glUniform4iv;
  _emscripten_glUniform4iv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glUniform4ui = (location, v0, v1, v2, v3) => {
      GLctx.uniform4ui(webglGetUniformLocation(location), v0, v1, v2, v3);
    };
  _glUniform4ui.sig = 'viiiii';
  var _emscripten_glUniform4ui = _glUniform4ui;
  _emscripten_glUniform4ui.sig = 'viiiii';

  /** @suppress {duplicate } */
  var _glUniform4uiv = (location, count, value) => {
      count && GLctx.uniform4uiv(webglGetUniformLocation(location), HEAPU32, ((value)>>2), count*4);
    };
  _glUniform4uiv.sig = 'viip';
  var _emscripten_glUniform4uiv = _glUniform4uiv;
  _emscripten_glUniform4uiv.sig = 'viip';

  /** @suppress {duplicate } */
  var _glUniformBlockBinding = (program, uniformBlockIndex, uniformBlockBinding) => {
      program = GL.programs[program];
  
      GLctx.uniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
    };
  _glUniformBlockBinding.sig = 'viii';
  var _emscripten_glUniformBlockBinding = _glUniformBlockBinding;
  _emscripten_glUniformBlockBinding.sig = 'viii';

  
  /** @suppress {duplicate } */
  var _glUniformMatrix2fv = (location, count, transpose, value) => {
  
      count && GLctx.uniformMatrix2fv(webglGetUniformLocation(location), !!transpose, HEAPF32, ((value)>>2), count*4);
    };
  _glUniformMatrix2fv.sig = 'viiip';
  var _emscripten_glUniformMatrix2fv = _glUniformMatrix2fv;
  _emscripten_glUniformMatrix2fv.sig = 'viiip';

  /** @suppress {duplicate } */
  var _glUniformMatrix2x3fv = (location, count, transpose, value) => {
      count && GLctx.uniformMatrix2x3fv(webglGetUniformLocation(location), !!transpose, HEAPF32, ((value)>>2), count*6);
    };
  _glUniformMatrix2x3fv.sig = 'viiip';
  var _emscripten_glUniformMatrix2x3fv = _glUniformMatrix2x3fv;
  _emscripten_glUniformMatrix2x3fv.sig = 'viiip';

  /** @suppress {duplicate } */
  var _glUniformMatrix2x4fv = (location, count, transpose, value) => {
      count && GLctx.uniformMatrix2x4fv(webglGetUniformLocation(location), !!transpose, HEAPF32, ((value)>>2), count*8);
    };
  _glUniformMatrix2x4fv.sig = 'viiip';
  var _emscripten_glUniformMatrix2x4fv = _glUniformMatrix2x4fv;
  _emscripten_glUniformMatrix2x4fv.sig = 'viiip';

  
  /** @suppress {duplicate } */
  var _glUniformMatrix3fv = (location, count, transpose, value) => {
  
      count && GLctx.uniformMatrix3fv(webglGetUniformLocation(location), !!transpose, HEAPF32, ((value)>>2), count*9);
    };
  _glUniformMatrix3fv.sig = 'viiip';
  var _emscripten_glUniformMatrix3fv = _glUniformMatrix3fv;
  _emscripten_glUniformMatrix3fv.sig = 'viiip';

  /** @suppress {duplicate } */
  var _glUniformMatrix3x2fv = (location, count, transpose, value) => {
      count && GLctx.uniformMatrix3x2fv(webglGetUniformLocation(location), !!transpose, HEAPF32, ((value)>>2), count*6);
    };
  _glUniformMatrix3x2fv.sig = 'viiip';
  var _emscripten_glUniformMatrix3x2fv = _glUniformMatrix3x2fv;
  _emscripten_glUniformMatrix3x2fv.sig = 'viiip';

  /** @suppress {duplicate } */
  var _glUniformMatrix3x4fv = (location, count, transpose, value) => {
      count && GLctx.uniformMatrix3x4fv(webglGetUniformLocation(location), !!transpose, HEAPF32, ((value)>>2), count*12);
    };
  _glUniformMatrix3x4fv.sig = 'viiip';
  var _emscripten_glUniformMatrix3x4fv = _glUniformMatrix3x4fv;
  _emscripten_glUniformMatrix3x4fv.sig = 'viiip';

  
  /** @suppress {duplicate } */
  var _glUniformMatrix4fv = (location, count, transpose, value) => {
  
      count && GLctx.uniformMatrix4fv(webglGetUniformLocation(location), !!transpose, HEAPF32, ((value)>>2), count*16);
    };
  _glUniformMatrix4fv.sig = 'viiip';
  var _emscripten_glUniformMatrix4fv = _glUniformMatrix4fv;
  _emscripten_glUniformMatrix4fv.sig = 'viiip';

  /** @suppress {duplicate } */
  var _glUniformMatrix4x2fv = (location, count, transpose, value) => {
      count && GLctx.uniformMatrix4x2fv(webglGetUniformLocation(location), !!transpose, HEAPF32, ((value)>>2), count*8);
    };
  _glUniformMatrix4x2fv.sig = 'viiip';
  var _emscripten_glUniformMatrix4x2fv = _glUniformMatrix4x2fv;
  _emscripten_glUniformMatrix4x2fv.sig = 'viiip';

  /** @suppress {duplicate } */
  var _glUniformMatrix4x3fv = (location, count, transpose, value) => {
      count && GLctx.uniformMatrix4x3fv(webglGetUniformLocation(location), !!transpose, HEAPF32, ((value)>>2), count*12);
    };
  _glUniformMatrix4x3fv.sig = 'viiip';
  var _emscripten_glUniformMatrix4x3fv = _glUniformMatrix4x3fv;
  _emscripten_glUniformMatrix4x3fv.sig = 'viiip';

  
  
  
  /** @suppress {duplicate } */
  var _glUnmapBuffer = (target) => {
      if (!emscriptenWebGLValidateMapBufferTarget(target)) {
        GL.recordError(0x500/*GL_INVALID_ENUM*/);
        err('GL_INVALID_ENUM in glUnmapBuffer');
        return 0;
      }
  
      var buffer = emscriptenWebGLGetBufferBinding(target);
      var mapping = GL.mappedBuffers[buffer];
      if (!mapping || !mapping.mem) {
        GL.recordError(0x502 /* GL_INVALID_OPERATION */);
        err('buffer was never mapped in glUnmapBuffer');
        return 0;
      }
  
      if (!(mapping.access & 0x10)) { /* GL_MAP_FLUSH_EXPLICIT_BIT */
        if (true) {
          GLctx.bufferSubData(target, mapping.offset, HEAPU8, mapping.mem, mapping.length);
        } else
        GLctx.bufferSubData(target, mapping.offset, HEAPU8.subarray(mapping.mem, mapping.mem+mapping.length));
      }
      _free(mapping.mem);
      mapping.mem = 0;
      return 1;
    };
  _glUnmapBuffer.sig = 'ii';
  var _emscripten_glUnmapBuffer = _glUnmapBuffer;
  _emscripten_glUnmapBuffer.sig = 'ii';

  /** @suppress {duplicate } */
  var _glUseProgram = (program) => {
      program = GL.programs[program];
      GLctx.useProgram(program);
      // Record the currently active program so that we can access the uniform
      // mapping table of that program.
      GLctx.currentProgram = program;
    };
  _glUseProgram.sig = 'vi';
  var _emscripten_glUseProgram = _glUseProgram;
  _emscripten_glUseProgram.sig = 'vi';

  /** @suppress {duplicate } */
  var _glValidateProgram = (program) => {
      GLctx.validateProgram(GL.programs[program]);
    };
  _glValidateProgram.sig = 'vi';
  var _emscripten_glValidateProgram = _glValidateProgram;
  _emscripten_glValidateProgram.sig = 'vi';

  /** @suppress {duplicate } */
  var _glVertexAttrib1f = (x0, x1) => GLctx.vertexAttrib1f(x0, x1);
  _glVertexAttrib1f.sig = 'vif';
  var _emscripten_glVertexAttrib1f = _glVertexAttrib1f;
  _emscripten_glVertexAttrib1f.sig = 'vif';

  /** @suppress {duplicate } */
  var _glVertexAttrib1fv = (index, v) => {
  
      GLctx.vertexAttrib1f(index, HEAPF32[v>>2]);
    };
  _glVertexAttrib1fv.sig = 'vip';
  var _emscripten_glVertexAttrib1fv = _glVertexAttrib1fv;
  _emscripten_glVertexAttrib1fv.sig = 'vip';

  /** @suppress {duplicate } */
  var _glVertexAttrib2f = (x0, x1, x2) => GLctx.vertexAttrib2f(x0, x1, x2);
  _glVertexAttrib2f.sig = 'viff';
  var _emscripten_glVertexAttrib2f = _glVertexAttrib2f;
  _emscripten_glVertexAttrib2f.sig = 'viff';

  /** @suppress {duplicate } */
  var _glVertexAttrib2fv = (index, v) => {
  
      GLctx.vertexAttrib2f(index, HEAPF32[v>>2], HEAPF32[v+4>>2]);
    };
  _glVertexAttrib2fv.sig = 'vip';
  var _emscripten_glVertexAttrib2fv = _glVertexAttrib2fv;
  _emscripten_glVertexAttrib2fv.sig = 'vip';

  /** @suppress {duplicate } */
  var _glVertexAttrib3f = (x0, x1, x2, x3) => GLctx.vertexAttrib3f(x0, x1, x2, x3);
  _glVertexAttrib3f.sig = 'vifff';
  var _emscripten_glVertexAttrib3f = _glVertexAttrib3f;
  _emscripten_glVertexAttrib3f.sig = 'vifff';

  /** @suppress {duplicate } */
  var _glVertexAttrib3fv = (index, v) => {
  
      GLctx.vertexAttrib3f(index, HEAPF32[v>>2], HEAPF32[v+4>>2], HEAPF32[v+8>>2]);
    };
  _glVertexAttrib3fv.sig = 'vip';
  var _emscripten_glVertexAttrib3fv = _glVertexAttrib3fv;
  _emscripten_glVertexAttrib3fv.sig = 'vip';

  /** @suppress {duplicate } */
  var _glVertexAttrib4f = (x0, x1, x2, x3, x4) => GLctx.vertexAttrib4f(x0, x1, x2, x3, x4);
  _glVertexAttrib4f.sig = 'viffff';
  var _emscripten_glVertexAttrib4f = _glVertexAttrib4f;
  _emscripten_glVertexAttrib4f.sig = 'viffff';

  /** @suppress {duplicate } */
  var _glVertexAttrib4fv = (index, v) => {
  
      GLctx.vertexAttrib4f(index, HEAPF32[v>>2], HEAPF32[v+4>>2], HEAPF32[v+8>>2], HEAPF32[v+12>>2]);
    };
  _glVertexAttrib4fv.sig = 'vip';
  var _emscripten_glVertexAttrib4fv = _glVertexAttrib4fv;
  _emscripten_glVertexAttrib4fv.sig = 'vip';

  /** @suppress {duplicate } */
  var _glVertexAttribDivisor = (index, divisor) => {
      GLctx.vertexAttribDivisor(index, divisor);
    };
  _glVertexAttribDivisor.sig = 'vii';
  var _emscripten_glVertexAttribDivisor = _glVertexAttribDivisor;
  _emscripten_glVertexAttribDivisor.sig = 'vii';

  
  /** @suppress {duplicate } */
  var _glVertexAttribDivisorANGLE = _glVertexAttribDivisor;
  var _emscripten_glVertexAttribDivisorANGLE = _glVertexAttribDivisorANGLE;

  
  /** @suppress {duplicate } */
  var _glVertexAttribDivisorARB = _glVertexAttribDivisor;
  var _emscripten_glVertexAttribDivisorARB = _glVertexAttribDivisorARB;

  
  /** @suppress {duplicate } */
  var _glVertexAttribDivisorEXT = _glVertexAttribDivisor;
  var _emscripten_glVertexAttribDivisorEXT = _glVertexAttribDivisorEXT;

  
  /** @suppress {duplicate } */
  var _glVertexAttribDivisorNV = _glVertexAttribDivisor;
  var _emscripten_glVertexAttribDivisorNV = _glVertexAttribDivisorNV;

  /** @suppress {duplicate } */
  var _glVertexAttribI4i = (x0, x1, x2, x3, x4) => GLctx.vertexAttribI4i(x0, x1, x2, x3, x4);
  _glVertexAttribI4i.sig = 'viiiii';
  var _emscripten_glVertexAttribI4i = _glVertexAttribI4i;
  _emscripten_glVertexAttribI4i.sig = 'viiiii';

  /** @suppress {duplicate } */
  var _glVertexAttribI4iv = (index, v) => {
      GLctx.vertexAttribI4i(index, HEAP32[v>>2], HEAP32[v+4>>2], HEAP32[v+8>>2], HEAP32[v+12>>2]);
    };
  _glVertexAttribI4iv.sig = 'vip';
  var _emscripten_glVertexAttribI4iv = _glVertexAttribI4iv;
  _emscripten_glVertexAttribI4iv.sig = 'vip';

  /** @suppress {duplicate } */
  var _glVertexAttribI4ui = (x0, x1, x2, x3, x4) => GLctx.vertexAttribI4ui(x0, x1, x2, x3, x4);
  _glVertexAttribI4ui.sig = 'viiiii';
  var _emscripten_glVertexAttribI4ui = _glVertexAttribI4ui;
  _emscripten_glVertexAttribI4ui.sig = 'viiiii';

  /** @suppress {duplicate } */
  var _glVertexAttribI4uiv = (index, v) => {
      GLctx.vertexAttribI4ui(index, HEAPU32[v>>2], HEAPU32[v+4>>2], HEAPU32[v+8>>2], HEAPU32[v+12>>2]);
    };
  _glVertexAttribI4uiv.sig = 'vip';
  var _emscripten_glVertexAttribI4uiv = _glVertexAttribI4uiv;
  _emscripten_glVertexAttribI4uiv.sig = 'vip';

  /** @suppress {duplicate } */
  var _glVertexAttribIPointer = (index, size, type, stride, ptr) => {
      var cb = GL.currentContext.clientBuffers[index];
      if (!GLctx.currentArrayBufferBinding) {
        cb.size = size;
        cb.type = type;
        cb.normalized = false;
        cb.stride = stride;
        cb.ptr = ptr;
        cb.clientside = true;
        cb.vertexAttribPointerAdaptor = function(index, size, type, normalized, stride, ptr) {
          this.vertexAttribIPointer(index, size, type, stride, ptr);
        };
        return;
      }
      cb.clientside = false;
      GLctx.vertexAttribIPointer(index, size, type, stride, ptr);
    };
  _glVertexAttribIPointer.sig = 'viiiip';
  var _emscripten_glVertexAttribIPointer = _glVertexAttribIPointer;
  _emscripten_glVertexAttribIPointer.sig = 'viiiip';

  /** @suppress {duplicate } */
  var _glVertexAttribPointer = (index, size, type, normalized, stride, ptr) => {
      var cb = GL.currentContext.clientBuffers[index];
      if (!GLctx.currentArrayBufferBinding) {
        cb.size = size;
        cb.type = type;
        cb.normalized = normalized;
        cb.stride = stride;
        cb.ptr = ptr;
        cb.clientside = true;
        cb.vertexAttribPointerAdaptor = function(index, size, type, normalized, stride, ptr) {
          this.vertexAttribPointer(index, size, type, normalized, stride, ptr);
        };
        return;
      }
      cb.clientside = false;
      GLctx.vertexAttribPointer(index, size, type, !!normalized, stride, ptr);
    };
  _glVertexAttribPointer.sig = 'viiiiip';
  var _emscripten_glVertexAttribPointer = _glVertexAttribPointer;
  _emscripten_glVertexAttribPointer.sig = 'viiiiip';

  /** @suppress {duplicate } */
  var _glViewport = (x0, x1, x2, x3) => GLctx.viewport(x0, x1, x2, x3);
  _glViewport.sig = 'viiii';
  var _emscripten_glViewport = _glViewport;
  _emscripten_glViewport.sig = 'viiii';

  /** @suppress {duplicate } */
  var _glWaitSync = (sync, flags, timeout) => {
      // See WebGL2 vs GLES3 difference on GL_TIMEOUT_IGNORED above (https://www.khronos.org/registry/webgl/specs/latest/2.0/#5.15)
      timeout = Number(timeout);
      GLctx.waitSync(GL.syncs[sync], flags, timeout);
    };
  _glWaitSync.sig = 'vpij';
  var _emscripten_glWaitSync = _glWaitSync;
  _emscripten_glWaitSync.sig = 'vpij';

  var _emscripten_has_asyncify = () => 0;
  _emscripten_has_asyncify.sig = 'i';

  var _emscripten_hide_mouse = () => {
      var styleSheet = document.styleSheets[0];
      var rules = styleSheet.cssRules;
      for (var i = 0; i < rules.length; i++) {
        if (rules[i].cssText.substr(0, 6) == 'canvas') {
          styleSheet.deleteRule(i);
          i--;
        }
      }
      styleSheet.insertRule('canvas.emscripten { border: 1px solid black; cursor: none; }', 0);
    };
  _emscripten_hide_mouse.sig = 'v';

  var reallyNegative = (x) => x < 0 || (x === 0 && (1/x) === -Infinity);
  
  var convertI32PairToI53 = (lo, hi) => {
      return (lo >>> 0) + hi * 4294967296;
    };
  
  var convertU32PairToI53 = (lo, hi) => {
      return (lo >>> 0) + (hi >>> 0) * 4294967296;
    };
  
  var reSign = (value, bits) => {
      if (value <= 0) {
        return value;
      }
      var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                            : Math.pow(2, bits-1);
      // for huge values, we can hit the precision limit and always get true here.
      // so don't do that but, in general there is no perfect solution here. With
      // 64-bit ints, we get rounding and errors
      // TODO: In i64 mode 1, resign the two parts separately and safely
      if (value >= half && (bits <= 32 || value > half)) {
        // Cannot bitshift half, as it may be at the limit of the bits JS uses in
        // bitshifts
        value = -2*half + value;
      }
      return value;
    };
  
  var unSign = (value, bits) => {
      if (value >= 0) {
        return value;
      }
      // Need some trickery, since if bits == 32, we are right at the limit of the
      // bits JS uses in bitshifts
      return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value
                        : Math.pow(2, bits)         + value;
    };
  
  var strLen = (ptr) => {
      var end = ptr;
      while (HEAPU8[end]) ++end;
      return end - ptr;
    };
  
  var formatString = (format, varargs) => {
      var textIndex = format;
      var argIndex = varargs;
      // This must be called before reading a double or i64 vararg. It will bump the pointer properly.
      // It also does an assert on i32 values, so it's nice to call it before all varargs calls.
      function prepVararg(ptr, type) {
        if (type === 'double' || type === 'i64') {
          // move so the load is aligned
          if (ptr & 7) {
            ptr += 4;
          }
        } else {
        }
        return ptr;
      }
      function getNextArg(type) {
        // NOTE: Explicitly ignoring type safety. Otherwise this fails:
        //       int x = 4; printf("%c\n", (char)x);
        var ret;
        argIndex = prepVararg(argIndex, type);
        if (type === 'double') {
          ret = HEAPF64[((argIndex)>>3)];
          argIndex += 8;
        } else if (type == 'i64') {
          ret = [HEAP32[((argIndex)>>2)],
                 HEAP32[(((argIndex)+(4))>>2)]];
          argIndex += 8;
        } else {
          type = 'i32'; // varargs are always i32, i64, or double
          ret = HEAP32[((argIndex)>>2)];
          argIndex += 4;
        }
        return ret;
      }
  
      var ret = [];
      var curr, next, currArg;
      while (1) {
        var startTextIndex = textIndex;
        curr = HEAP8[textIndex];
        if (curr === 0) break;
        next = HEAP8[textIndex+1];
        if (curr == 37) {
          // Handle flags.
          var flagAlwaysSigned = false;
          var flagLeftAlign = false;
          var flagAlternative = false;
          var flagZeroPad = false;
          var flagPadSign = false;
          flagsLoop: while (1) {
            switch (next) {
              case 43:
                flagAlwaysSigned = true;
                break;
              case 45:
                flagLeftAlign = true;
                break;
              case 35:
                flagAlternative = true;
                break;
              case 48:
                if (flagZeroPad) {
                  break flagsLoop;
                } else {
                  flagZeroPad = true;
                  break;
                }
              case 32:
                flagPadSign = true;
                break;
              default:
                break flagsLoop;
            }
            textIndex++;
            next = HEAP8[textIndex+1];
          }
  
          // Handle width.
          var width = 0;
          if (next == 42) {
            width = getNextArg('i32');
            textIndex++;
            next = HEAP8[textIndex+1];
          } else {
            while (next >= 48 && next <= 57) {
              width = width * 10 + (next - 48);
              textIndex++;
              next = HEAP8[textIndex+1];
            }
          }
  
          // Handle precision.
          var precisionSet = false, precision = -1;
          if (next == 46) {
            precision = 0;
            precisionSet = true;
            textIndex++;
            next = HEAP8[textIndex+1];
            if (next == 42) {
              precision = getNextArg('i32');
              textIndex++;
            } else {
              while (1) {
                var precisionChr = HEAP8[textIndex+1];
                if (precisionChr < 48 ||
                    precisionChr > 57) break;
                precision = precision * 10 + (precisionChr - 48);
                textIndex++;
              }
            }
            next = HEAP8[textIndex+1];
          }
          if (precision < 0) {
            precision = 6; // Standard default.
            precisionSet = false;
          }
  
          // Handle integer sizes. WARNING: These assume a 32-bit architecture!
          var argSize;
          switch (String.fromCharCode(next)) {
            case 'h':
              var nextNext = HEAP8[textIndex+2];
              if (nextNext == 104) {
                textIndex++;
                argSize = 1; // char (actually i32 in varargs)
              } else {
                argSize = 2; // short (actually i32 in varargs)
              }
              break;
            case 'l':
              var nextNext = HEAP8[textIndex+2];
              if (nextNext == 108) {
                textIndex++;
                argSize = 8; // long long
              } else {
                argSize = 4; // long
              }
              break;
            case 'L': // long long
            case 'q': // int64_t
            case 'j': // intmax_t
              argSize = 8;
              break;
            case 'z': // size_t
            case 't': // ptrdiff_t
            case 'I': // signed ptrdiff_t or unsigned size_t
              argSize = 4;
              break;
            default:
              argSize = null;
          }
          if (argSize) textIndex++;
          next = HEAP8[textIndex+1];
  
          // Handle type specifier.
          switch (String.fromCharCode(next)) {
            case 'd': case 'i': case 'u': case 'o': case 'x': case 'X': case 'p': {
              // Integer.
              var signed = next == 100 || next == 105;
              argSize = argSize || 4;
              currArg = getNextArg('i' + (argSize * 8));
              var argText;
              // Flatten i64-1 [low, high] into a (slightly rounded) double
              if (argSize == 8) {
                currArg = next == 117 ? convertU32PairToI53(currArg[0], currArg[1]) : convertI32PairToI53(currArg[0], currArg[1]);
              }
              // Truncate to requested size.
              if (argSize <= 4) {
                var limit = Math.pow(256, argSize) - 1;
                currArg = (signed ? reSign : unSign)(currArg & limit, argSize * 8);
              }
              // Format the number.
              var currAbsArg = Math.abs(currArg);
              var prefix = '';
              if (next == 100 || next == 105) {
                argText = reSign(currArg, 8 * argSize).toString(10);
              } else if (next == 117) {
                argText = unSign(currArg, 8 * argSize).toString(10);
                currArg = Math.abs(currArg);
              } else if (next == 111) {
                argText = (flagAlternative ? '0' : '') + currAbsArg.toString(8);
              } else if (next == 120 || next == 88) {
                prefix = (flagAlternative && currArg != 0) ? '0x' : '';
                if (currArg < 0) {
                  // Represent negative numbers in hex as 2's complement.
                  currArg = -currArg;
                  argText = (currAbsArg - 1).toString(16);
                  var buffer = [];
                  for (var i = 0; i < argText.length; i++) {
                    buffer.push((0xF - parseInt(argText[i], 16)).toString(16));
                  }
                  argText = buffer.join('');
                  while (argText.length < argSize * 2) argText = 'f' + argText;
                } else {
                  argText = currAbsArg.toString(16);
                }
                if (next == 88) {
                  prefix = prefix.toUpperCase();
                  argText = argText.toUpperCase();
                }
              } else if (next == 112) {
                if (currAbsArg === 0) {
                  argText = '(nil)';
                } else {
                  prefix = '0x';
                  argText = currAbsArg.toString(16);
                }
              }
              if (precisionSet) {
                while (argText.length < precision) {
                  argText = '0' + argText;
                }
              }
  
              // Add sign if needed
              if (currArg >= 0) {
                if (flagAlwaysSigned) {
                  prefix = '+' + prefix;
                } else if (flagPadSign) {
                  prefix = ' ' + prefix;
                }
              }
  
              // Move sign to prefix so we zero-pad after the sign
              if (argText.charAt(0) == '-') {
                prefix = '-' + prefix;
                argText = argText.substr(1);
              }
  
              // Add padding.
              while (prefix.length + argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad) {
                    argText = '0' + argText;
                  } else {
                    prefix = ' ' + prefix;
                  }
                }
              }
  
              // Insert the result into the buffer.
              argText = prefix + argText;
              argText.split('').forEach((chr) => ret.push(chr.charCodeAt(0)));
              break;
            }
            case 'f': case 'F': case 'e': case 'E': case 'g': case 'G': {
              // Float.
              currArg = getNextArg('double');
              var argText;
              if (isNaN(currArg)) {
                argText = 'nan';
                flagZeroPad = false;
              } else if (!isFinite(currArg)) {
                argText = (currArg < 0 ? '-' : '') + 'inf';
                flagZeroPad = false;
              } else {
                var isGeneral = false;
                var effectivePrecision = Math.min(precision, 20);
  
                // Convert g/G to f/F or e/E, as per:
                // http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html
                if (next == 103 || next == 71) {
                  isGeneral = true;
                  precision = precision || 1;
                  var exponent = parseInt(currArg.toExponential(effectivePrecision).split('e')[1], 10);
                  if (precision > exponent && exponent >= -4) {
                    next = ((next == 103) ? 'f' : 'F').charCodeAt(0);
                    precision -= exponent + 1;
                  } else {
                    next = ((next == 103) ? 'e' : 'E').charCodeAt(0);
                    precision--;
                  }
                  effectivePrecision = Math.min(precision, 20);
                }
  
                if (next == 101 || next == 69) {
                  argText = currArg.toExponential(effectivePrecision);
                  // Make sure the exponent has at least 2 digits.
                  if (/[eE][-+]\d$/.test(argText)) {
                    argText = argText.slice(0, -1) + '0' + argText.slice(-1);
                  }
                } else if (next == 102 || next == 70) {
                  argText = currArg.toFixed(effectivePrecision);
                  if (currArg === 0 && reallyNegative(currArg)) {
                    argText = '-' + argText;
                  }
                }
  
                var parts = argText.split('e');
                if (isGeneral && !flagAlternative) {
                  // Discard trailing zeros and periods.
                  while (parts[0].length > 1 && parts[0].includes('.') &&
                         (parts[0].slice(-1) == '0' || parts[0].slice(-1) == '.')) {
                    parts[0] = parts[0].slice(0, -1);
                  }
                } else {
                  // Make sure we have a period in alternative mode.
                  if (flagAlternative && argText.indexOf('.') == -1) parts[0] += '.';
                  // Zero pad until required precision.
                  while (precision > effectivePrecision++) parts[0] += '0';
                }
                argText = parts[0] + (parts.length > 1 ? 'e' + parts[1] : '');
  
                // Capitalize 'E' if needed.
                if (next == 69) argText = argText.toUpperCase();
  
                // Add sign.
                if (currArg >= 0) {
                  if (flagAlwaysSigned) {
                    argText = '+' + argText;
                  } else if (flagPadSign) {
                    argText = ' ' + argText;
                  }
                }
              }
  
              // Add padding.
              while (argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad && (argText[0] == '-' || argText[0] == '+')) {
                    argText = argText[0] + '0' + argText.slice(1);
                  } else {
                    argText = (flagZeroPad ? '0' : ' ') + argText;
                  }
                }
              }
  
              // Adjust case.
              if (next < 97) argText = argText.toUpperCase();
  
              // Insert the result into the buffer.
              argText.split('').forEach((chr) => ret.push(chr.charCodeAt(0)));
              break;
            }
            case 's': {
              // String.
              var arg = getNextArg('i8*');
              var argLength = arg ? strLen(arg) : '(null)'.length;
              if (precisionSet) argLength = Math.min(argLength, precision);
              if (!flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              if (arg) {
                for (var i = 0; i < argLength; i++) {
                  ret.push(HEAPU8[arg++]);
                }
              } else {
                ret = ret.concat(intArrayFromString('(null)'.substr(0, argLength), true));
              }
              if (flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              break;
            }
            case 'c': {
              // Character.
              if (flagLeftAlign) ret.push(getNextArg('i8'));
              while (--width > 0) {
                ret.push(32);
              }
              if (!flagLeftAlign) ret.push(getNextArg('i8'));
              break;
            }
            case 'n': {
              // Write the length written so far to the next parameter.
              var ptr = getNextArg('i32*');
              HEAP32[((ptr)>>2)] = ret.length;
              break;
            }
            case '%': {
              // Literal percent sign.
              ret.push(curr);
              break;
            }
            default: {
              // Unknown specifiers remain untouched.
              for (var i = startTextIndex; i < textIndex + 2; i++) {
                ret.push(HEAP8[i]);
              }
            }
          }
          textIndex += 2;
          // TODO: Support a/A (hex float) and m (last error) specifiers.
          // TODO: Support %1${specifier} for arg selection.
        } else {
          ret.push(curr);
          textIndex += 1;
        }
      }
      return ret;
    };
  
  var emscriptenLog = (flags, str) => {
      if (flags & 24) {
        str = str.replace(/\s+$/, ''); // Ensure the message and the callstack are joined cleanly with exactly one newline.
        str += (str.length > 0 ? '\n' : '') + getCallstack(flags);
      }
  
      if (flags & 1) {
        if (flags & 4) {
          console.error(str);
        } else if (flags & 2) {
          console.warn(str);
        } else if (flags & 512) {
          console.info(str);
        } else if (flags & 256) {
          console.debug(str);
        } else {
          console.log(str);
        }
      } else if (flags & 6) {
        err(str);
      } else {
        out(str);
      }
    };
  var _emscripten_log = (flags, format, varargs) => {
      var result = formatString(format, varargs);
      var str = UTF8ArrayToString(result);
      emscriptenLog(flags, str);
    };
  _emscripten_log.sig = 'vipp';

  var _emscripten_out = (str) => out(UTF8ToString(str));
  _emscripten_out.sig = 'vp';

  var _emscripten_pause_main_loop = () => MainLoop.pause();
  _emscripten_pause_main_loop.sig = 'v';

  class HandleAllocator {
      allocated = [undefined];
      freelist = [];
      get(id) {
        return this.allocated[id];
      }
      has(id) {
        return this.allocated[id] !== undefined;
      }
      allocate(handle) {
        var id = this.freelist.pop() || this.allocated.length;
        this.allocated[id] = handle;
        return id;
      }
      free(id) {
        // Set the slot to `undefined` rather than using `delete` here since
        // apparently arrays with holes in them can be less efficient.
        this.allocated[id] = undefined;
        this.freelist.push(id);
      }
    }
  var promiseMap = new HandleAllocator();;
  var makePromise = () => {
      var promiseInfo = {};
      promiseInfo.promise = new Promise((resolve, reject) => {
        promiseInfo.reject = reject;
        promiseInfo.resolve = resolve;
      });
      promiseInfo.id = promiseMap.allocate(promiseInfo);
      return promiseInfo;
    };
  var _emscripten_promise_create = () => makePromise().id;
  _emscripten_promise_create.sig = 'p';

  var _emscripten_promise_destroy = (id) => {
      promiseMap.free(id);
    };
  _emscripten_promise_destroy.sig = 'vp';

  
  var getPromise = (id) => promiseMap.get(id).promise;
  
  var _emscripten_promise_resolve = (id, result, value) => {
      var info = promiseMap.get(id);
      switch (result) {
        case 0:
          info.resolve(value);
          return;
        case 1:
          info.resolve(getPromise(value));
          return;
        case 2:
          info.resolve(getPromise(value));
          _emscripten_promise_destroy(value);
          return;
        case 3:
          info.reject(value);
          return;
      }
    };
  _emscripten_promise_resolve.sig = 'vpip';

  var _emscripten_random = () => Math.random();
  _emscripten_random.sig = 'f';

  
  
  var growMemory = (size) => {
      var b = wasmMemory.buffer;
      var pages = ((size - b.byteLength + 65535) / 65536) | 0;
      try {
        // round size grow request up to wasm page size (fixed 64KB per spec)
        wasmMemory.grow(pages); // .grow() takes a delta compared to the previous size
        updateMemoryViews();
        return 1 /*success*/;
      } catch(e) {
      }
      // implicit 0 return to save code size (caller will cast "undefined" into 0
      // anyhow)
    };
  var _emscripten_resize_heap = (requestedSize) => {
      var oldSize = HEAPU8.length;
      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
      requestedSize >>>= 0;
      // With multithreaded builds, races can happen (another thread might increase the size
      // in between), so return a failure, and let the caller retry.
  
      // Memory resize rules:
      // 1.  Always increase heap size to at least the requested size, rounded up
      //     to next page multiple.
      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap
      //     geometrically: increase the heap size according to
      //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most
      //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).
      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap
      //     linearly: increase the heap size by at least
      //     MEMORY_GROWTH_LINEAR_STEP bytes.
      // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by
      //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest
      // 4.  If we were unable to allocate as much memory, it may be due to
      //     over-eager decision to excessively reserve due to (3) above.
      //     Hence if an allocation fails, cut down on the amount of excess
      //     growth, in an attempt to succeed to perform a smaller allocation.
  
      // A limit is set for how much we can grow. We should not exceed that
      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
  
      // Loop through potential heap size increases. If we attempt a too eager
      // reservation that fails, cut down on the attempted size and reserve a
      // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth
        // but limit overreserving (default to capping at +96MB overgrowth at most)
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );
  
        var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));
  
        var replacement = growMemory(newSize);
        if (replacement) {
  
          return true;
        }
      }
      return false;
    };
  _emscripten_resize_heap.sig = 'ip';

  var _emscripten_resume_main_loop = () => MainLoop.resume();
  _emscripten_resume_main_loop.sig = 'v';

  
  
  
  var _emscripten_run_preload_plugins = (file, onload, onerror) => {
      
  
      var _file = UTF8ToString(file);
      var data = FS.analyzePath(_file);
      if (!data.exists) return -1;
      FS.createPreloadedFile(
        PATH.dirname(_file),
        PATH.basename(_file),
        // TODO: This copy is not needed if the contents are already a Uint8Array,
        //       which they often are (and always are in WasmFS).
        FS.readFile(_file), true, true,
        () => {
          
          if (onload) getWasmTableEntry(onload)(file);
        },
        () => {
          
          if (onerror) getWasmTableEntry(onerror)(file);
        },
        true // don'tCreateFile - it's already there
      );
      return 0;
    };
  _emscripten_run_preload_plugins.sig = 'ippp';


  /** @suppress{checkTypes} */
  var _emscripten_run_script_int = (ptr) => {
      return eval(UTF8ToString(ptr))|0;
    };
  _emscripten_run_script_int.sig = 'ip';

  
  
  
  var _emscripten_run_script_string = (ptr) => {
      var s = eval(UTF8ToString(ptr));
      if (s == null) {
        return 0;
      }
      s += '';
      var me = _emscripten_run_script_string;
      var len = lengthBytesUTF8(s);
      if (!me.bufferSize || me.bufferSize < len+1) {
        if (me.bufferSize) _free(me.buffer);
        me.bufferSize = len+1;
        me.buffer = _malloc(me.bufferSize);
      }
      stringToUTF8(s, me.buffer, me.bufferSize);
      return me.buffer;
    };
  _emscripten_run_script_string.sig = 'pp';

  
  var _emscripten_set_main_loop = (func, fps, simulateInfiniteLoop) => {
      var iterFunc = getWasmTableEntry(func);
      setMainLoop(iterFunc, fps, simulateInfiniteLoop);
    };
  _emscripten_set_main_loop.sig = 'vpii';

  var _emscripten_set_main_loop_expected_blockers = (num) => {
      MainLoop.expectedBlockers = num;
      MainLoop.remainingBlockers = num;
      MainLoop.updateStatus();
    };
  _emscripten_set_main_loop_expected_blockers.sig = 'vi';


  
  var _emscripten_set_window_title = (title) => document.title = UTF8ToString(title);
  _emscripten_set_window_title.sig = 'vp';

  var _emscripten_sleep = () => {
      throw 'Please compile your program with async support in order to use asynchronous operations like emscripten_sleep';
    };
  _emscripten_sleep.sig = 'vi';

  
  
  
  var _emscripten_supports_offscreencanvas = () =>
      // TODO: Add a new build mode, e.g. OFFSCREENCANVAS_SUPPORT=2, which
      // necessitates OffscreenCanvas support at build time, and "return 1;" here in that build mode.
      typeof OffscreenCanvas != 'undefined';
  _emscripten_supports_offscreencanvas.sig = 'i';
  
  var JSEvents = {
  memcpy(target, src, size) {
        HEAP8.set(HEAP8.subarray(src, src + size), target);
      },
  removeAllEventListeners() {
        while (JSEvents.eventHandlers.length) {
          JSEvents._removeHandler(JSEvents.eventHandlers.length - 1);
        }
        JSEvents.deferredCalls = [];
      },
  inEventHandler:0,
  deferredCalls:[],
  deferCall(targetFunction, precedence, argsList) {
        function arraysHaveEqualContent(arrA, arrB) {
          if (arrA.length != arrB.length) return false;
  
          for (var i in arrA) {
            if (arrA[i] != arrB[i]) return false;
          }
          return true;
        }
        // Test if the given call was already queued, and if so, don't add it again.
        for (var call of JSEvents.deferredCalls) {
          if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
            return;
          }
        }
        JSEvents.deferredCalls.push({
          targetFunction,
          precedence,
          argsList
        });
  
        JSEvents.deferredCalls.sort((x,y) => x.precedence < y.precedence);
      },
  removeDeferredCalls(targetFunction) {
        JSEvents.deferredCalls = JSEvents.deferredCalls.filter((call) => call.targetFunction != targetFunction);
      },
  canPerformEventHandlerRequests() {
        if (navigator.userActivation) {
          // Verify against transient activation status from UserActivation API
          // whether it is possible to perform a request here without needing to defer. See
          // https://developer.mozilla.org/en-US/docs/Web/Security/User_activation#transient_activation
          // and https://caniuse.com/mdn-api_useractivation
          // At the time of writing, Firefox does not support this API: https://bugzilla.mozilla.org/show_bug.cgi?id=1791079
          return navigator.userActivation.isActive;
        }
  
        return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
      },
  runDeferredCalls() {
        if (!JSEvents.canPerformEventHandlerRequests()) {
          return;
        }
        var deferredCalls = JSEvents.deferredCalls;
        JSEvents.deferredCalls = [];
        for (var call of deferredCalls) {
          call.targetFunction(...call.argsList);
        }
      },
  eventHandlers:[],
  removeAllHandlersOnTarget:(target, eventTypeString) => {
        for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
          if (JSEvents.eventHandlers[i].target == target &&
            (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i].eventTypeString)) {
             JSEvents._removeHandler(i--);
           }
        }
      },
  _removeHandler(i) {
        var h = JSEvents.eventHandlers[i];
        h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
        JSEvents.eventHandlers.splice(i, 1);
      },
  registerOrRemoveHandler(eventHandler) {
        if (!eventHandler.target) {
          return -4;
        }
        if (eventHandler.callbackfunc) {
          eventHandler.eventListenerFunc = function(event) {
            // Increment nesting count for the event handler.
            ++JSEvents.inEventHandler;
            JSEvents.currentEventHandler = eventHandler;
            // Process any old deferred calls the user has placed.
            JSEvents.runDeferredCalls();
            // Process the actual event, calls back to user C code handler.
            eventHandler.handlerFunc(event);
            // Process any new deferred calls that were placed right now from this event handler.
            JSEvents.runDeferredCalls();
            // Out of event handler - restore nesting count.
            --JSEvents.inEventHandler;
          };
  
          eventHandler.target.addEventListener(eventHandler.eventTypeString,
                                               eventHandler.eventListenerFunc,
                                               eventHandler.useCapture);
          JSEvents.eventHandlers.push(eventHandler);
        } else {
          for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
            if (JSEvents.eventHandlers[i].target == eventHandler.target
             && JSEvents.eventHandlers[i].eventTypeString == eventHandler.eventTypeString) {
               JSEvents._removeHandler(i--);
             }
          }
        }
        return 0;
      },
  getNodeNameForTarget(target) {
        if (!target) return '';
        if (target == window) return '#window';
        if (target == screen) return '#screen';
        return target?.nodeName || '';
      },
  fullscreenEnabled() {
        return document.fullscreenEnabled
        // Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitFullscreenEnabled.
        // TODO: If Safari at some point ships with unprefixed version, update the version check above.
        || document.webkitFullscreenEnabled
         ;
      },
  };
  
  var webglPowerPreferences = ["default","low-power","high-performance"];
  
  var maybeCStringToJsString = (cString) => {
      // "cString > 2" checks if the input is a number, and isn't of the special
      // values we accept here, EMSCRIPTEN_EVENT_TARGET_* (which map to 0, 1, 2).
      // In other words, if cString > 2 then it's a pointer to a valid place in
      // memory, and points to a C string.
      return cString > 2 ? UTF8ToString(cString) : cString;
    };
  
  /** @type {Object} */
  var specialHTMLTargets = [0, document, window];
  var findEventTarget = (target) => {
      target = maybeCStringToJsString(target);
      var domElement = specialHTMLTargets[target] || document.querySelector(target);
      return domElement;
    };
  
  
  var findCanvasEventTarget = (target) => {
      target = maybeCStringToJsString(target);
  
      // When compiling with OffscreenCanvas support and looking up a canvas to target,
      // we first look up if the target Canvas has been transferred to OffscreenCanvas use.
      // These transfers are represented/tracked by GL.offscreenCanvases object, which contain
      // the OffscreenCanvas element for each regular Canvas element that has been transferred.
  
      // Note that each pthread/worker have their own set of GL.offscreenCanvases. That is,
      // when an OffscreenCanvas is transferred from a pthread/main thread to another pthread,
      // it will move in the GL.offscreenCanvases array between threads. Hence GL.offscreenCanvases
      // represents the set of OffscreenCanvases owned by the current calling thread.
  
      // First check out the list of OffscreenCanvases by CSS selector ID ('#myCanvasID')
      return GL.offscreenCanvases[target.substr(1)] // Remove '#' prefix
      // If not found, if one is querying by using DOM tag name selector 'canvas', grab the first
      // OffscreenCanvas that we can find.
       || (target == 'canvas' && Object.keys(GL.offscreenCanvases)[0])
      // If that is not found either, query via the regular DOM selector.
       || document.querySelector(target);
    };
  
  /** @suppress {duplicate } */
  var _emscripten_webgl_do_create_context = (target, attributes) => {
      var attr32 = ((attributes)>>2);
      var powerPreference = HEAP32[attr32 + (8>>2)];
      var contextAttributes = {
        'alpha': !!HEAP8[attributes + 0],
        'depth': !!HEAP8[attributes + 1],
        'stencil': !!HEAP8[attributes + 2],
        'antialias': !!HEAP8[attributes + 3],
        'premultipliedAlpha': !!HEAP8[attributes + 4],
        'preserveDrawingBuffer': !!HEAP8[attributes + 5],
        'powerPreference': webglPowerPreferences[powerPreference],
        'failIfMajorPerformanceCaveat': !!HEAP8[attributes + 12],
        // The following are not predefined WebGL context attributes in the WebGL specification, so the property names can be minified by Closure.
        majorVersion: HEAP32[attr32 + (16>>2)],
        minorVersion: HEAP32[attr32 + (20>>2)],
        enableExtensionsByDefault: HEAP8[attributes + 24],
        explicitSwapControl: HEAP8[attributes + 25],
        proxyContextToMainThread: HEAP32[attr32 + (28>>2)],
        renderViaOffscreenBackBuffer: HEAP8[attributes + 32]
      };
  
      var canvas = findCanvasEventTarget(target);
  
      if (!canvas) {
        return 0;
      }
  
      if (canvas.offscreenCanvas) canvas = canvas.offscreenCanvas;
  
      if (contextAttributes.explicitSwapControl) {
        var supportsOffscreenCanvas = canvas.transferControlToOffscreen || (_emscripten_supports_offscreencanvas() && canvas instanceof OffscreenCanvas);
  
        if (!supportsOffscreenCanvas) {
          return 0;
        }
  
        if (canvas.transferControlToOffscreen) {
          if (!canvas.controlTransferredOffscreen) {
            GL.offscreenCanvases[canvas.id] = {
              canvas: canvas.transferControlToOffscreen(),
              canvasSharedPtr: _malloc(12),
              id: canvas.id
            };
            canvas.controlTransferredOffscreen = true;
          } else if (!GL.offscreenCanvases[canvas.id]) {
            return 0;
          }
          canvas = GL.offscreenCanvases[canvas.id].canvas;
        }
      }
  
      var contextHandle = GL.createContext(canvas, contextAttributes);
      return contextHandle;
    };
  _emscripten_webgl_do_create_context.sig = 'ppp';
  var _emscripten_webgl_create_context = _emscripten_webgl_do_create_context;
  _emscripten_webgl_create_context.sig = 'ppp';

  
  /** @suppress {duplicate } */
  var _emscripten_webgl_do_get_current_context = () => GL.currentContext ? GL.currentContext.handle : 0;
  _emscripten_webgl_do_get_current_context.sig = 'p';
  var _emscripten_webgl_get_current_context = _emscripten_webgl_do_get_current_context;
  _emscripten_webgl_get_current_context.sig = 'p';

  var _emscripten_webgl_make_context_current = (contextHandle) => {
      var success = GL.makeContextCurrent(contextHandle);
      return success ? 0 : -5;
    };
  _emscripten_webgl_make_context_current.sig = 'ip';

  var _emscripten_wget_data = (url, pbuffer, pnum, perror) => {
      throw 'Please compile your program with async support in order to use asynchronous operations like emscripten_wget_data';
    };
  _emscripten_wget_data.sig = 'vpppp';

  
  var getEnvStrings = () => {
      if (!getEnvStrings.strings) {
        // Default values.
        // Browser language detection #8751
        var lang = ((typeof navigator == 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8';
        var env = {
          'USER': 'web_user',
          'LOGNAME': 'web_user',
          'PATH': '/',
          'PWD': '/',
          'HOME': '/home/web_user',
          'LANG': lang,
          '_': getExecutableName()
        };
        // Apply the user-provided values, if any.
        for (var x in ENV) {
          // x is a key in ENV; if ENV[x] is undefined, that means it was
          // explicitly set to be so. We allow user code to do that to
          // force variables with default values to remain unset.
          if (ENV[x] === undefined) delete env[x];
          else env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(`${x}=${env[x]}`);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    };
  
  var stringToAscii = (str, buffer) => {
      for (var i = 0; i < str.length; ++i) {
        HEAP8[buffer++] = str.charCodeAt(i);
      }
      // Null-terminate the string
      HEAP8[buffer] = 0;
    };
  var _environ_get = (__environ, environ_buf) => {
      var bufSize = 0;
      getEnvStrings().forEach((string, i) => {
        var ptr = environ_buf + bufSize;
        HEAPU32[(((__environ)+(i*4))>>2)] = ptr;
        stringToAscii(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    };
  _environ_get.sig = 'ipp';

  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
      var strings = getEnvStrings();
      HEAPU32[((penviron_count)>>2)] = strings.length;
      var bufSize = 0;
      strings.forEach((string) => bufSize += string.length + 1);
      HEAPU32[((penviron_buf_size)>>2)] = bufSize;
      return 0;
    };
  _environ_sizes_get.sig = 'ipp';


  function _fd_close(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  }
  _fd_close.sig = 'ii';

  function _fd_fdstat_get(fd, pbuf) {
  try {
  
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        // All character devices are terminals (other things a Linux system would
        // assume is a character device, like the mouse, we have special APIs for).
        var type = stream.tty ? 2 :
                   FS.isDir(stream.mode) ? 3 :
                   FS.isLink(stream.mode) ? 7 :
                   4;
      }
      HEAP8[pbuf] = type;
      HEAP16[(((pbuf)+(2))>>1)] = flags;
      HEAP64[(((pbuf)+(8))>>3)] = BigInt(rightsBase);
      HEAP64[(((pbuf)+(16))>>3)] = BigInt(rightsInheriting);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  }
  _fd_fdstat_get.sig = 'iip';

  /** @param {number=} offset */
  var doReadv = (stream, iov, iovcnt, offset) => {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.read(stream, HEAP8, ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) break; // nothing more to read
        if (typeof offset != 'undefined') {
          offset += curr;
        }
      }
      return ret;
    };
  
  
  function _fd_pread(fd, iov, iovcnt, offset, pnum) {
    offset = bigintToI53Checked(offset);
  
    
  try {
  
      if (isNaN(offset)) return 61;
      var stream = SYSCALLS.getStreamFromFD(fd)
      var num = doReadv(stream, iov, iovcnt, offset);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  ;
  }
  _fd_pread.sig = 'iippjp';

  /** @param {number=} offset */
  var doWritev = (stream, iov, iovcnt, offset) => {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.write(stream, HEAP8, ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) {
          // No more space to write.
          break;
        }
        if (typeof offset != 'undefined') {
          offset += curr;
        }
      }
      return ret;
    };
  
  
  function _fd_pwrite(fd, iov, iovcnt, offset, pnum) {
    offset = bigintToI53Checked(offset);
  
    
  try {
  
      if (isNaN(offset)) return 61;
      var stream = SYSCALLS.getStreamFromFD(fd)
      var num = doWritev(stream, iov, iovcnt, offset);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  ;
  }
  _fd_pwrite.sig = 'iippjp';

  
  function _fd_read(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  }
  _fd_read.sig = 'iippp';

  
  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);
  
    
  try {
  
      if (isNaN(offset)) return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      HEAP64[((newOffset)>>3)] = BigInt(stream.position);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  ;
  }
  _fd_seek.sig = 'iijip';

  function _fd_sync(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (stream.stream_ops?.fsync) {
        return stream.stream_ops.fsync(stream);
      }
      return 0; // we can't do anything synchronously; the in-memory FS is already synced to
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  }
  _fd_sync.sig = 'ii';

  
  function _fd_write(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  }
  _fd_write.sig = 'iippp';

  
  
  
  
  
  
  
  
  
  var _getaddrinfo = (node, service, hint, out) => {
      // Note getaddrinfo currently only returns a single addrinfo with ai_next defaulting to NULL. When NULL
      // hints are specified or ai_family set to AF_UNSPEC or ai_socktype or ai_protocol set to 0 then we
      // really should provide a linked list of suitable addrinfo values.
      var addrs = [];
      var canon = null;
      var addr = 0;
      var port = 0;
      var flags = 0;
      var family = 0;
      var type = 0;
      var proto = 0;
      var ai, last;
  
      function allocaddrinfo(family, type, proto, canon, addr, port) {
        var sa, salen, ai;
        var errno;
  
        salen = family === 10 ?
          28 :
          16;
        addr = family === 10 ?
          inetNtop6(addr) :
          inetNtop4(addr);
        sa = _malloc(salen);
        errno = writeSockaddr(sa, family, addr, port);
        assert(!errno);
  
        ai = _malloc(32);
        HEAP32[(((ai)+(4))>>2)] = family;
        HEAP32[(((ai)+(8))>>2)] = type;
        HEAP32[(((ai)+(12))>>2)] = proto;
        HEAPU32[(((ai)+(24))>>2)] = canon;
        HEAPU32[(((ai)+(20))>>2)] = sa;
        if (family === 10) {
          HEAP32[(((ai)+(16))>>2)] = 28;
        } else {
          HEAP32[(((ai)+(16))>>2)] = 16;
        }
        HEAP32[(((ai)+(28))>>2)] = 0;
  
        return ai;
      }
  
      if (hint) {
        flags = HEAP32[((hint)>>2)];
        family = HEAP32[(((hint)+(4))>>2)];
        type = HEAP32[(((hint)+(8))>>2)];
        proto = HEAP32[(((hint)+(12))>>2)];
      }
      if (type && !proto) {
        proto = type === 2 ? 17 : 6;
      }
      if (!type && proto) {
        type = proto === 17 ? 2 : 1;
      }
  
      // If type or proto are set to zero in hints we should really be returning multiple addrinfo values, but for
      // now default to a TCP STREAM socket so we can at least return a sensible addrinfo given NULL hints.
      if (proto === 0) {
        proto = 6;
      }
      if (type === 0) {
        type = 1;
      }
  
      if (!node && !service) {
        return -2;
      }
      if (flags & ~(1|2|4|
          1024|8|16|32)) {
        return -1;
      }
      if (hint !== 0 && (HEAP32[((hint)>>2)] & 2) && !node) {
        return -1;
      }
      if (flags & 32) {
        // TODO
        return -2;
      }
      if (type !== 0 && type !== 1 && type !== 2) {
        return -7;
      }
      if (family !== 0 && family !== 2 && family !== 10) {
        return -6;
      }
  
      if (service) {
        service = UTF8ToString(service);
        port = parseInt(service, 10);
  
        if (isNaN(port)) {
          if (flags & 1024) {
            return -2;
          }
          // TODO support resolving well-known service names from:
          // http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt
          return -8;
        }
      }
  
      if (!node) {
        if (family === 0) {
          family = 2;
        }
        if ((flags & 1) === 0) {
          if (family === 2) {
            addr = _htonl(2130706433);
          } else {
            addr = [0, 0, 0, _htonl(1)];
          }
        }
        ai = allocaddrinfo(family, type, proto, null, addr, port);
        HEAPU32[((out)>>2)] = ai;
        return 0;
      }
  
      //
      // try as a numeric address
      //
      node = UTF8ToString(node);
      addr = inetPton4(node);
      if (addr !== null) {
        // incoming node is a valid ipv4 address
        if (family === 0 || family === 2) {
          family = 2;
        }
        else if (family === 10 && (flags & 8)) {
          addr = [0, 0, _htonl(0xffff), addr];
          family = 10;
        } else {
          return -2;
        }
      } else {
        addr = inetPton6(node);
        if (addr !== null) {
          // incoming node is a valid ipv6 address
          if (family === 0 || family === 10) {
            family = 10;
          } else {
            return -2;
          }
        }
      }
      if (addr != null) {
        ai = allocaddrinfo(family, type, proto, node, addr, port);
        HEAPU32[((out)>>2)] = ai;
        return 0;
      }
      if (flags & 4) {
        return -2;
      }
  
      //
      // try as a hostname
      //
      // resolve the hostname to a temporary fake address
      node = DNS.lookup_name(node);
      addr = inetPton4(node);
      if (family === 0) {
        family = 2;
      } else if (family === 10) {
        addr = [0, 0, _htonl(0xffff), addr];
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[((out)>>2)] = ai;
      return 0;
    };
  _getaddrinfo.sig = 'ipppp';

  
  
  
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
      var info = readSockaddr(sa, salen);
      if (info.errno) {
        return -6;
      }
      var port = info.port;
      var addr = info.addr;
  
      var overflowed = false;
  
      if (node && nodelen) {
        var lookup;
        if ((flags & 1) || !(lookup = DNS.lookup_addr(addr))) {
          if (flags & 8) {
            return -2;
          }
        } else {
          addr = lookup;
        }
        var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
  
        if (numBytesWrittenExclNull+1 >= nodelen) {
          overflowed = true;
        }
      }
  
      if (serv && servlen) {
        port = '' + port;
        var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
  
        if (numBytesWrittenExclNull+1 >= servlen) {
          overflowed = true;
        }
      }
  
      if (overflowed) {
        // Note: even when we overflow, getnameinfo() is specced to write out the truncated results.
        return -12;
      }
  
      return 0;
    };
  _getnameinfo.sig = 'ipipipii';

  var Protocols = {
  list:[],
  map:{
  },
  };
  
  
  var _setprotoent = (stayopen) => {
      // void setprotoent(int stayopen);
  
      // Allocate and populate a protoent structure given a name, protocol number and array of aliases
      function allocprotoent(name, proto, aliases) {
        // write name into buffer
        var nameBuf = _malloc(name.length + 1);
        stringToAscii(name, nameBuf);
  
        // write aliases into buffer
        var j = 0;
        var length = aliases.length;
        var aliasListBuf = _malloc((length + 1) * 4); // Use length + 1 so we have space for the terminating NULL ptr.
  
        for (var i = 0; i < length; i++, j += 4) {
          var alias = aliases[i];
          var aliasBuf = _malloc(alias.length + 1);
          stringToAscii(alias, aliasBuf);
          HEAPU32[(((aliasListBuf)+(j))>>2)] = aliasBuf;
        }
        HEAPU32[(((aliasListBuf)+(j))>>2)] = 0; // Terminating NULL pointer.
  
        // generate protoent
        var pe = _malloc(12);
        HEAPU32[((pe)>>2)] = nameBuf;
        HEAPU32[(((pe)+(4))>>2)] = aliasListBuf;
        HEAP32[(((pe)+(8))>>2)] = proto;
        return pe;
      };
  
      // Populate the protocol 'database'. The entries are limited to tcp and udp, though it is fairly trivial
      // to add extra entries from /etc/protocols if desired - though not sure if that'd actually be useful.
      var list = Protocols.list;
      var map  = Protocols.map;
      if (list.length === 0) {
          var entry = allocprotoent('tcp', 6, ['TCP']);
          list.push(entry);
          map['tcp'] = map['6'] = entry;
          entry = allocprotoent('udp', 17, ['UDP']);
          list.push(entry);
          map['udp'] = map['17'] = entry;
      }
  
      _setprotoent.index = 0;
    };
  _setprotoent.sig = 'vi';
  
  
  var _getprotobyname = (name) => {
      // struct protoent *getprotobyname(const char *);
      name = UTF8ToString(name);
      _setprotoent(true);
      var result = Protocols.map[name];
      return result;
    };
  _getprotobyname.sig = 'pp';



  function _random_get(buffer, size) {
  try {
  
      randomFill(HEAPU8.subarray(buffer, buffer + size));
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  }
  _random_get.sig = 'ipp';










  var print = out;


  var FS_createPath = FS.createPath;



  var FS_unlink = (path) => FS.unlink(path);

  var FS_createLazyFile = FS.createLazyFile;

  var FS_createDevice = FS.createDevice;


  var writeI53ToI64Clamped = (ptr, num) => {
      if (num > 0x7FFFFFFFFFFFFFFF) {
        HEAPU32[((ptr)>>2)] = 4294967295;
        HEAPU32[(((ptr)+(4))>>2)] = 2147483647;
      } else if (num < -0x8000000000000000) {
        HEAPU32[((ptr)>>2)] = 0;
        HEAPU32[(((ptr)+(4))>>2)] = 2147483648;
      } else {
        writeI53ToI64(ptr, num);
      }
    };

  var writeI53ToI64Signaling = (ptr, num) => {
      if (num > 0x7FFFFFFFFFFFFFFF || num < -0x8000000000000000) {
        throw `RangeError: ${num}`;
      }
      writeI53ToI64(ptr, num);
    };

  var writeI53ToU64Clamped = (ptr, num) => {
      if (num > 0xFFFFFFFFFFFFFFFF) {
        HEAPU32[((ptr)>>2)] = 4294967295;
        HEAPU32[(((ptr)+(4))>>2)] = 4294967295;
      } else if (num < 0) {
        HEAPU32[((ptr)>>2)] = 0;
        HEAPU32[(((ptr)+(4))>>2)] = 0;
      } else {
        writeI53ToI64(ptr, num);
      }
    };

  var writeI53ToU64Signaling = (ptr, num) => {
      if (num < 0 || num > 0xFFFFFFFFFFFFFFFF) {
        throw `RangeError: ${num}`;
      }
      writeI53ToI64(ptr, num);
    };


  var readI53FromU64 = (ptr) => {
      return HEAPU32[((ptr)>>2)] + HEAPU32[(((ptr)+(4))>>2)] * 4294967296;
    };


  var convertI32PairToI53Checked = (lo, hi) => {
      return ((hi + 0x200000) >>> 0 < 0x400001 - !!lo) ? (lo >>> 0) + hi * 4294967296 : NaN;
    };








  var getTempRet0 = (val) => __emscripten_tempret_get();

  var setTempRet0 = (val) => __emscripten_tempret_set(val);

  var _stackAlloc = stackAlloc;

  var _stackSave = stackSave;

  var _stackRestore = stackSave;

  var _setTempRet0 = setTempRet0;
  Module['_setTempRet0'] = _setTempRet0;

  var _getTempRet0 = getTempRet0;
  Module['_getTempRet0'] = _getTempRet0;

  var ptrToString = (ptr) => {
      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
      ptr >>>= 0;
      return '0x' + ptr.toString(16).padStart(8, '0');
    };








  var _emscripten_notify_memory_growth = (memoryIndex) => {
      updateMemoryViews();
    };
  _emscripten_notify_memory_growth.sig = 'vp';






  
  var withStackSave = (f) => {
      var stack = stackSave();
      var ret = f();
      stackRestore(stack);
      return ret;
    };


  var ERRNO_CODES = {
      'EPERM': 63,
      'ENOENT': 44,
      'ESRCH': 71,
      'EINTR': 27,
      'EIO': 29,
      'ENXIO': 60,
      'E2BIG': 1,
      'ENOEXEC': 45,
      'EBADF': 8,
      'ECHILD': 12,
      'EAGAIN': 6,
      'EWOULDBLOCK': 6,
      'ENOMEM': 48,
      'EACCES': 2,
      'EFAULT': 21,
      'ENOTBLK': 105,
      'EBUSY': 10,
      'EEXIST': 20,
      'EXDEV': 75,
      'ENODEV': 43,
      'ENOTDIR': 54,
      'EISDIR': 31,
      'EINVAL': 28,
      'ENFILE': 41,
      'EMFILE': 33,
      'ENOTTY': 59,
      'ETXTBSY': 74,
      'EFBIG': 22,
      'ENOSPC': 51,
      'ESPIPE': 70,
      'EROFS': 69,
      'EMLINK': 34,
      'EPIPE': 64,
      'EDOM': 18,
      'ERANGE': 68,
      'ENOMSG': 49,
      'EIDRM': 24,
      'ECHRNG': 106,
      'EL2NSYNC': 156,
      'EL3HLT': 107,
      'EL3RST': 108,
      'ELNRNG': 109,
      'EUNATCH': 110,
      'ENOCSI': 111,
      'EL2HLT': 112,
      'EDEADLK': 16,
      'ENOLCK': 46,
      'EBADE': 113,
      'EBADR': 114,
      'EXFULL': 115,
      'ENOANO': 104,
      'EBADRQC': 103,
      'EBADSLT': 102,
      'EDEADLOCK': 16,
      'EBFONT': 101,
      'ENOSTR': 100,
      'ENODATA': 116,
      'ETIME': 117,
      'ENOSR': 118,
      'ENONET': 119,
      'ENOPKG': 120,
      'EREMOTE': 121,
      'ENOLINK': 47,
      'EADV': 122,
      'ESRMNT': 123,
      'ECOMM': 124,
      'EPROTO': 65,
      'EMULTIHOP': 36,
      'EDOTDOT': 125,
      'EBADMSG': 9,
      'ENOTUNIQ': 126,
      'EBADFD': 127,
      'EREMCHG': 128,
      'ELIBACC': 129,
      'ELIBBAD': 130,
      'ELIBSCN': 131,
      'ELIBMAX': 132,
      'ELIBEXEC': 133,
      'ENOSYS': 52,
      'ENOTEMPTY': 55,
      'ENAMETOOLONG': 37,
      'ELOOP': 32,
      'EOPNOTSUPP': 138,
      'EPFNOSUPPORT': 139,
      'ECONNRESET': 15,
      'ENOBUFS': 42,
      'EAFNOSUPPORT': 5,
      'EPROTOTYPE': 67,
      'ENOTSOCK': 57,
      'ENOPROTOOPT': 50,
      'ESHUTDOWN': 140,
      'ECONNREFUSED': 14,
      'EADDRINUSE': 3,
      'ECONNABORTED': 13,
      'ENETUNREACH': 40,
      'ENETDOWN': 38,
      'ETIMEDOUT': 73,
      'EHOSTDOWN': 142,
      'EHOSTUNREACH': 23,
      'EINPROGRESS': 26,
      'EALREADY': 7,
      'EDESTADDRREQ': 17,
      'EMSGSIZE': 35,
      'EPROTONOSUPPORT': 66,
      'ESOCKTNOSUPPORT': 137,
      'EADDRNOTAVAIL': 4,
      'ENETRESET': 39,
      'EISCONN': 30,
      'ENOTCONN': 53,
      'ETOOMANYREFS': 141,
      'EUSERS': 136,
      'EDQUOT': 19,
      'ESTALE': 72,
      'ENOTSUP': 138,
      'ENOMEDIUM': 148,
      'EILSEQ': 25,
      'EOVERFLOW': 61,
      'ECANCELED': 11,
      'ENOTRECOVERABLE': 56,
      'EOWNERDEAD': 62,
      'ESTRPIPE': 135,
    };

  
  
  var strError = (errno) => UTF8ToString(_strerror(errno));













  var _endprotoent = () => {
      // void endprotoent(void);
      // We're not using a real protocol database so we don't do a real close.
    };
  _endprotoent.sig = 'v';

  
  var _getprotoent = (number) => {
      // struct protoent *getprotoent(void);
      // reads the  next  entry  from  the  protocols 'database' or return NULL if 'eof'
      if (_setprotoent.index === Protocols.list.length) {
        return 0;
      }
      var result = Protocols.list[_setprotoent.index++];
      return result;
    };
  _getprotoent.sig = 'p';


  
  var _getprotobynumber = (number) => {
      // struct protoent *getprotobynumber(int proto);
      _setprotoent(true);
      var result = Protocols.map[number];
      return result;
    };
  _getprotobynumber.sig = 'pi';










  var _emscripten_performance_now = () => performance.now();
  _emscripten_performance_now.sig = 'd';




  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  __emscripten_get_now_is_monotonic.sig = 'i';







  
  var _emscripten_print_double = (x, to, max) => {
      var str = x + '';
      if (to) return stringToUTF8(str, to, max);
      else return lengthBytesUTF8(str);
    };
  _emscripten_print_double.sig = 'idpi';





  var _emscripten_asm_const_double = (code, sigPtr, argbuf) => {
      return runEmAsmFunction(code, sigPtr, argbuf);
    };
  _emscripten_asm_const_double.sig = 'dppp';

  var _emscripten_asm_const_ptr = (code, sigPtr, argbuf) => {
      return runEmAsmFunction(code, sigPtr, argbuf);
    };
  _emscripten_asm_const_ptr.sig = 'pppp';

  var runMainThreadEmAsm = (emAsmAddr, sigPtr, argbuf, sync) => {
      var args = readEmAsmArgs(sigPtr, argbuf);
      return ASM_CONSTS[emAsmAddr](...args);
    };

  var _emscripten_asm_const_int_sync_on_main_thread = (emAsmAddr, sigPtr, argbuf) => runMainThreadEmAsm(emAsmAddr, sigPtr, argbuf, 1);
  _emscripten_asm_const_int_sync_on_main_thread.sig = 'ippp';

  var _emscripten_asm_const_ptr_sync_on_main_thread = (emAsmAddr, sigPtr, argbuf) => runMainThreadEmAsm(emAsmAddr, sigPtr, argbuf, 1);
  _emscripten_asm_const_ptr_sync_on_main_thread.sig = 'pppp';

  var _emscripten_asm_const_double_sync_on_main_thread = _emscripten_asm_const_int_sync_on_main_thread;
  _emscripten_asm_const_double_sync_on_main_thread.sig = 'dppp';

  var _emscripten_asm_const_async_on_main_thread = (emAsmAddr, sigPtr, argbuf) => runMainThreadEmAsm(emAsmAddr, sigPtr, argbuf, 0);
  _emscripten_asm_const_async_on_main_thread.sig = 'vppp';


  var jstoi_s = Number;

  
  var __Unwind_Backtrace = (func, arg) => {
      var trace = getCallstack();
      var parts = trace.split('\n');
      for (var i = 0; i < parts.length; i++) {
        var ret = getWasmTableEntry(func)(0, arg);
        if (ret !== 0) return;
      }
    };
  __Unwind_Backtrace.sig = 'ipp';

  var __Unwind_GetIPInfo = (context, ipBefore) => abort('Unwind_GetIPInfo');
  __Unwind_GetIPInfo.sig = 'ppp';

  var __Unwind_FindEnclosingFunction = (ip) => 0;
  __Unwind_FindEnclosingFunction.sig = 'pp';

  var __Unwind_RaiseException = (ex) => {
      err('Warning: _Unwind_RaiseException is not correctly implemented');
      return ___cxa_throw(ex, 0, 0);
    };
  __Unwind_RaiseException.sig = 'ip';

  var __Unwind_DeleteException = (ex) => err('TODO: Unwind_DeleteException');
  __Unwind_DeleteException.sig = 'vp';




  var getDynCaller = (sig, ptr) => {
      return (...args) => dynCall(sig, ptr, args);
    };










  var _emscripten_outn = (str, len) => out(UTF8ToString(str, len));
  _emscripten_outn.sig = 'vpp';


  var _emscripten_errn = (str, len) => err(UTF8ToString(str, len));
  _emscripten_errn.sig = 'vpp';






  var _emscripten_throw_number = (number) => {
      throw number;
    };
  _emscripten_throw_number.sig = 'vd';

  var _emscripten_throw_string = (str) => {
      throw UTF8ToString(str);
    };
  _emscripten_throw_string.sig = 'vp';




  var runtimeKeepalivePush = () => {
      runtimeKeepaliveCounter += 1;
    };
  runtimeKeepalivePush.sig = 'v';

  var runtimeKeepalivePop = () => {
      runtimeKeepaliveCounter -= 1;
    };
  runtimeKeepalivePop.sig = 'v';

  var _emscripten_runtime_keepalive_push = runtimeKeepalivePush;
  _emscripten_runtime_keepalive_push.sig = 'v';

  var _emscripten_runtime_keepalive_pop = runtimeKeepalivePop;
  _emscripten_runtime_keepalive_pop.sig = 'v';

  var _emscripten_runtime_keepalive_check = keepRuntimeAlive;
  _emscripten_runtime_keepalive_check.sig = 'i';



  var asmjsMangle = (x) => {
      if (x == '__main_argc_argv') {
        x = 'main';
      }
      return x.startsWith('dynCall_') ? x : '_' + x;
    };










  var ___global_base = 1024;

  
  
  var __emscripten_fs_load_embedded_files = (ptr) => {
      do {
        var name_addr = HEAPU32[((ptr)>>2)];
        ptr += 4;
        var len = HEAPU32[((ptr)>>2)];
        ptr += 4;
        var content = HEAPU32[((ptr)>>2)];
        ptr += 4;
        var name = UTF8ToString(name_addr)
        FS.createPath('/', PATH.dirname(name), true, true);
        // canOwn this data in the filesystem, it is a slice of wasm memory that will never change
        FS.createDataFile(name, null, HEAP8.subarray(content, content + len), true, true, true);
      } while (HEAPU32[((ptr)>>2)]);
    };
  __emscripten_fs_load_embedded_files.sig = 'vp';


  var POINTER_SIZE = 4;
  function getNativeTypeSize(type) {
    // prettier-ignore
    switch (type) {
      case 'i1': case 'i8': case 'u8': return 1;
      case 'i16': case 'u16': return 2;
      case 'i32': case 'u32': return 4;
      case 'i64': case 'u64': return 8;
      case 'float': return 4;
      case 'double': return 8;
      default: {
        if (type[type.length - 1] === '*') {
          return POINTER_SIZE;
        }
        if (type[0] === 'i') {
          const bits = Number(type.substr(1));
          assert(bits % 8 === 0, `getNativeTypeSize invalid bits ${bits}, ${type} type`);
          return bits / 8;
        }
        return 0;
      }
    }
  }



  var STACK_SIZE = 8388608;

  var STACK_ALIGN = 16;


  var ASSERTIONS = 0;

  var getCFunc = (ident) => {
      var func = Module['_' + ident]; // closure exported function
      return func;
    };

  
  var writeArrayToMemory = (array, buffer) => {
      HEAP8.set(array, buffer);
    };
  
  
  
  
  
  
    /**
     * @param {string|null=} returnType
     * @param {Array=} argTypes
     * @param {Arguments|Array=} args
     * @param {Object=} opts
     */
  var ccall = (ident, returnType, argTypes, args, opts) => {
      // For fast lookup of conversion functions
      var toC = {
        'string': (str) => {
          var ret = 0;
          if (str !== null && str !== undefined && str !== 0) { // null string
            ret = stringToUTF8OnStack(str);
          }
          return ret;
        },
        'array': (arr) => {
          var ret = stackAlloc(arr.length);
          writeArrayToMemory(arr, ret);
          return ret;
        }
      };
  
      function convertReturnValue(ret) {
        if (returnType === 'string') {
          return UTF8ToString(ret);
        }
        if (returnType === 'boolean') return Boolean(ret);
        return ret;
      }
  
      var func = getCFunc(ident);
      var cArgs = [];
      var stack = 0;
      if (args) {
        for (var i = 0; i < args.length; i++) {
          var converter = toC[argTypes[i]];
          if (converter) {
            if (stack === 0) stack = stackSave();
            cArgs[i] = converter(args[i]);
          } else {
            cArgs[i] = args[i];
          }
        }
      }
      var ret = func(...cArgs);
      function onDone(ret) {
        if (stack !== 0) stackRestore(stack);
        return convertReturnValue(ret);
      }
  
      ret = onDone(ret);
      return ret;
    };

  
  
    /**
     * @param {string=} returnType
     * @param {Array=} argTypes
     * @param {Object=} opts
     */
  var cwrap = (ident, returnType, argTypes, opts) => {
      // When the function takes numbers and returns a number, we can just return
      // the original function
      var numericArgs = !argTypes || argTypes.every((type) => type === 'number' || type === 'boolean');
      var numericRet = returnType !== 'string';
      if (numericRet && numericArgs && !opts) {
        return getCFunc(ident);
      }
      return (...args) => ccall(ident, returnType, argTypes, args, opts);
    };











  
  
  
  
  var removeFunction = (index) => {
      functionsInTableMap.delete(getWasmTableEntry(index));
      setWasmTableEntry(index, null);
      freeTableIndexes.push(index);
    };








  var _emscripten_math_cbrt = Math.cbrt;
  _emscripten_math_cbrt.sig = 'dd';

  var _emscripten_math_pow = Math.pow;
  _emscripten_math_pow.sig = 'ddd';

  var _emscripten_math_random = Math.random;
  _emscripten_math_random.sig = 'd';

  var _emscripten_math_sign = Math.sign;
  _emscripten_math_sign.sig = 'dd';

  var _emscripten_math_sqrt = Math.sqrt;
  _emscripten_math_sqrt.sig = 'dd';

  var _emscripten_math_exp = Math.exp;
  _emscripten_math_exp.sig = 'dd';

  var _emscripten_math_expm1 = Math.expm1;
  _emscripten_math_expm1.sig = 'dd';

  var _emscripten_math_fmod = (x, y) => x % y;
  _emscripten_math_fmod.sig = 'ddd';

  var _emscripten_math_log = Math.log;
  _emscripten_math_log.sig = 'dd';

  var _emscripten_math_log1p = Math.log1p;
  _emscripten_math_log1p.sig = 'dd';

  var _emscripten_math_log10 = Math.log10;
  _emscripten_math_log10.sig = 'dd';

  var _emscripten_math_log2 = Math.log2;
  _emscripten_math_log2.sig = 'dd';

  var _emscripten_math_round = Math.round;
  _emscripten_math_round.sig = 'dd';

  var _emscripten_math_acos = Math.acos;
  _emscripten_math_acos.sig = 'dd';

  var _emscripten_math_acosh = Math.acosh;
  _emscripten_math_acosh.sig = 'dd';

  var _emscripten_math_asin = Math.asin;
  _emscripten_math_asin.sig = 'dd';

  var _emscripten_math_asinh = Math.asinh;
  _emscripten_math_asinh.sig = 'dd';

  var _emscripten_math_atan = Math.atan;
  _emscripten_math_atan.sig = 'dd';

  var _emscripten_math_atanh = Math.atanh;
  _emscripten_math_atanh.sig = 'dd';

  var _emscripten_math_atan2 = Math.atan2;
  _emscripten_math_atan2.sig = 'ddd';

  var _emscripten_math_cos = Math.cos;
  _emscripten_math_cos.sig = 'dd';

  var _emscripten_math_cosh = Math.cosh;
  _emscripten_math_cosh.sig = 'dd';

  var _emscripten_math_hypot = (count, varargs) => {
      var args = [];
      for (var i = 0; i < count; ++i) {
        args.push(HEAPF64[(((varargs)+(i * 8))>>3)]);
      }
      return Math.hypot(...args);
    };
  _emscripten_math_hypot.sig = 'dip';

  var _emscripten_math_sin = Math.sin;
  _emscripten_math_sin.sig = 'dd';

  var _emscripten_math_sinh = Math.sinh;
  _emscripten_math_sinh.sig = 'dd';

  var _emscripten_math_tan = Math.tan;
  _emscripten_math_tan.sig = 'dd';

  var _emscripten_math_tanh = Math.tanh;
  _emscripten_math_tanh.sig = 'dd';










  function intArrayToString(array) {
    var ret = [];
    for (var i = 0; i < array.length; i++) {
      var chr = array[i];
      if (chr > 0xFF) {
        chr &= 0xFF;
      }
      ret.push(String.fromCharCode(chr));
    }
    return ret.join('');
  }

  var AsciiToString = (ptr) => {
      var str = '';
      while (1) {
        var ch = HEAPU8[ptr++];
        if (!ch) return str;
        str += String.fromCharCode(ch);
      }
    };













  
  
  
  
  var registerKeyEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      JSEvents.keyEvent ||= _malloc(160);
  
      var keyEventHandlerFunc = (e) => {
  
        var keyEventData = JSEvents.keyEvent;
        HEAPF64[((keyEventData)>>3)] = e.timeStamp;
  
        var idx = ((keyEventData)>>2);
  
        HEAP32[idx + 2] = e.location;
        HEAP8[keyEventData + 12] = e.ctrlKey;
        HEAP8[keyEventData + 13] = e.shiftKey;
        HEAP8[keyEventData + 14] = e.altKey;
        HEAP8[keyEventData + 15] = e.metaKey;
        HEAP8[keyEventData + 16] = e.repeat;
        HEAP32[idx + 5] = e.charCode;
        HEAP32[idx + 6] = e.keyCode;
        HEAP32[idx + 7] = e.which;
        stringToUTF8(e.key || '', keyEventData + 32, 32);
        stringToUTF8(e.code || '', keyEventData + 64, 32);
        stringToUTF8(e.char || '', keyEventData + 96, 32);
        stringToUTF8(e.locale || '', keyEventData + 128, 32);
  
        if (getWasmTableEntry(callbackfunc)(eventTypeId, keyEventData, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: findEventTarget(target),
        eventTypeString,
        callbackfunc,
        handlerFunc: keyEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };





  var _emscripten_set_keypress_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerKeyEventCallback(target, userData, useCapture, callbackfunc, 1, "keypress", targetThread);
  _emscripten_set_keypress_callback_on_thread.sig = 'ippipp';

  var _emscripten_set_keydown_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerKeyEventCallback(target, userData, useCapture, callbackfunc, 2, "keydown", targetThread);
  _emscripten_set_keydown_callback_on_thread.sig = 'ippipp';

  var _emscripten_set_keyup_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerKeyEventCallback(target, userData, useCapture, callbackfunc, 3, "keyup", targetThread);
  _emscripten_set_keyup_callback_on_thread.sig = 'ippipp';

  var getBoundingClientRect = (e) => specialHTMLTargets.indexOf(e) < 0 ? e.getBoundingClientRect() : {'left':0,'top':0};

  
  
  var fillMouseEventData = (eventStruct, e, target) => {
      HEAPF64[((eventStruct)>>3)] = e.timeStamp;
      var idx = ((eventStruct)>>2);
      HEAP32[idx + 2] = e.screenX;
      HEAP32[idx + 3] = e.screenY;
      HEAP32[idx + 4] = e.clientX;
      HEAP32[idx + 5] = e.clientY;
      HEAP8[eventStruct + 24] = e.ctrlKey;
      HEAP8[eventStruct + 25] = e.shiftKey;
      HEAP8[eventStruct + 26] = e.altKey;
      HEAP8[eventStruct + 27] = e.metaKey;
      HEAP16[idx*2 + 14] = e.button;
      HEAP16[idx*2 + 15] = e.buttons;
  
      HEAP32[idx + 8] = e["movementX"]
        ;
  
      HEAP32[idx + 9] = e["movementY"]
        ;
      // default scale values for 2D contexts, which atm don't seem to be affected by css scaling
      var scaleX = 1;
      var scaleY = 1;
      // Note: rect contains doubles (truncated to placate SAFE_HEAP, which is the same behaviour when writing to HEAP32 anyway)
      // use .target{X/Y}
       var rect = getBoundingClientRect(target);
  
      // only scale values for 3D contexts
      if (target.getContext && !target.getContext("2d")) {
        scaleX = target.width / rect.width;
        scaleY = target.height / rect.height;
      }
      HEAP32[idx + 10] = (e.clientX - rect.left) * scaleX;
      HEAP32[idx + 11] = (e.clientY - rect.top) * scaleY;
  
    };

  
  
  
  
  var registerMouseEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      JSEvents.mouseEvent ||= _malloc(64);
      target = findEventTarget(target);
  
      var mouseEventHandlerFunc = (e = event) => {
        // TODO: Make this access thread safe, or this could update live while app is reading it.
        fillMouseEventData(JSEvents.mouseEvent, e, target);
  
        if (getWasmTableEntry(callbackfunc)(eventTypeId, JSEvents.mouseEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target,
        allowsDeferredCalls: eventTypeString != 'mousemove' && eventTypeString != 'mouseenter' && eventTypeString != 'mouseleave', // Mouse move events do not allow fullscreen/pointer lock requests to be handled in them!
        eventTypeString,
        callbackfunc,
        handlerFunc: mouseEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };

  var _emscripten_set_click_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 4, "click", targetThread);
  _emscripten_set_click_callback_on_thread.sig = 'ippipp';

  var _emscripten_set_mousedown_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 5, "mousedown", targetThread);
  _emscripten_set_mousedown_callback_on_thread.sig = 'ippipp';

  var _emscripten_set_mouseup_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 6, "mouseup", targetThread);
  _emscripten_set_mouseup_callback_on_thread.sig = 'ippipp';

  var _emscripten_set_dblclick_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 7, "dblclick", targetThread);
  _emscripten_set_dblclick_callback_on_thread.sig = 'ippipp';

  var _emscripten_set_mousemove_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 8, "mousemove", targetThread);
  _emscripten_set_mousemove_callback_on_thread.sig = 'ippipp';

  var _emscripten_set_mouseenter_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 33, "mouseenter", targetThread);
  _emscripten_set_mouseenter_callback_on_thread.sig = 'ippipp';

  var _emscripten_set_mouseleave_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 34, "mouseleave", targetThread);
  _emscripten_set_mouseleave_callback_on_thread.sig = 'ippipp';

  var _emscripten_set_mouseover_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 35, "mouseover", targetThread);
  _emscripten_set_mouseover_callback_on_thread.sig = 'ippipp';

  var _emscripten_set_mouseout_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 36, "mouseout", targetThread);
  _emscripten_set_mouseout_callback_on_thread.sig = 'ippipp';

  var _emscripten_get_mouse_status = (mouseState) => {
      if (!JSEvents.mouseEvent) return -7;
      // HTML5 does not really have a polling API for mouse events, so implement one manually by
      // returning the data from the most recently received event. This requires that user has registered
      // at least some no-op function as an event handler to any of the mouse function.
      JSEvents.memcpy(mouseState, JSEvents.mouseEvent, 64);
      return 0;
    };
  _emscripten_get_mouse_status.sig = 'ip';

  
  
  
  
  var registerWheelEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      JSEvents.wheelEvent ||= _malloc(96);
  
      // The DOM Level 3 events spec event 'wheel'
      var wheelHandlerFunc = (e = event) => {
        var wheelEvent = JSEvents.wheelEvent;
        fillMouseEventData(wheelEvent, e, target);
        HEAPF64[(((wheelEvent)+(64))>>3)] = e["deltaX"];
        HEAPF64[(((wheelEvent)+(72))>>3)] = e["deltaY"];
        HEAPF64[(((wheelEvent)+(80))>>3)] = e["deltaZ"];
        HEAP32[(((wheelEvent)+(88))>>2)] = e["deltaMode"];
        if (getWasmTableEntry(callbackfunc)(eventTypeId, wheelEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target,
        allowsDeferredCalls: true,
        eventTypeString,
        callbackfunc,
        handlerFunc: wheelHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };

  
  
  var _emscripten_set_wheel_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) => {
      target = findEventTarget(target);
      if (!target) return -4;
      if (typeof target.onwheel != 'undefined') {
        return registerWheelEventCallback(target, userData, useCapture, callbackfunc, 9, "wheel", targetThread);
      } else {
        return -1;
      }
    };
  _emscripten_set_wheel_callback_on_thread.sig = 'ippipp';

  
  
  
  var registerUiEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      JSEvents.uiEvent ||= _malloc(36);
  
      target = findEventTarget(target);
  
      var uiEventHandlerFunc = (e = event) => {
        if (e.target != target) {
          // Never take ui events such as scroll via a 'bubbled' route, but always from the direct element that
          // was targeted. Otherwise e.g. if app logs a message in response to a page scroll, the Emscripten log
          // message box could cause to scroll, generating a new (bubbled) scroll message, causing a new log print,
          // causing a new scroll, etc..
          return;
        }
        var b = document.body; // Take document.body to a variable, Closure compiler does not outline access to it on its own.
        if (!b) {
          // During a page unload 'body' can be null, with "Cannot read property 'clientWidth' of null" being thrown
          return;
        }
        var uiEvent = JSEvents.uiEvent;
        HEAP32[((uiEvent)>>2)] = 0; // always zero for resize and scroll
        HEAP32[(((uiEvent)+(4))>>2)] = b.clientWidth;
        HEAP32[(((uiEvent)+(8))>>2)] = b.clientHeight;
        HEAP32[(((uiEvent)+(12))>>2)] = innerWidth;
        HEAP32[(((uiEvent)+(16))>>2)] = innerHeight;
        HEAP32[(((uiEvent)+(20))>>2)] = outerWidth;
        HEAP32[(((uiEvent)+(24))>>2)] = outerHeight;
        HEAP32[(((uiEvent)+(28))>>2)] = pageXOffset | 0; // scroll offsets are float
        HEAP32[(((uiEvent)+(32))>>2)] = pageYOffset | 0;
        if (getWasmTableEntry(callbackfunc)(eventTypeId, uiEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target,
        eventTypeString,
        callbackfunc,
        handlerFunc: uiEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };

  var _emscripten_set_resize_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerUiEventCallback(target, userData, useCapture, callbackfunc, 10, "resize", targetThread);
  _emscripten_set_resize_callback_on_thread.sig = 'ippipp';

  var _emscripten_set_scroll_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerUiEventCallback(target, userData, useCapture, callbackfunc, 11, "scroll", targetThread);
  _emscripten_set_scroll_callback_on_thread.sig = 'ippipp';

  
  
  
  
  var registerFocusEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      JSEvents.focusEvent ||= _malloc(256);
  
      var focusEventHandlerFunc = (e = event) => {
        var nodeName = JSEvents.getNodeNameForTarget(e.target);
        var id = e.target.id ? e.target.id : '';
  
        var focusEvent = JSEvents.focusEvent;
        stringToUTF8(nodeName, focusEvent + 0, 128);
        stringToUTF8(id, focusEvent + 128, 128);
  
        if (getWasmTableEntry(callbackfunc)(eventTypeId, focusEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: findEventTarget(target),
        eventTypeString,
        callbackfunc,
        handlerFunc: focusEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };

  var _emscripten_set_blur_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerFocusEventCallback(target, userData, useCapture, callbackfunc, 12, "blur", targetThread);
  _emscripten_set_blur_callback_on_thread.sig = 'ippipp';

  var _emscripten_set_focus_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerFocusEventCallback(target, userData, useCapture, callbackfunc, 13, "focus", targetThread);
  _emscripten_set_focus_callback_on_thread.sig = 'ippipp';

  var _emscripten_set_focusin_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerFocusEventCallback(target, userData, useCapture, callbackfunc, 14, "focusin", targetThread);
  _emscripten_set_focusin_callback_on_thread.sig = 'ippipp';

  var _emscripten_set_focusout_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerFocusEventCallback(target, userData, useCapture, callbackfunc, 15, "focusout", targetThread);
  _emscripten_set_focusout_callback_on_thread.sig = 'ippipp';

  var fillDeviceOrientationEventData = (eventStruct, e, target) => {
      HEAPF64[((eventStruct)>>3)] = e.alpha;
      HEAPF64[(((eventStruct)+(8))>>3)] = e.beta;
      HEAPF64[(((eventStruct)+(16))>>3)] = e.gamma;
      HEAP8[(eventStruct)+(24)] = e.absolute;
    };

  
  
  
  var registerDeviceOrientationEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      JSEvents.deviceOrientationEvent ||= _malloc(32);
  
      var deviceOrientationEventHandlerFunc = (e = event) => {
        fillDeviceOrientationEventData(JSEvents.deviceOrientationEvent, e, target); // TODO: Thread-safety with respect to emscripten_get_deviceorientation_status()
  
        if (getWasmTableEntry(callbackfunc)(eventTypeId, JSEvents.deviceOrientationEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: findEventTarget(target),
        eventTypeString,
        callbackfunc,
        handlerFunc: deviceOrientationEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };

  var _emscripten_set_deviceorientation_callback_on_thread = (userData, useCapture, callbackfunc, targetThread) => {
      return registerDeviceOrientationEventCallback(2, userData, useCapture, callbackfunc, 16, "deviceorientation", targetThread);
    };
  _emscripten_set_deviceorientation_callback_on_thread.sig = 'ipipp';

  
  var _emscripten_get_deviceorientation_status = (orientationState) => {
      if (!JSEvents.deviceOrientationEvent) return -7;
      // HTML5 does not really have a polling API for device orientation events, so implement one manually by
      // returning the data from the most recently received event. This requires that user has registered
      // at least some no-op function as an event handler.
      JSEvents.memcpy(orientationState, JSEvents.deviceOrientationEvent, 32);
      return 0;
    };
  _emscripten_get_deviceorientation_status.sig = 'ip';

  var fillDeviceMotionEventData = (eventStruct, e, target) => {
      var supportedFields = 0;
      var a = e['acceleration'];
      supportedFields |= a && 1;
      var ag = e['accelerationIncludingGravity'];
      supportedFields |= ag && 2;
      var rr = e['rotationRate'];
      supportedFields |= rr && 4;
      a = a || {};
      ag = ag || {};
      rr = rr || {};
      HEAPF64[((eventStruct)>>3)] = a["x"];
      HEAPF64[(((eventStruct)+(8))>>3)] = a["y"];
      HEAPF64[(((eventStruct)+(16))>>3)] = a["z"];
      HEAPF64[(((eventStruct)+(24))>>3)] = ag["x"];
      HEAPF64[(((eventStruct)+(32))>>3)] = ag["y"];
      HEAPF64[(((eventStruct)+(40))>>3)] = ag["z"];
      HEAPF64[(((eventStruct)+(48))>>3)] = rr["alpha"];
      HEAPF64[(((eventStruct)+(56))>>3)] = rr["beta"];
      HEAPF64[(((eventStruct)+(64))>>3)] = rr["gamma"];
    };

  
  
  
  
  var registerDeviceMotionEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      JSEvents.deviceMotionEvent ||= _malloc(80);
  
      var deviceMotionEventHandlerFunc = (e = event) => {
        fillDeviceMotionEventData(JSEvents.deviceMotionEvent, e, target); // TODO: Thread-safety with respect to emscripten_get_devicemotion_status()
  
        if (getWasmTableEntry(callbackfunc)(eventTypeId, JSEvents.deviceMotionEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: findEventTarget(target),
        eventTypeString,
        callbackfunc,
        handlerFunc: deviceMotionEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };

  var _emscripten_set_devicemotion_callback_on_thread = (userData, useCapture, callbackfunc, targetThread) =>
      registerDeviceMotionEventCallback(2, userData, useCapture, callbackfunc, 17, "devicemotion", targetThread);
  _emscripten_set_devicemotion_callback_on_thread.sig = 'ipipp';

  var _emscripten_get_devicemotion_status = (motionState) => {
      if (!JSEvents.deviceMotionEvent) return -7;
      // HTML5 does not really have a polling API for device motion events, so implement one manually by
      // returning the data from the most recently received event. This requires that user has registered
      // at least some no-op function as an event handler.
      JSEvents.memcpy(motionState, JSEvents.deviceMotionEvent, 80);
      return 0;
    };
  _emscripten_get_devicemotion_status.sig = 'ip';

  var screenOrientation = () => {
      if (!window.screen) return undefined;
      return screen.orientation || screen['mozOrientation'] || screen['webkitOrientation'];
    };

  var fillOrientationChangeEventData = (eventStruct) => {
      // OrientationType enum
      var orientationsType1 = ['portrait-primary', 'portrait-secondary', 'landscape-primary', 'landscape-secondary'];
      // alternative selection from OrientationLockType enum
      var orientationsType2 = ['portrait',         'portrait',           'landscape',         'landscape'];
  
      var orientationIndex = 0;
      var orientationAngle = 0;
      var screenOrientObj  = screenOrientation();
      if (typeof screenOrientObj === 'object') {
        orientationIndex = orientationsType1.indexOf(screenOrientObj.type);
        if (orientationIndex < 0) {
          orientationIndex = orientationsType2.indexOf(screenOrientObj.type);
        }
        if (orientationIndex >= 0) {
          orientationIndex = 1 << orientationIndex;
        }
        orientationAngle = screenOrientObj.angle;
      }
      else {
        // fallback for Safari earlier than 16.4 (March 2023)
        orientationAngle = window.orientation;
      }
  
      HEAP32[((eventStruct)>>2)] = orientationIndex;
      HEAP32[(((eventStruct)+(4))>>2)] = orientationAngle;
    };

  
  
  
  
  var registerOrientationChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      JSEvents.orientationChangeEvent ||= _malloc(8);
  
      var orientationChangeEventHandlerFunc = (e = event) => {
        var orientationChangeEvent = JSEvents.orientationChangeEvent;
  
        fillOrientationChangeEventData(orientationChangeEvent);
  
        if (getWasmTableEntry(callbackfunc)(eventTypeId, orientationChangeEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target,
        eventTypeString,
        callbackfunc,
        handlerFunc: orientationChangeEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };

  var _emscripten_set_orientationchange_callback_on_thread = (userData, useCapture, callbackfunc, targetThread) => {
      if (!window.screen || !screen.orientation) return -1;
      return registerOrientationChangeEventCallback(screen.orientation, userData, useCapture, callbackfunc, 18, 'change', targetThread);
    };
  _emscripten_set_orientationchange_callback_on_thread.sig = 'ipipp';

  
  var _emscripten_get_orientation_status = (orientationChangeEvent) => {
      // screenOrientation() resolving standard, window.orientation being the deprecated mobile-only
      if (!screenOrientation() && typeof orientation == 'undefined') return -1;
      fillOrientationChangeEventData(orientationChangeEvent);
      return 0;
    };
  _emscripten_get_orientation_status.sig = 'ip';

  var _emscripten_lock_orientation = (allowedOrientations) => {
      var orientations = [];
      if (allowedOrientations & 1) orientations.push("portrait-primary");
      if (allowedOrientations & 2) orientations.push("portrait-secondary");
      if (allowedOrientations & 4) orientations.push("landscape-primary");
      if (allowedOrientations & 8) orientations.push("landscape-secondary");
      var succeeded;
      if (screen.lockOrientation) {
        succeeded = screen.lockOrientation(orientations);
      } else if (screen.mozLockOrientation) {
        succeeded = screen.mozLockOrientation(orientations);
      } else if (screen.webkitLockOrientation) {
        succeeded = screen.webkitLockOrientation(orientations);
      } else {
        return -1;
      }
      if (succeeded) {
        return 0;
      }
      return -6;
    };
  _emscripten_lock_orientation.sig = 'ii';

  var _emscripten_unlock_orientation = () => {
      if (screen.unlockOrientation) {
        screen.unlockOrientation();
      } else if (screen.mozUnlockOrientation) {
        screen.mozUnlockOrientation();
      } else if (screen.webkitUnlockOrientation) {
        screen.webkitUnlockOrientation();
      } else {
        return -1;
      }
      return 0;
    };
  _emscripten_unlock_orientation.sig = 'i';

  
  var fillFullscreenChangeEventData = (eventStruct) => {
      var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
      var isFullscreen = !!fullscreenElement;
      // Assigning a boolean to HEAP32 with expected type coercion.
      /** @suppress{checkTypes} */
      HEAP8[eventStruct] = isFullscreen;
      HEAP8[(eventStruct)+(1)] = JSEvents.fullscreenEnabled();
      // If transitioning to fullscreen, report info about the element that is now fullscreen.
      // If transitioning to windowed mode, report info about the element that just was fullscreen.
      var reportedElement = isFullscreen ? fullscreenElement : JSEvents.previousFullscreenElement;
      var nodeName = JSEvents.getNodeNameForTarget(reportedElement);
      var id = reportedElement?.id || '';
      stringToUTF8(nodeName, eventStruct + 2, 128);
      stringToUTF8(id, eventStruct + 130, 128);
      HEAP32[(((eventStruct)+(260))>>2)] = reportedElement ? reportedElement.clientWidth : 0;
      HEAP32[(((eventStruct)+(264))>>2)] = reportedElement ? reportedElement.clientHeight : 0;
      HEAP32[(((eventStruct)+(268))>>2)] = screen.width;
      HEAP32[(((eventStruct)+(272))>>2)] = screen.height;
      if (isFullscreen) {
        JSEvents.previousFullscreenElement = fullscreenElement;
      }
    };

  
  
  
  
  var registerFullscreenChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      JSEvents.fullscreenChangeEvent ||= _malloc(276);
  
      var fullscreenChangeEventhandlerFunc = (e = event) => {
        var fullscreenChangeEvent = JSEvents.fullscreenChangeEvent;
  
        fillFullscreenChangeEventData(fullscreenChangeEvent);
  
        if (getWasmTableEntry(callbackfunc)(eventTypeId, fullscreenChangeEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target,
        eventTypeString,
        callbackfunc,
        handlerFunc: fullscreenChangeEventhandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };

  
  
  
  var _emscripten_set_fullscreenchange_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) => {
      if (!JSEvents.fullscreenEnabled()) return -1;
      target = findEventTarget(target);
      if (!target) return -4;
  
      // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
      // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
      registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "webkitfullscreenchange", targetThread);
  
      return registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "fullscreenchange", targetThread);
    };
  _emscripten_set_fullscreenchange_callback_on_thread.sig = 'ippipp';

  
  var _emscripten_get_fullscreen_status = (fullscreenStatus) => {
      if (!JSEvents.fullscreenEnabled()) return -1;
      fillFullscreenChangeEventData(fullscreenStatus);
      return 0;
    };
  _emscripten_get_fullscreen_status.sig = 'ip';

  
  
  
  var _emscripten_get_canvas_element_size = (target, width, height) => {
      var canvas = findCanvasEventTarget(target);
      if (!canvas) return -4;
      HEAP32[((width)>>2)] = canvas.width;
      HEAP32[((height)>>2)] = canvas.height;
    };
  _emscripten_get_canvas_element_size.sig = 'ippp';
  
  
  
  var getCanvasElementSize = (target) => {
      var sp = stackSave();
      var w = stackAlloc(8);
      var h = w + 4;
  
      var targetInt = stringToUTF8OnStack(target.id);
      var ret = _emscripten_get_canvas_element_size(targetInt, w, h);
      var size = [HEAP32[((w)>>2)], HEAP32[((h)>>2)]];
      stackRestore(sp);
      return size;
    };
  
  
  var _emscripten_set_canvas_element_size = (target, width, height) => {
      var canvas = findCanvasEventTarget(target);
      if (!canvas) return -4;
      canvas.width = width;
      canvas.height = height;
      return 0;
    };
  _emscripten_set_canvas_element_size.sig = 'ipii';
  
  
  
  var setCanvasElementSize = (target, width, height) => {
      if (!target.controlTransferredOffscreen) {
        target.width = width;
        target.height = height;
      } else {
        // This function is being called from high-level JavaScript code instead of asm.js/Wasm,
        // and it needs to synchronously proxy over to another thread, so marshal the string onto the heap to do the call.
        var sp = stackSave();
        var targetInt = stringToUTF8OnStack(target.id);
        _emscripten_set_canvas_element_size(targetInt, width, height);
        stackRestore(sp);
      }
    };
  
  var registerRestoreOldStyle = (canvas) => {
      var canvasSize = getCanvasElementSize(canvas);
      var oldWidth = canvasSize[0];
      var oldHeight = canvasSize[1];
      var oldCssWidth = canvas.style.width;
      var oldCssHeight = canvas.style.height;
      var oldBackgroundColor = canvas.style.backgroundColor; // Chrome reads color from here.
      var oldDocumentBackgroundColor = document.body.style.backgroundColor; // IE11 reads color from here.
      // Firefox always has black background color.
      var oldPaddingLeft = canvas.style.paddingLeft; // Chrome, FF, Safari
      var oldPaddingRight = canvas.style.paddingRight;
      var oldPaddingTop = canvas.style.paddingTop;
      var oldPaddingBottom = canvas.style.paddingBottom;
      var oldMarginLeft = canvas.style.marginLeft; // IE11
      var oldMarginRight = canvas.style.marginRight;
      var oldMarginTop = canvas.style.marginTop;
      var oldMarginBottom = canvas.style.marginBottom;
      var oldDocumentBodyMargin = document.body.style.margin;
      var oldDocumentOverflow = document.documentElement.style.overflow; // Chrome, Firefox
      var oldDocumentScroll = document.body.scroll; // IE
      var oldImageRendering = canvas.style.imageRendering;
  
      function restoreOldStyle() {
        var fullscreenElement = document.fullscreenElement
          || document.webkitFullscreenElement
          ;
        if (!fullscreenElement) {
          document.removeEventListener('fullscreenchange', restoreOldStyle);
  
          // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
          // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
          document.removeEventListener('webkitfullscreenchange', restoreOldStyle);
  
          setCanvasElementSize(canvas, oldWidth, oldHeight);
  
          canvas.style.width = oldCssWidth;
          canvas.style.height = oldCssHeight;
          canvas.style.backgroundColor = oldBackgroundColor; // Chrome
          // IE11 hack: assigning 'undefined' or an empty string to document.body.style.backgroundColor has no effect, so first assign back the default color
          // before setting the undefined value. Setting undefined value is also important, or otherwise we would later treat that as something that the user
          // had explicitly set so subsequent fullscreen transitions would not set background color properly.
          if (!oldDocumentBackgroundColor) document.body.style.backgroundColor = 'white';
          document.body.style.backgroundColor = oldDocumentBackgroundColor; // IE11
          canvas.style.paddingLeft = oldPaddingLeft; // Chrome, FF, Safari
          canvas.style.paddingRight = oldPaddingRight;
          canvas.style.paddingTop = oldPaddingTop;
          canvas.style.paddingBottom = oldPaddingBottom;
          canvas.style.marginLeft = oldMarginLeft; // IE11
          canvas.style.marginRight = oldMarginRight;
          canvas.style.marginTop = oldMarginTop;
          canvas.style.marginBottom = oldMarginBottom;
          document.body.style.margin = oldDocumentBodyMargin;
          document.documentElement.style.overflow = oldDocumentOverflow; // Chrome, Firefox
          document.body.scroll = oldDocumentScroll; // IE
          canvas.style.imageRendering = oldImageRendering;
          if (canvas.GLctxObject) canvas.GLctxObject.GLctx.viewport(0, 0, oldWidth, oldHeight);
  
          if (currentFullscreenStrategy.canvasResizedCallback) {
            getWasmTableEntry(currentFullscreenStrategy.canvasResizedCallback)(37, 0, currentFullscreenStrategy.canvasResizedCallbackUserData);
          }
        }
      }
      document.addEventListener('fullscreenchange', restoreOldStyle);
      // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
      // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
      document.addEventListener('webkitfullscreenchange', restoreOldStyle);
      return restoreOldStyle;
    };
  
  
  var setLetterbox = (element, topBottom, leftRight) => {
      // Cannot use margin to specify letterboxes in FF or Chrome, since those ignore margins in fullscreen mode.
      element.style.paddingLeft = element.style.paddingRight = leftRight + 'px';
      element.style.paddingTop = element.style.paddingBottom = topBottom + 'px';
    };
  
  
  var JSEvents_resizeCanvasForFullscreen = (target, strategy) => {
      var restoreOldStyle = registerRestoreOldStyle(target);
      var cssWidth = strategy.softFullscreen ? innerWidth : screen.width;
      var cssHeight = strategy.softFullscreen ? innerHeight : screen.height;
      var rect = getBoundingClientRect(target);
      var windowedCssWidth = rect.width;
      var windowedCssHeight = rect.height;
      var canvasSize = getCanvasElementSize(target);
      var windowedRttWidth = canvasSize[0];
      var windowedRttHeight = canvasSize[1];
  
      if (strategy.scaleMode == 3) {
        setLetterbox(target, (cssHeight - windowedCssHeight) / 2, (cssWidth - windowedCssWidth) / 2);
        cssWidth = windowedCssWidth;
        cssHeight = windowedCssHeight;
      } else if (strategy.scaleMode == 2) {
        if (cssWidth*windowedRttHeight < windowedRttWidth*cssHeight) {
          var desiredCssHeight = windowedRttHeight * cssWidth / windowedRttWidth;
          setLetterbox(target, (cssHeight - desiredCssHeight) / 2, 0);
          cssHeight = desiredCssHeight;
        } else {
          var desiredCssWidth = windowedRttWidth * cssHeight / windowedRttHeight;
          setLetterbox(target, 0, (cssWidth - desiredCssWidth) / 2);
          cssWidth = desiredCssWidth;
        }
      }
  
      // If we are adding padding, must choose a background color or otherwise Chrome will give the
      // padding a default white color. Do it only if user has not customized their own background color.
      target.style.backgroundColor ||= 'black';
      // IE11 does the same, but requires the color to be set in the document body.
      document.body.style.backgroundColor ||= 'black'; // IE11
      // Firefox always shows black letterboxes independent of style color.
  
      target.style.width = cssWidth + 'px';
      target.style.height = cssHeight + 'px';
  
      if (strategy.filteringMode == 1) {
        target.style.imageRendering = 'optimizeSpeed';
        target.style.imageRendering = '-moz-crisp-edges';
        target.style.imageRendering = '-o-crisp-edges';
        target.style.imageRendering = '-webkit-optimize-contrast';
        target.style.imageRendering = 'optimize-contrast';
        target.style.imageRendering = 'crisp-edges';
        target.style.imageRendering = 'pixelated';
      }
  
      var dpiScale = (strategy.canvasResolutionScaleMode == 2) ? devicePixelRatio : 1;
      if (strategy.canvasResolutionScaleMode != 0) {
        var newWidth = (cssWidth * dpiScale)|0;
        var newHeight = (cssHeight * dpiScale)|0;
        setCanvasElementSize(target, newWidth, newHeight);
        if (target.GLctxObject) target.GLctxObject.GLctx.viewport(0, 0, newWidth, newHeight);
      }
      return restoreOldStyle;
    };
  
  var JSEvents_requestFullscreen = (target, strategy) => {
      // EMSCRIPTEN_FULLSCREEN_SCALE_DEFAULT + EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_NONE is a mode where no extra logic is performed to the DOM elements.
      if (strategy.scaleMode != 0 || strategy.canvasResolutionScaleMode != 0) {
        JSEvents_resizeCanvasForFullscreen(target, strategy);
      }
  
      if (target.requestFullscreen) {
        target.requestFullscreen();
      } else if (target.webkitRequestFullscreen) {
        target.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
      } else {
        return JSEvents.fullscreenEnabled() ? -3 : -1;
      }
  
      currentFullscreenStrategy = strategy;
  
      if (strategy.canvasResizedCallback) {
        getWasmTableEntry(strategy.canvasResizedCallback)(37, 0, strategy.canvasResizedCallbackUserData);
      }
  
      return 0;
    };



  var hideEverythingExceptGivenElement = (onlyVisibleElement) => {
      var child = onlyVisibleElement;
      var parent = child.parentNode;
      var hiddenElements = [];
      while (child != document.body) {
        var children = parent.children;
        for (var i = 0; i < children.length; ++i) {
          if (children[i] != child) {
            hiddenElements.push({ node: children[i], displayState: children[i].style.display });
            children[i].style.display = 'none';
          }
        }
        child = parent;
        parent = parent.parentNode;
      }
      return hiddenElements;
    };

  var restoreHiddenElements = (hiddenElements) => {
      for (var elem of hiddenElements) {
        elem.node.style.display = elem.displayState;
      }
    };


  var currentFullscreenStrategy = {
  };

  var restoreOldWindowedStyle = null;

  
  
  
  
  
  
  var softFullscreenResizeWebGLRenderTarget = () => {
      var dpr = devicePixelRatio;
      var inHiDPIFullscreenMode = currentFullscreenStrategy.canvasResolutionScaleMode == 2;
      var inAspectRatioFixedFullscreenMode = currentFullscreenStrategy.scaleMode == 2;
      var inPixelPerfectFullscreenMode = currentFullscreenStrategy.canvasResolutionScaleMode != 0;
      var inCenteredWithoutScalingFullscreenMode = currentFullscreenStrategy.scaleMode == 3;
      var screenWidth = inHiDPIFullscreenMode ? Math.round(innerWidth*dpr) : innerWidth;
      var screenHeight = inHiDPIFullscreenMode ? Math.round(innerHeight*dpr) : innerHeight;
      var w = screenWidth;
      var h = screenHeight;
      var canvas = currentFullscreenStrategy.target;
      var canvasSize = getCanvasElementSize(canvas);
      var x = canvasSize[0];
      var y = canvasSize[1];
      var topMargin;
  
      if (inAspectRatioFixedFullscreenMode) {
        if (w*y < x*h) h = (w * y / x) | 0;
        else if (w*y > x*h) w = (h * x / y) | 0;
        topMargin = ((screenHeight - h) / 2) | 0;
      }
  
      if (inPixelPerfectFullscreenMode) {
        setCanvasElementSize(canvas, w, h);
        if (canvas.GLctxObject) canvas.GLctxObject.GLctx.viewport(0, 0, w, h);
      }
  
      // Back to CSS pixels.
      if (inHiDPIFullscreenMode) {
        topMargin /= dpr;
        w /= dpr;
        h /= dpr;
        // Round to nearest 4 digits of precision.
        w = Math.round(w*1e4)/1e4;
        h = Math.round(h*1e4)/1e4;
        topMargin = Math.round(topMargin*1e4)/1e4;
      }
  
      if (inCenteredWithoutScalingFullscreenMode) {
        var t = (innerHeight - jstoi_q(canvas.style.height)) / 2;
        var b = (innerWidth - jstoi_q(canvas.style.width)) / 2;
        setLetterbox(canvas, t, b);
      } else {
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        var b = (innerWidth - w) / 2;
        setLetterbox(canvas, topMargin, b);
      }
  
      if (!inCenteredWithoutScalingFullscreenMode && currentFullscreenStrategy.canvasResizedCallback) {
        getWasmTableEntry(currentFullscreenStrategy.canvasResizedCallback)(37, 0, currentFullscreenStrategy.canvasResizedCallbackUserData);
      }
    };

  
  
  
  
  
  
  
  var doRequestFullscreen = (target, strategy) => {
      if (!JSEvents.fullscreenEnabled()) return -1;
      target = findEventTarget(target);
      if (!target) return -4;
  
      if (!target.requestFullscreen
        && !target.webkitRequestFullscreen
        ) {
        return -3;
      }
  
      // Queue this function call if we're not currently in an event handler and
      // the user saw it appropriate to do so.
      if (!JSEvents.canPerformEventHandlerRequests()) {
        if (strategy.deferUntilInEventHandler) {
          JSEvents.deferCall(JSEvents_requestFullscreen, 1 /* priority over pointer lock */, [target, strategy]);
          return 1;
        }
        return -2;
      }
  
      return JSEvents_requestFullscreen(target, strategy);
    };

  var _emscripten_request_fullscreen = (target, deferUntilInEventHandler) => {
      var strategy = {
        // These options perform no added logic, but just bare request fullscreen.
        scaleMode: 0,
        canvasResolutionScaleMode: 0,
        filteringMode: 0,
        deferUntilInEventHandler,
        canvasResizedCallbackTargetThread: 2
      };
      return doRequestFullscreen(target, strategy);
    };
  _emscripten_request_fullscreen.sig = 'ipi';

  
  
  var _emscripten_request_fullscreen_strategy = (target, deferUntilInEventHandler, fullscreenStrategy) => {
      var strategy = {
        scaleMode: HEAP32[((fullscreenStrategy)>>2)],
        canvasResolutionScaleMode: HEAP32[(((fullscreenStrategy)+(4))>>2)],
        filteringMode: HEAP32[(((fullscreenStrategy)+(8))>>2)],
        deferUntilInEventHandler,
        canvasResizedCallback: HEAP32[(((fullscreenStrategy)+(12))>>2)],
        canvasResizedCallbackUserData: HEAP32[(((fullscreenStrategy)+(16))>>2)]
      };
  
      return doRequestFullscreen(target, strategy);
    };
  _emscripten_request_fullscreen_strategy.sig = 'ipip';

  
  
  
  
  
  
  
  
  
  
  
  
  var _emscripten_enter_soft_fullscreen = (target, fullscreenStrategy) => {
      target = findEventTarget(target);
      if (!target) return -4;
  
      var strategy = {
          scaleMode: HEAP32[((fullscreenStrategy)>>2)],
          canvasResolutionScaleMode: HEAP32[(((fullscreenStrategy)+(4))>>2)],
          filteringMode: HEAP32[(((fullscreenStrategy)+(8))>>2)],
          canvasResizedCallback: HEAP32[(((fullscreenStrategy)+(12))>>2)],
          canvasResizedCallbackUserData: HEAP32[(((fullscreenStrategy)+(16))>>2)],
          target,
          softFullscreen: true
      };
  
      var restoreOldStyle = JSEvents_resizeCanvasForFullscreen(target, strategy);
  
      document.documentElement.style.overflow = 'hidden';  // Firefox, Chrome
      document.body.scroll = "no"; // IE11
      document.body.style.margin = '0px'; // Override default document margin area on all browsers.
  
      var hiddenElements = hideEverythingExceptGivenElement(target);
  
      function restoreWindowedState() {
        restoreOldStyle();
        restoreHiddenElements(hiddenElements);
        removeEventListener('resize', softFullscreenResizeWebGLRenderTarget);
        if (strategy.canvasResizedCallback) {
          getWasmTableEntry(strategy.canvasResizedCallback)(37, 0, strategy.canvasResizedCallbackUserData);
        }
        currentFullscreenStrategy = 0;
      }
      restoreOldWindowedStyle = restoreWindowedState;
      currentFullscreenStrategy = strategy;
      addEventListener('resize', softFullscreenResizeWebGLRenderTarget);
  
      // Inform the caller that the canvas size has changed.
      if (strategy.canvasResizedCallback) {
        getWasmTableEntry(strategy.canvasResizedCallback)(37, 0, strategy.canvasResizedCallbackUserData);
      }
  
      return 0;
    };
  _emscripten_enter_soft_fullscreen.sig = 'ipp';

  var _emscripten_exit_soft_fullscreen = () => {
      restoreOldWindowedStyle?.();
      restoreOldWindowedStyle = null;
  
      return 0;
    };
  _emscripten_exit_soft_fullscreen.sig = 'i';

  
  
  
  var _emscripten_exit_fullscreen = () => {
      if (!JSEvents.fullscreenEnabled()) return -1;
      // Make sure no queued up calls will fire after this.
      JSEvents.removeDeferredCalls(JSEvents_requestFullscreen);
  
      var d = specialHTMLTargets[1];
      if (d.exitFullscreen) {
        d.fullscreenElement && d.exitFullscreen();
      } else if (d.webkitExitFullscreen) {
        d.webkitFullscreenElement && d.webkitExitFullscreen();
      } else {
        return -1;
      }
  
      return 0;
    };
  _emscripten_exit_fullscreen.sig = 'i';

  
  var fillPointerlockChangeEventData = (eventStruct) => {
      var pointerLockElement = document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement || document.msPointerLockElement;
      var isPointerlocked = !!pointerLockElement;
      // Assigning a boolean to HEAP32 with expected type coercion.
      /** @suppress{checkTypes} */
      HEAP8[eventStruct] = isPointerlocked;
      var nodeName = JSEvents.getNodeNameForTarget(pointerLockElement);
      var id = pointerLockElement?.id || '';
      stringToUTF8(nodeName, eventStruct + 1, 128);
      stringToUTF8(id, eventStruct + 129, 128);
    };

  
  
  
  
  var registerPointerlockChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      JSEvents.pointerlockChangeEvent ||= _malloc(257);
  
      var pointerlockChangeEventHandlerFunc = (e = event) => {
        var pointerlockChangeEvent = JSEvents.pointerlockChangeEvent;
        fillPointerlockChangeEventData(pointerlockChangeEvent);
  
        if (getWasmTableEntry(callbackfunc)(eventTypeId, pointerlockChangeEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target,
        eventTypeString,
        callbackfunc,
        handlerFunc: pointerlockChangeEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };

  
  
  
  /** @suppress {missingProperties} */
  var _emscripten_set_pointerlockchange_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) => {
      // TODO: Currently not supported in pthreads or in --proxy-to-worker mode. (In pthreads mode, document object is not defined)
      if (!document || !document.body || (!document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock)) {
        return -1;
      }
  
      target = findEventTarget(target);
      if (!target) return -4;
      registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "mozpointerlockchange", targetThread);
      registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "webkitpointerlockchange", targetThread);
      registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "mspointerlockchange", targetThread);
      return registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "pointerlockchange", targetThread);
    };
  _emscripten_set_pointerlockchange_callback_on_thread.sig = 'ippipp';

  
  
  
  var registerPointerlockErrorEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
  
      var pointerlockErrorEventHandlerFunc = (e = event) => {
        if (getWasmTableEntry(callbackfunc)(eventTypeId, 0, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target,
        eventTypeString,
        callbackfunc,
        handlerFunc: pointerlockErrorEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };

  
  
  
  /** @suppress {missingProperties} */
  var _emscripten_set_pointerlockerror_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) => {
      // TODO: Currently not supported in pthreads or in --proxy-to-worker mode. (In pthreads mode, document object is not defined)
      if (!document || !document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock) {
        return -1;
      }
  
      target = findEventTarget(target);
  
      if (!target) return -4;
      registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "mozpointerlockerror", targetThread);
      registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "webkitpointerlockerror", targetThread);
      registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "mspointerlockerror", targetThread);
      return registerPointerlockErrorEventCallback(target, userData, useCapture, callbackfunc, 38, "pointerlockerror", targetThread);
    };
  _emscripten_set_pointerlockerror_callback_on_thread.sig = 'ippipp';

  /** @suppress {missingProperties} */
  var _emscripten_get_pointerlock_status = (pointerlockStatus) => {
      if (pointerlockStatus) fillPointerlockChangeEventData(pointerlockStatus);
      if (!document.body || (!document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock)) {
        return -1;
      }
      return 0;
    };
  _emscripten_get_pointerlock_status.sig = 'ip';

  var requestPointerLock = (target) => {
      if (target.requestPointerLock) {
        target.requestPointerLock();
      } else {
        // document.body is known to accept pointer lock, so use that to differentiate if the user passed a bad element,
        // or if the whole browser just doesn't support the feature.
        if (document.body.requestPointerLock
          ) {
          return -3;
        }
        return -1;
      }
      return 0;
    };

  
  
  var _emscripten_request_pointerlock = (target, deferUntilInEventHandler) => {
      target = findEventTarget(target);
      if (!target) return -4;
      if (!target.requestPointerLock
        ) {
        return -1;
      }
  
      // Queue this function call if we're not currently in an event handler and
      // the user saw it appropriate to do so.
      if (!JSEvents.canPerformEventHandlerRequests()) {
        if (deferUntilInEventHandler) {
          JSEvents.deferCall(requestPointerLock, 2 /* priority below fullscreen */, [target]);
          return 1;
        }
        return -2;
      }
  
      return requestPointerLock(target);
    };
  _emscripten_request_pointerlock.sig = 'ipi';

  
  var _emscripten_exit_pointerlock = () => {
      // Make sure no queued up calls will fire after this.
      JSEvents.removeDeferredCalls(requestPointerLock);
  
      if (document.exitPointerLock) {
        document.exitPointerLock();
      } else {
        return -1;
      }
      return 0;
    };
  _emscripten_exit_pointerlock.sig = 'i';

  var _emscripten_vibrate = (msecs) => {
      if (!navigator.vibrate) return -1;
      navigator.vibrate(msecs);
      return 0;
    };
  _emscripten_vibrate.sig = 'ii';

  var _emscripten_vibrate_pattern = (msecsArray, numEntries) => {
      if (!navigator.vibrate) return -1;
  
      var vibrateList = [];
      for (var i = 0; i < numEntries; ++i) {
        var msecs = HEAP32[(((msecsArray)+(i*4))>>2)];
        vibrateList.push(msecs);
      }
      navigator.vibrate(vibrateList);
      return 0;
    };
  _emscripten_vibrate_pattern.sig = 'ipi';

  var fillVisibilityChangeEventData = (eventStruct) => {
      var visibilityStates = [ "hidden", "visible", "prerender", "unloaded" ];
      var visibilityState = visibilityStates.indexOf(document.visibilityState);
  
      // Assigning a boolean to HEAP32 with expected type coercion.
      /** @suppress{checkTypes} */
      HEAP8[eventStruct] = document.hidden;
      HEAP32[(((eventStruct)+(4))>>2)] = visibilityState;
    };

  
  
  
  
  var registerVisibilityChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      JSEvents.visibilityChangeEvent ||= _malloc(8);
  
      var visibilityChangeEventHandlerFunc = (e = event) => {
        var visibilityChangeEvent = JSEvents.visibilityChangeEvent;
  
        fillVisibilityChangeEventData(visibilityChangeEvent);
  
        if (getWasmTableEntry(callbackfunc)(eventTypeId, visibilityChangeEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target,
        eventTypeString,
        callbackfunc,
        handlerFunc: visibilityChangeEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };

  
  var _emscripten_set_visibilitychange_callback_on_thread = (userData, useCapture, callbackfunc, targetThread) => {
      return registerVisibilityChangeEventCallback(specialHTMLTargets[1], userData, useCapture, callbackfunc, 21, "visibilitychange", targetThread);
    };
  _emscripten_set_visibilitychange_callback_on_thread.sig = 'ipipp';

  var _emscripten_get_visibility_status = (visibilityStatus) => {
      if (typeof document.visibilityState == 'undefined' && typeof document.hidden == 'undefined') {
        return -1;
      }
      fillVisibilityChangeEventData(visibilityStatus);
      return 0;
    };
  _emscripten_get_visibility_status.sig = 'ip';

  
  
  
  
  var registerTouchEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      JSEvents.touchEvent ||= _malloc(1552);
  
      target = findEventTarget(target);
  
      var touchEventHandlerFunc = (e) => {
        var t, touches = {}, et = e.touches;
        // To ease marshalling different kinds of touches that browser reports (all touches are listed in e.touches,
        // only changed touches in e.changedTouches, and touches on target at a.targetTouches), mark a boolean in
        // each Touch object so that we can later loop only once over all touches we see to marshall over to Wasm.
  
        for (let t of et) {
          // Browser might recycle the generated Touch objects between each frame (Firefox on Android), so reset any
          // changed/target states we may have set from previous frame.
          t.isChanged = t.onTarget = 0;
          touches[t.identifier] = t;
        }
        // Mark which touches are part of the changedTouches list.
        for (let t of e.changedTouches) {
          t.isChanged = 1;
          touches[t.identifier] = t;
        }
        // Mark which touches are part of the targetTouches list.
        for (let t of e.targetTouches) {
          touches[t.identifier].onTarget = 1;
        }
  
        var touchEvent = JSEvents.touchEvent;
        HEAPF64[((touchEvent)>>3)] = e.timeStamp;
        HEAP8[touchEvent + 12] = e.ctrlKey;
        HEAP8[touchEvent + 13] = e.shiftKey;
        HEAP8[touchEvent + 14] = e.altKey;
        HEAP8[touchEvent + 15] = e.metaKey;
        var idx = touchEvent + 16;
        var targetRect = getBoundingClientRect(target);
        var numTouches = 0;
        for (let t of Object.values(touches)) {
          var idx32 = ((idx)>>2); // Pre-shift the ptr to index to HEAP32 to save code size
          HEAP32[idx32 + 0] = t.identifier;
          HEAP32[idx32 + 1] = t.screenX;
          HEAP32[idx32 + 2] = t.screenY;
          HEAP32[idx32 + 3] = t.clientX;
          HEAP32[idx32 + 4] = t.clientY;
          HEAP32[idx32 + 5] = t.pageX;
          HEAP32[idx32 + 6] = t.pageY;
          HEAP8[idx + 28] = t.isChanged;
          HEAP8[idx + 29] = t.onTarget;
          HEAP32[idx32 + 8] = t.clientX - (targetRect.left | 0);
          HEAP32[idx32 + 9] = t.clientY - (targetRect.top  | 0);
  
          idx += 48;
  
          if (++numTouches > 31) {
            break;
          }
        }
        HEAP32[(((touchEvent)+(8))>>2)] = numTouches;
  
        if (getWasmTableEntry(callbackfunc)(eventTypeId, touchEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target,
        allowsDeferredCalls: eventTypeString == 'touchstart' || eventTypeString == 'touchend',
        eventTypeString,
        callbackfunc,
        handlerFunc: touchEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };

  var _emscripten_set_touchstart_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerTouchEventCallback(target, userData, useCapture, callbackfunc, 22, "touchstart", targetThread);
  _emscripten_set_touchstart_callback_on_thread.sig = 'ippipp';

  var _emscripten_set_touchend_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerTouchEventCallback(target, userData, useCapture, callbackfunc, 23, "touchend", targetThread);
  _emscripten_set_touchend_callback_on_thread.sig = 'ippipp';

  var _emscripten_set_touchmove_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerTouchEventCallback(target, userData, useCapture, callbackfunc, 24, "touchmove", targetThread);
  _emscripten_set_touchmove_callback_on_thread.sig = 'ippipp';

  var _emscripten_set_touchcancel_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>
      registerTouchEventCallback(target, userData, useCapture, callbackfunc, 25, "touchcancel", targetThread);
  _emscripten_set_touchcancel_callback_on_thread.sig = 'ippipp';

  var fillGamepadEventData = (eventStruct, e) => {
      HEAPF64[((eventStruct)>>3)] = e.timestamp;
      for (var i = 0; i < e.axes.length; ++i) {
        HEAPF64[(((eventStruct+i*8)+(16))>>3)] = e.axes[i];
      }
      for (var i = 0; i < e.buttons.length; ++i) {
        if (typeof e.buttons[i] == 'object') {
          HEAPF64[(((eventStruct+i*8)+(528))>>3)] = e.buttons[i].value;
        } else {
          HEAPF64[(((eventStruct+i*8)+(528))>>3)] = e.buttons[i];
        }
      }
      for (var i = 0; i < e.buttons.length; ++i) {
        if (typeof e.buttons[i] == 'object') {
          HEAP8[(eventStruct+i)+(1040)] = e.buttons[i].pressed;
        } else {
          // Assigning a boolean to HEAP32, that's ok, but Closure would like to warn about it:
          /** @suppress {checkTypes} */
          HEAP8[(eventStruct+i)+(1040)] = e.buttons[i] == 1;
        }
      }
      HEAP8[(eventStruct)+(1104)] = e.connected;
      HEAP32[(((eventStruct)+(1108))>>2)] = e.index;
      HEAP32[(((eventStruct)+(8))>>2)] = e.axes.length;
      HEAP32[(((eventStruct)+(12))>>2)] = e.buttons.length;
      stringToUTF8(e.id, eventStruct + 1112, 64);
      stringToUTF8(e.mapping, eventStruct + 1176, 64);
    };

  
  
  
  
  var registerGamepadEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      JSEvents.gamepadEvent ||= _malloc(1240);
  
      var gamepadEventHandlerFunc = (e = event) => {
        var gamepadEvent = JSEvents.gamepadEvent;
        fillGamepadEventData(gamepadEvent, e["gamepad"]);
  
        if (getWasmTableEntry(callbackfunc)(eventTypeId, gamepadEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: findEventTarget(target),
        allowsDeferredCalls: true,
        eventTypeString,
        callbackfunc,
        handlerFunc: gamepadEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };

  
  /** @suppress {checkTypes} */
  var _emscripten_sample_gamepad_data = () => {
      try {
        if (navigator.getGamepads) return (JSEvents.lastGamepadState = navigator.getGamepads())
          ? 0 : -1;
      } catch(e) {
        navigator.getGamepads = null; // Disable getGamepads() so that it won't be attempted to be used again.
      }
      return -1;
    };
  _emscripten_sample_gamepad_data.sig = 'i';
  var _emscripten_set_gamepadconnected_callback_on_thread = (userData, useCapture, callbackfunc, targetThread) => {
      if (_emscripten_sample_gamepad_data()) return -1;
      return registerGamepadEventCallback(2, userData, useCapture, callbackfunc, 26, "gamepadconnected", targetThread);
    };
  _emscripten_set_gamepadconnected_callback_on_thread.sig = 'ipipp';

  
  var _emscripten_set_gamepaddisconnected_callback_on_thread = (userData, useCapture, callbackfunc, targetThread) => {
      if (_emscripten_sample_gamepad_data()) return -1;
      return registerGamepadEventCallback(2, userData, useCapture, callbackfunc, 27, "gamepaddisconnected", targetThread);
    };
  _emscripten_set_gamepaddisconnected_callback_on_thread.sig = 'ipipp';


  var _emscripten_get_num_gamepads = () => {
      // N.B. Do not call emscripten_get_num_gamepads() unless having first called emscripten_sample_gamepad_data(), and that has returned EMSCRIPTEN_RESULT_SUCCESS.
      // Otherwise the following line will throw an exception.
      return JSEvents.lastGamepadState.length;
    };
  _emscripten_get_num_gamepads.sig = 'i';

  
  var _emscripten_get_gamepad_status = (index, gamepadState) => {
      // INVALID_PARAM is returned on a Gamepad index that never was there.
      if (index < 0 || index >= JSEvents.lastGamepadState.length) return -5;
  
      // NO_DATA is returned on a Gamepad index that was removed.
      // For previously disconnected gamepads there should be an empty slot (null/undefined/false) at the index.
      // This is because gamepads must keep their original position in the array.
      // For example, removing the first of two gamepads produces [null/undefined/false, gamepad].
      if (!JSEvents.lastGamepadState[index]) return -7;
  
      fillGamepadEventData(gamepadState, JSEvents.lastGamepadState[index]);
      return 0;
    };
  _emscripten_get_gamepad_status.sig = 'iip';

  
  
  
  var registerBeforeUnloadEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString) => {
      var beforeUnloadEventHandlerFunc = (e = event) => {
        // Note: This is always called on the main browser thread, since it needs synchronously return a value!
        var confirmationMessage = getWasmTableEntry(callbackfunc)(eventTypeId, 0, userData);
  
        if (confirmationMessage) {
          confirmationMessage = UTF8ToString(confirmationMessage);
        }
        if (confirmationMessage) {
          e.preventDefault();
          e.returnValue = confirmationMessage;
          return confirmationMessage;
        }
      };
  
      var eventHandler = {
        target: findEventTarget(target),
        eventTypeString,
        callbackfunc,
        handlerFunc: beforeUnloadEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };

  var _emscripten_set_beforeunload_callback_on_thread = (userData, callbackfunc, targetThread) => {
      if (typeof onbeforeunload == 'undefined') return -1;
      // beforeunload callback can only be registered on the main browser thread, because the page will go away immediately after returning from the handler,
      // and there is no time to start proxying it anywhere.
      if (targetThread !== 1) return -5;
      return registerBeforeUnloadEventCallback(2, userData, true, callbackfunc, 28, "beforeunload");
    };
  _emscripten_set_beforeunload_callback_on_thread.sig = 'ippp';

  var fillBatteryEventData = (eventStruct, e) => {
      HEAPF64[((eventStruct)>>3)] = e.chargingTime;
      HEAPF64[(((eventStruct)+(8))>>3)] = e.dischargingTime;
      HEAPF64[(((eventStruct)+(16))>>3)] = e.level;
      HEAP8[(eventStruct)+(24)] = e.charging;
    };

  var battery = () => navigator.battery || navigator.mozBattery || navigator.webkitBattery;

  
  
  
  
  
  var registerBatteryEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
      JSEvents.batteryEvent ||= _malloc(32);
  
      var batteryEventHandlerFunc = (e = event) => {
        var batteryEvent = JSEvents.batteryEvent;
        fillBatteryEventData(batteryEvent, battery());
  
        if (getWasmTableEntry(callbackfunc)(eventTypeId, batteryEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: findEventTarget(target),
        eventTypeString,
        callbackfunc,
        handlerFunc: batteryEventHandlerFunc,
        useCapture
      };
      return JSEvents.registerOrRemoveHandler(eventHandler);
    };

  
  var _emscripten_set_batterychargingchange_callback_on_thread = (userData, callbackfunc, targetThread) => {
      if (!battery()) return -1;
      return registerBatteryEventCallback(battery(), userData, true, callbackfunc, 29, "chargingchange", targetThread);
    };
  _emscripten_set_batterychargingchange_callback_on_thread.sig = 'ippp';

  
  var _emscripten_set_batterylevelchange_callback_on_thread = (userData, callbackfunc, targetThread) => {
      if (!battery()) return -1;
      return registerBatteryEventCallback(battery(), userData, true, callbackfunc, 30, "levelchange", targetThread);
    };
  _emscripten_set_batterylevelchange_callback_on_thread.sig = 'ippp';

  
  var _emscripten_get_battery_status = (batteryState) => {
      if (!battery()) return -1;
      fillBatteryEventData(batteryState, battery());
      return 0;
    };
  _emscripten_get_battery_status.sig = 'ip';






  
  var _emscripten_set_element_css_size = (target, width, height) => {
      target = findEventTarget(target);
      if (!target) return -4;
  
      target.style.width = width + "px";
      target.style.height = height + "px";
  
      return 0;
    };
  _emscripten_set_element_css_size.sig = 'ipdd';

  
  
  var _emscripten_get_element_css_size = (target, width, height) => {
      target = findEventTarget(target);
      if (!target) return -4;
  
      var rect = getBoundingClientRect(target);
      HEAPF64[((width)>>3)] = rect.width;
      HEAPF64[((height)>>3)] = rect.height;
  
      return 0;
    };
  _emscripten_get_element_css_size.sig = 'ippp';

  var _emscripten_html5_remove_all_event_listeners = () => JSEvents.removeAllEventListeners();
  _emscripten_html5_remove_all_event_listeners.sig = 'v';

  var _emscripten_request_animation_frame = (cb, userData) =>
      requestAnimationFrame((timeStamp) => getWasmTableEntry(cb)(timeStamp, userData));
  _emscripten_request_animation_frame.sig = 'ipp';

  var _emscripten_cancel_animation_frame = (id) => cancelAnimationFrame(id);
  _emscripten_cancel_animation_frame.sig = 'vi';

  var _emscripten_request_animation_frame_loop = (cb, userData) => {
      function tick(timeStamp) {
        if (getWasmTableEntry(cb)(timeStamp, userData)) {
          requestAnimationFrame(tick);
        }
      }
      return requestAnimationFrame(tick);
    };
  _emscripten_request_animation_frame_loop.sig = 'vpp';





  /** @returns {number} */
  var convertFrameToPC = (frame) => {
      abort('Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER');
      // return 0 if we can't find any
      return 0;
    };

  
  var _emscripten_return_address = (level) => {
      var callstack = jsStackTrace().split('\n');
      if (callstack[0] == 'Error') {
        callstack.shift();
      }
      // skip this function and the caller to get caller's return address
      var caller = callstack[level + 3];
      return convertFrameToPC(caller);
    };
  _emscripten_return_address.sig = 'pi';

  var UNWIND_CACHE = {
  };

  
  
  
  var saveInUnwindCache = (callstack) => {
      callstack.forEach((frame) => {
        var pc = convertFrameToPC(frame);
        if (pc) {
          UNWIND_CACHE[pc] = frame;
        }
      });
    };
  
  var _emscripten_stack_snapshot = () => {
      var callstack = jsStackTrace().split('\n');
      if (callstack[0] == 'Error') {
        callstack.shift();
      }
      saveInUnwindCache(callstack);
  
      // Caches the stack snapshot so that emscripten_stack_unwind_buffer() can
      // unwind from this spot.
      UNWIND_CACHE.last_addr = convertFrameToPC(callstack[3]);
      UNWIND_CACHE.last_stack = callstack;
      return UNWIND_CACHE.last_addr;
    };
  _emscripten_stack_snapshot.sig = 'p';


  
  
  
  var _emscripten_stack_unwind_buffer = (addr, buffer, count) => {
      var stack;
      if (UNWIND_CACHE.last_addr == addr) {
        stack = UNWIND_CACHE.last_stack;
      } else {
        stack = jsStackTrace().split('\n');
        if (stack[0] == 'Error') {
          stack.shift();
        }
        saveInUnwindCache(stack);
      }
  
      var offset = 3;
      while (stack[offset] && convertFrameToPC(stack[offset]) != addr) {
        ++offset;
      }
  
      for (var i = 0; i < count && stack[i+offset]; ++i) {
        HEAP32[(((buffer)+(i*4))>>2)] = convertFrameToPC(stack[i + offset]);
      }
      return i;
    };
  _emscripten_stack_unwind_buffer.sig = 'ippi';

  var _emscripten_pc_get_function = (pc) => {
      abort('Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER');
      return 0;
    };
  _emscripten_pc_get_function.sig = 'pp';

  
  var convertPCtoSourceLocation = (pc) => {
      if (UNWIND_CACHE.last_get_source_pc == pc) return UNWIND_CACHE.last_source;
  
      var match;
      var source;
  
      if (!source) {
        var frame = UNWIND_CACHE[pc];
        if (!frame) return null;
        // Example: at callMain (a.out.js:6335:22)
        if (match = /\((.*):(\d+):(\d+)\)$/.exec(frame)) {
          source = {file: match[1], line: match[2], column: match[3]};
        // Example: main@a.out.js:1337:42
        } else if (match = /@(.*):(\d+):(\d+)/.exec(frame)) {
          source = {file: match[1], line: match[2], column: match[3]};
        }
      }
      UNWIND_CACHE.last_get_source_pc = pc;
      UNWIND_CACHE.last_source = source;
      return source;
    };

  
  
  var _emscripten_pc_get_file = (pc) => {
      var result = convertPCtoSourceLocation(pc);
      if (!result) return 0;
  
      if (_emscripten_pc_get_file.ret) _free(_emscripten_pc_get_file.ret);
      _emscripten_pc_get_file.ret = stringToNewUTF8(result.file);
      return _emscripten_pc_get_file.ret;
    };
  _emscripten_pc_get_file.sig = 'pp';

  var _emscripten_pc_get_line = (pc) => {
      var result = convertPCtoSourceLocation(pc);
      return result ? result.line : 0;
    };
  _emscripten_pc_get_line.sig = 'ip';

  var _emscripten_pc_get_column = (pc) => {
      var result = convertPCtoSourceLocation(pc);
      return result ? result.column || 0 : 0;
    };
  _emscripten_pc_get_column.sig = 'ip';



  var _sched_yield = () => 0;
  Module['_sched_yield'] = _sched_yield;
  _sched_yield.sig = 'i';















  var wasiRightsToMuslOFlags = (rights) => {
      if ((rights & 2) && (rights & 64)) {
        return 2;
      }
      if (rights & 2) {
        return 0;
      }
      if (rights & 64) {
        return 1;
      }
      throw new FS.ErrnoError(28);
    };

  var wasiOFlagsToMuslOFlags = (oflags) => {
      var musl_oflags = 0;
      if (oflags & 1) {
        musl_oflags |= 64;
      }
      if (oflags & 8) {
        musl_oflags |= 512;
      }
      if (oflags & 2) {
        musl_oflags |= 65536;
      }
      if (oflags & 4) {
        musl_oflags |= 128;
      }
      return musl_oflags;
    };






  var _emscripten_unwind_to_js_event_loop = () => {
      throw 'unwind';
    };
  _emscripten_unwind_to_js_event_loop.sig = 'v';


  var setImmediateWrapped = (func) => {
      setImmediateWrapped.mapping ||= [];
      var id = setImmediateWrapped.mapping.length;
      setImmediateWrapped.mapping[id] = setImmediate(() => {
        setImmediateWrapped.mapping[id] = undefined;
        func();
      });
      return id;
    };


  var clearImmediateWrapped = (id) => {
      clearImmediate(setImmediateWrapped.mapping[id]);
      setImmediateWrapped.mapping[id] = undefined;
    };

  
  var polyfillSetImmediate = () => {
      // nop, used for its postset to ensure setImmediate() polyfill is
      // not duplicated between emscripten_set_immediate() and
      // emscripten_set_immediate_loop() if application links to both of them.
    };

  
  
  var _emscripten_set_immediate = (cb, userData) => {
      
      return emSetImmediate(() => {
        
        callUserCallback(() => getWasmTableEntry(cb)(userData));
      });
    };
  _emscripten_set_immediate.sig = 'ipp';

  var _emscripten_clear_immediate = (id) => {
      
      emClearImmediate(id);
    };
  _emscripten_clear_immediate.sig = 'vi';

  
  
  var _emscripten_set_immediate_loop = (cb, userData) => {
      function tick() {
        callUserCallback(() => {
          if (getWasmTableEntry(cb)(userData)) {
            emSetImmediate(tick);
          } else {
            
          }
        });
      }
      
      emSetImmediate(tick);
    };
  _emscripten_set_immediate_loop.sig = 'vpp';

  
  var _emscripten_set_timeout = (cb, msecs, userData) =>
      safeSetTimeout(() => getWasmTableEntry(cb)(userData), msecs);
  _emscripten_set_timeout.sig = 'ipdp';

  var _emscripten_clear_timeout = clearTimeout;
  _emscripten_clear_timeout.sig = 'vi';

  
  
  var _emscripten_set_timeout_loop = (cb, msecs, userData) => {
      function tick() {
        var t = _emscripten_get_now();
        var n = t + msecs;
        
        callUserCallback(() => {
          if (getWasmTableEntry(cb)(t, userData)) {
            // Save a little bit of code space: modern browsers should treat
            // negative setTimeout as timeout of 0
            // (https://stackoverflow.com/questions/8430966/is-calling-settimeout-with-a-negative-delay-ok)
            
            setTimeout(tick, n - _emscripten_get_now());
          }
        });
      }
      
      return setTimeout(tick, 0);
    };
  _emscripten_set_timeout_loop.sig = 'vpdp';

  
  var _emscripten_set_interval = (cb, msecs, userData) => {
      
      return setInterval(() => {
        callUserCallback(() => getWasmTableEntry(cb)(userData));
      }, msecs);
    };
  _emscripten_set_interval.sig = 'ipdp';

  var _emscripten_clear_interval = (id) => {
      
      clearInterval(id);
    };
  _emscripten_clear_interval.sig = 'vi';


  var registerPostMainLoop = (f) => {
      // Does nothing unless $MainLoop is included/used.
      typeof MainLoop != 'undefined' && MainLoop.postMainLoop.push(f);
    };



  var _emscripten_get_main_loop_timing = (mode, value) => {
      if (mode) HEAP32[((mode)>>2)] = MainLoop.timingMode;
      if (value) HEAP32[((value)>>2)] = MainLoop.timingValue;
    };
  _emscripten_get_main_loop_timing.sig = 'vpp';




  
  var _emscripten_set_main_loop_arg = (func, arg, fps, simulateInfiniteLoop) => {
      var iterFunc = () => getWasmTableEntry(func)(arg);
      setMainLoop(iterFunc, fps, simulateInfiniteLoop, arg);
    };
  _emscripten_set_main_loop_arg.sig = 'vppii';




  
  
  var __emscripten_push_main_loop_blocker = (func, arg, name) => {
      MainLoop.queue.push({ func: () => {
        getWasmTableEntry(func)(arg);
      }, name: UTF8ToString(name), counted: true });
      MainLoop.updateStatus();
    };
  __emscripten_push_main_loop_blocker.sig = 'vppp';

  
  
  var __emscripten_push_uncounted_main_loop_blocker = (func, arg, name) => {
      MainLoop.queue.push({ func: () => {
        getWasmTableEntry(func)(arg);
      }, name: UTF8ToString(name), counted: false });
      MainLoop.updateStatus();
    };
  __emscripten_push_uncounted_main_loop_blocker.sig = 'vppp';





  
  var idsToPromises = (idBuf, size) => {
      var promises = [];
      for (var i = 0; i < size; i++) {
        var id = HEAP32[(((idBuf)+(i*4))>>2)];
        promises[i] = getPromise(id);
      }
      return promises;
    };




  
  
  
  
  
  
  var makePromiseCallback = (callback, userData) => {
      return (value) => {
        ;
        var stack = stackSave();
        // Allocate space for the result value and initialize it to NULL.
        var resultPtr = stackAlloc(POINTER_SIZE);
        HEAPU32[((resultPtr)>>2)] = 0;
        try {
          var result =
              getWasmTableEntry(callback)(resultPtr, userData, value);
          var resultVal = HEAPU32[((resultPtr)>>2)];
        } catch (e) {
          // If the thrown value is potentially a valid pointer, use it as the
          // rejection reason. Otherwise use a null pointer as the reason. If we
          // allow arbitrary objects to be thrown here, we will get a TypeError in
          // MEMORY64 mode when they are later converted to void* rejection
          // values.
          if (typeof e != 'number') {
            throw 0;
          }
          throw e;
        } finally {
          // Thrown errors will reject the promise, but at least we will restore
          // the stack first.
          stackRestore(stack);
        }
        switch (result) {
          case 0:
            return resultVal;
          case 1:
            return getPromise(resultVal);
          case 2:
            var ret = getPromise(resultVal);
            _emscripten_promise_destroy(resultVal);
            return ret;
          case 3:
            throw resultVal;
        }
      };
    };

  
  
  var _emscripten_promise_then = (id, onFulfilled, onRejected, userData) => {
      ;
      var promise = getPromise(id);
      var newId = promiseMap.allocate({
        promise: promise.then(makePromiseCallback(onFulfilled, userData),
                              makePromiseCallback(onRejected, userData))
      });
      return newId;
    };
  _emscripten_promise_then.sig = 'ppppp';

  
  var _emscripten_promise_all = (idBuf, resultBuf, size) => {
      var promises = idsToPromises(idBuf, size);
      var id = promiseMap.allocate({
        promise: Promise.all(promises).then((results) => {
          if (resultBuf) {
            for (var i = 0; i < size; i++) {
              var result = results[i];
              HEAPU32[(((resultBuf)+(i*4))>>2)] = result;
            }
          }
          return resultBuf;
        })
      });
      return id;
    };
  _emscripten_promise_all.sig = 'pppp';

  var setPromiseResult = (ptr, fulfill, value) => {
      var result = fulfill ? 0 : 3
      HEAP32[((ptr)>>2)] = result;
      HEAPU32[(((ptr)+(4))>>2)] = value;
    };

  
  
  var _emscripten_promise_all_settled = (idBuf, resultBuf, size) => {
      var promises = idsToPromises(idBuf, size);
      var id = promiseMap.allocate({
        promise: Promise.allSettled(promises).then((results) => {
          if (resultBuf) {
            var offset = resultBuf;
            for (var i = 0; i < size; i++, offset += 8) {
              if (results[i].status === 'fulfilled') {
                setPromiseResult(offset, true, results[i].value);
              } else {
                setPromiseResult(offset, false, results[i].reason);
              }
            }
          }
          return resultBuf;
        })
      });
      return id;
    };
  _emscripten_promise_all_settled.sig = 'pppp';

  
  var _emscripten_promise_any = (idBuf, errorBuf, size) => {
      var promises = idsToPromises(idBuf, size);
      var id = promiseMap.allocate({
        promise: Promise.any(promises).catch((err) => {
          if (errorBuf) {
            for (var i = 0; i < size; i++) {
              HEAPU32[(((errorBuf)+(i*4))>>2)] = err.errors[i];
            }
          }
          throw errorBuf;
        })
      });
      return id;
    };
  _emscripten_promise_any.sig = 'pppp';

  
  var _emscripten_promise_race = (idBuf, size) => {
      var promises = idsToPromises(idBuf, size);
      var id = promiseMap.allocate({
        promise: Promise.race(promises)
      });
      return id;
    };
  _emscripten_promise_race.sig = 'ppp';

  
  var _emscripten_promise_await = (returnValuePtr, id) => {
      abort('emscripten_promise_await is only available with ASYNCIFY');
    };
  _emscripten_promise_await.sig = 'vpp';

  
  
  var ___resumeException = (ptr) => {
      if (!exceptionLast) {
        exceptionLast = ptr;
      }
      throw exceptionLast;
    };
  ___resumeException.sig = 'vp';
  
  
  var findMatchingCatch = (args) => {
      var thrown =
        exceptionLast;
      if (!thrown) {
        // just pass through the null ptr
        setTempRet0(0);
        return 0;
      }
      var info = new ExceptionInfo(thrown);
      info.set_adjusted_ptr(thrown);
      var thrownType = info.get_type();
      if (!thrownType) {
        // just pass through the thrown ptr
        setTempRet0(0);
        return thrown;
      }
  
      // can_catch receives a **, add indirection
      // The different catch blocks are denoted by different types.
      // Due to inheritance, those types may not precisely match the
      // type of the thrown object. Find one which matches, and
      // return the type of the catch block which should be called.
      for (var caughtType of args) {
        if (caughtType === 0 || caughtType === thrownType) {
          // Catch all clause matched or exactly the same type is caught
          break;
        }
        var adjusted_ptr_addr = info.ptr + 16;
        if (___cxa_can_catch(caughtType, thrownType, adjusted_ptr_addr)) {
          setTempRet0(caughtType);
          return thrown;
        }
      }
      setTempRet0(thrownType);
      return thrown;
    };
  var ___cxa_find_matching_catch_2 = () => findMatchingCatch([]);
  ___cxa_find_matching_catch_2.sig = 'p';

  var ___cxa_find_matching_catch_3 = (arg0) => findMatchingCatch([arg0]);
  ___cxa_find_matching_catch_3.sig = 'pp';

  var ___cxa_find_matching_catch_4 = (arg0,arg1) => findMatchingCatch([arg0,arg1]);
  ___cxa_find_matching_catch_4.sig = 'ppp';



  var exceptionCaught =  [];



  
  
  var ___cxa_rethrow = () => {
      var info = exceptionCaught.pop();
      if (!info) {
        abort('no exception to throw');
      }
      var ptr = info.excPtr;
      if (!info.get_rethrown()) {
        // Only pop if the corresponding push was through rethrow_primary_exception
        exceptionCaught.push(info);
        info.set_rethrown(true);
        info.set_caught(false);
        uncaughtExceptionCount++;
      }
      exceptionLast = ptr;
      throw exceptionLast;
    };
  ___cxa_rethrow.sig = 'v';

  var _llvm_eh_typeid_for = (type) => type;
  _llvm_eh_typeid_for.sig = 'vp';

  
  
  
  var ___cxa_begin_catch = (ptr) => {
      var info = new ExceptionInfo(ptr);
      if (!info.get_caught()) {
        info.set_caught(true);
        uncaughtExceptionCount--;
      }
      info.set_rethrown(false);
      exceptionCaught.push(info);
      ___cxa_increment_exception_refcount(ptr);
      return ___cxa_get_exception_ptr(ptr);
    };
  ___cxa_begin_catch.sig = 'pp';

  
  
  
  var ___cxa_end_catch = () => {
      // Clear state flag.
      _setThrew(0, 0);
      // Call destructor if one is registered then clear it.
      var info = exceptionCaught.pop();
  
      ___cxa_decrement_exception_refcount(info.excPtr);
      exceptionLast = 0; // XXX in decRef?
    };
  ___cxa_end_catch.sig = 'v';

  var ___cxa_uncaught_exceptions = () => uncaughtExceptionCount;
  Module['___cxa_uncaught_exceptions'] = ___cxa_uncaught_exceptions;
  ___cxa_uncaught_exceptions.sig = 'i';

  var ___cxa_call_unexpected = (exception) => abort('Unexpected exception thrown, this is not properly supported - aborting');
  ___cxa_call_unexpected.sig = 'vp';

  
  var ___cxa_current_primary_exception = () => {
      if (!exceptionCaught.length) {
        return 0;
      }
      var info = exceptionCaught[exceptionCaught.length - 1];
      ___cxa_increment_exception_refcount(info.excPtr);
      return info.excPtr;
    };
  Module['___cxa_current_primary_exception'] = ___cxa_current_primary_exception;
  ___cxa_current_primary_exception.sig = 'p';

  
  
  var ___cxa_rethrow_primary_exception = (ptr) => {
      if (!ptr) return;
      var info = new ExceptionInfo(ptr);
      exceptionCaught.push(info);
      info.set_rethrown(true);
      ___cxa_rethrow();
    };
  Module['___cxa_rethrow_primary_exception'] = ___cxa_rethrow_primary_exception;
  ___cxa_rethrow_primary_exception.sig = 'vp';





  var Browser_asyncPrepareDataCounter = 0;

  
  
  
  
  var _emscripten_run_preload_plugins_data = (data, size, suffix, arg, onload, onerror) => {
      
  
      var _suffix = UTF8ToString(suffix);
      var name = 'prepare_data_' + (Browser_asyncPrepareDataCounter++) + '.' + _suffix;
      var cname = stringToNewUTF8(name);
      FS.createPreloadedFile(
        '/',
        name,
        HEAPU8.subarray((data), data + size),
        true, true,
        () => {
          
          if (onload) getWasmTableEntry(onload)(arg, cname);
        },
        () => {
          
          if (onerror) getWasmTableEntry(onerror)(arg);
        },
        true // don'tCreateFile - it's already there
      );
    };
  _emscripten_run_preload_plugins_data.sig = 'vpipppp';


  
  
  
  var _emscripten_async_load_script = (url, onload, onerror) => {
      url = UTF8ToString(url);
      
  
      var loadDone = () => {
        
        if (onload) {
          var onloadCallback = () => callUserCallback(getWasmTableEntry(onload));
          if (runDependencies > 0) {
            dependenciesFulfilled = onloadCallback;
          } else {
            onloadCallback();
          }
        }
      }
  
      var loadError = () => {
        
        if (onerror) {
          callUserCallback(getWasmTableEntry(onerror));
        }
      };
  
      var script = document.createElement('script');
      script.onload = loadDone;
      script.onerror = loadError;
      script.src = url;
      document.body.appendChild(script);
    };
  _emscripten_async_load_script.sig = 'vppp';





  var _emscripten_set_canvas_size = (width, height) => Browser.setCanvasSize(width, height);
  _emscripten_set_canvas_size.sig = 'vii';

  var _emscripten_get_canvas_size = (width, height, isFullscreen) => {
      var canvas = Module['canvas'];
      HEAP32[((width)>>2)] = canvas.width;
      HEAP32[((height)>>2)] = canvas.height;
      HEAP32[((isFullscreen)>>2)] = Browser.isFullscreen ? 1 : 0;
    };
  _emscripten_get_canvas_size.sig = 'vppp';



  
  
  var _emscripten_call_worker = (id, funcName, data, size, callback, arg) => {
      funcName = UTF8ToString(funcName);
      var info = Browser.workers[id];
      var callbackId = -1;
      if (callback) {
        // If we are waiting for a response from the worker we need to keep
        // the runtime alive at least long enough to receive it.
        // The corresponding runtimeKeepalivePop is in the `finalResponse`
        // handler above.
        
        callbackId = info.callbacks.length;
        info.callbacks.push({
          func: getWasmTableEntry(callback),
          arg
        });
        info.awaited++;
      }
      var transferObject = {
        'funcName': funcName,
        'callbackId': callbackId,
        'data': data ? new Uint8Array(HEAPU8.subarray((data), data + size)) : 0
      };
      if (data) {
        info.worker.postMessage(transferObject, [transferObject.data.buffer]);
      } else {
        info.worker.postMessage(transferObject);
      }
    };
  _emscripten_call_worker.sig = 'vippipp';


  var getPreloadedImageData = (path, w, h) => {
      path = PATH_FS.resolve(path);
  
      var canvas = /** @type {HTMLCanvasElement} */(Browser.preloadedImages[path]);
      if (!canvas) return 0;
  
      var ctx = canvas.getContext("2d");
      var image = ctx.getImageData(0, 0, canvas.width, canvas.height);
      var buf = _malloc(canvas.width * canvas.height * 4);
  
      HEAPU8.set(image.data, buf);
  
      HEAP32[((w)>>2)] = canvas.width;
      HEAP32[((h)>>2)] = canvas.height;
      return buf;
    };
  
  
  
  var _emscripten_get_preloaded_image_data = (path, w, h) => getPreloadedImageData(UTF8ToString(path), w, h);
  _emscripten_get_preloaded_image_data.sig = 'pppp';

  var getPreloadedImageData__data = ["$PATH_FS","malloc"];


  
  
  var _emscripten_get_preloaded_image_data_from_FILE = (file, w, h) => {
      var fd = _fileno(file);
      var stream = FS.getStream(fd);
      if (stream) {
        return getPreloadedImageData(stream.path, w, h);
      }
  
      return 0;
    };
  _emscripten_get_preloaded_image_data_from_FILE.sig = 'pppp';


  
  
  
  
  
  
  
    /**
     * @param {number=} mode Optionally, the mode to create in. Uses mkdir's
     *                       default if not set.
     */
  var FS_mkdirTree = (path, mode) => FS.mkdirTree(path, mode);
  
  
  
  
  var _emscripten_async_wget = (url, file, onload, onerror) => {
      
  
      var _url = UTF8ToString(url);
      var _file = UTF8ToString(file);
      _file = PATH_FS.resolve(_file);
      function doCallback(callback) {
        if (callback) {
          
          callUserCallback(() => {
            var sp = stackSave();
            getWasmTableEntry(callback)(stringToUTF8OnStack(_file));
            stackRestore(sp);
          });
        }
      }
      var destinationDirectory = PATH.dirname(_file);
      FS_createPreloadedFile(
        destinationDirectory,
        PATH.basename(_file),
        _url, true, true,
        () => doCallback(onload),
        () => doCallback(onerror),
        false, // dontCreateFile
        false, // canOwn
        () => { // preFinish
          // if a file exists there, we overwrite it
          try {
            FS_unlink(_file);
          } catch (e) {}
          // if the destination directory does not yet exist, create it
          FS_mkdirTree(destinationDirectory);
        }
      );
    };
  _emscripten_async_wget.sig = 'vpppp';

  
  
  
  
  
  var _emscripten_async_wget_data = (url, userdata, onload, onerror) => {
      
      /* no need for run dependency, this is async but will not do any prepare etc. step */
      asyncLoad(UTF8ToString(url)).then((byteArray) => {
        
        callUserCallback(() => {
          var buffer = _malloc(byteArray.length);
          HEAPU8.set(byteArray, buffer);
          getWasmTableEntry(onload)(userdata, buffer, byteArray.length);
          _free(buffer);
        });
      }, () => {
        if (onerror) {
          
          callUserCallback(() => {
            getWasmTableEntry(onerror)(userdata);
          });
        }
      });
    };
  _emscripten_async_wget_data.sig = 'vpppp';








  var ___asctime_r = (tmPtr, buf) => {
      var date = {
        tm_sec: HEAP32[((tmPtr)>>2)],
        tm_min: HEAP32[(((tmPtr)+(4))>>2)],
        tm_hour: HEAP32[(((tmPtr)+(8))>>2)],
        tm_mday: HEAP32[(((tmPtr)+(12))>>2)],
        tm_mon: HEAP32[(((tmPtr)+(16))>>2)],
        tm_year: HEAP32[(((tmPtr)+(20))>>2)],
        tm_wday: HEAP32[(((tmPtr)+(24))>>2)]
      };
      var days = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ];
      var months = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
      var s = days[date.tm_wday] + ' ' + months[date.tm_mon] +
          (date.tm_mday < 10 ? '  ' : ' ') + date.tm_mday +
          (date.tm_hour < 10 ? ' 0' : ' ') + date.tm_hour +
          (date.tm_min < 10 ? ':0' : ':') + date.tm_min +
          (date.tm_sec < 10 ? ':0' : ':') + date.tm_sec +
          ' ' + (1900 + date.tm_year) + "\n";
  
      // asctime_r is specced to behave in an undefined manner if the algorithm would attempt
      // to write out more than 26 bytes (including the null terminator).
      // See http://pubs.opengroup.org/onlinepubs/9699919799/functions/asctime.html
      // Our undefined behavior is to truncate the write to at most 26 bytes, including null terminator.
      stringToUTF8(s, buf, 26);
      return buf;
    };
  ___asctime_r.sig = 'ppp';


  var MONTH_DAYS_REGULAR = [31,28,31,30,31,30,31,31,30,31,30,31];

  var MONTH_DAYS_LEAP = [31,29,31,30,31,30,31,31,30,31,30,31];





  var arraySum = (array, index) => {
      var sum = 0;
      for (var i = 0; i <= index; sum += array[i++]) {
        // no-op
      }
      return sum;
    };

  
  
  var addDays = (date, days) => {
      var newDate = new Date(date.getTime());
      while (days > 0) {
        var leap = isLeapYear(newDate.getFullYear());
        var currentMonth = newDate.getMonth();
        var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
  
        if (days > daysInCurrentMonth-newDate.getDate()) {
          // we spill over to next month
          days -= (daysInCurrentMonth-newDate.getDate()+1);
          newDate.setDate(1);
          if (currentMonth < 11) {
            newDate.setMonth(currentMonth+1)
          } else {
            newDate.setMonth(0);
            newDate.setFullYear(newDate.getFullYear()+1);
          }
        } else {
          // we stay in current month
          newDate.setDate(newDate.getDate()+days);
          return newDate;
        }
      }
  
      return newDate;
    };

  
  
  
  
  
  
  
  var _strptime = (buf, format, tm) => {
      // char *strptime(const char *restrict buf, const char *restrict format, struct tm *restrict tm);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html
      var pattern = UTF8ToString(format);
  
      // escape special characters
      // TODO: not sure we really need to escape all of these in JS regexps
      var SPECIAL_CHARS = '\\!@#$^&*()+=-[]/{}|:<>?,.';
      for (var i=0, ii=SPECIAL_CHARS.length; i<ii; ++i) {
        pattern = pattern.replace(new RegExp('\\'+SPECIAL_CHARS[i], 'g'), '\\'+SPECIAL_CHARS[i]);
      }
  
      // reduce number of matchers
      var EQUIVALENT_MATCHERS = {
        'A':  '%a',
        'B':  '%b',
        'c':  '%a %b %d %H:%M:%S %Y',
        'D':  '%m\\/%d\\/%y',
        'e':  '%d',
        'F':  '%Y-%m-%d',
        'h':  '%b',
        'R':  '%H\\:%M',
        'r':  '%I\\:%M\\:%S\\s%p',
        'T':  '%H\\:%M\\:%S',
        'x':  '%m\\/%d\\/(?:%y|%Y)',
        'X':  '%H\\:%M\\:%S'
      };
      // TODO: take care of locale
  
      var DATE_PATTERNS = {
        /* weekday name */    'a': '(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)',
        /* month name */      'b': '(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)',
        /* century */         'C': '\\d\\d',
        /* day of month */    'd': '0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31',
        /* hour (24hr) */     'H': '\\d(?!\\d)|[0,1]\\d|20|21|22|23',
        /* hour (12hr) */     'I': '\\d(?!\\d)|0\\d|10|11|12',
        /* day of year */     'j': '00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d',
        /* month */           'm': '0[1-9]|[1-9](?!\\d)|10|11|12',
        /* minutes */         'M': '0\\d|\\d(?!\\d)|[1-5]\\d',
        /* whitespace */      'n': ' ',
        /* AM/PM */           'p': 'AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.',
        /* seconds */         'S': '0\\d|\\d(?!\\d)|[1-5]\\d|60',
        /* week number */     'U': '0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53',
        /* week number */     'W': '0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53',
        /* weekday number */  'w': '[0-6]',
        /* 2-digit year */    'y': '\\d\\d',
        /* 4-digit year */    'Y': '\\d\\d\\d\\d',
        /* whitespace */      't': ' ',
        /* time zone */       'z': 'Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)'
      };
  
      var MONTH_NUMBERS = {JAN: 0, FEB: 1, MAR: 2, APR: 3, MAY: 4, JUN: 5, JUL: 6, AUG: 7, SEP: 8, OCT: 9, NOV: 10, DEC: 11};
      var DAY_NUMBERS_SUN_FIRST = {SUN: 0, MON: 1, TUE: 2, WED: 3, THU: 4, FRI: 5, SAT: 6};
      var DAY_NUMBERS_MON_FIRST = {MON: 0, TUE: 1, WED: 2, THU: 3, FRI: 4, SAT: 5, SUN: 6};
  
      var capture = [];
      var pattern_out = pattern
        .replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m)
        .replace(/%(.)/g, (_, c) => {
          let pat = DATE_PATTERNS[c];
          if (pat){
            capture.push(c);
            return `(${pat})`;
          } else {
            return c;
          }
        })
        .replace( // any number of space or tab characters match zero or more spaces
          /\s+/g,'\\s*'
        );
  
      var matches = new RegExp('^'+pattern_out, "i").exec(UTF8ToString(buf))
  
      function initDate() {
        function fixup(value, min, max) {
          return (typeof value != 'number' || isNaN(value)) ? min : (value>=min ? (value<=max ? value: max): min);
        };
        return {
          year: fixup(HEAP32[(((tm)+(20))>>2)] + 1900 , 1970, 9999),
          month: fixup(HEAP32[(((tm)+(16))>>2)], 0, 11),
          day: fixup(HEAP32[(((tm)+(12))>>2)], 1, 31),
          hour: fixup(HEAP32[(((tm)+(8))>>2)], 0, 23),
          min: fixup(HEAP32[(((tm)+(4))>>2)], 0, 59),
          sec: fixup(HEAP32[((tm)>>2)], 0, 59),
          gmtoff: 0
        };
      };
  
      if (matches) {
        var date = initDate();
        var value;
  
        var getMatch = (symbol) => {
          var pos = capture.indexOf(symbol);
          // check if symbol appears in regexp
          if (pos >= 0) {
            // return matched value or null (falsy!) for non-matches
            return matches[pos+1];
          }
          return;
        };
  
        // seconds
        if ((value=getMatch('S'))) {
          date.sec = jstoi_q(value);
        }
  
        // minutes
        if ((value=getMatch('M'))) {
          date.min = jstoi_q(value);
        }
  
        // hours
        if ((value=getMatch('H'))) {
          // 24h clock
          date.hour = jstoi_q(value);
        } else if ((value = getMatch('I'))) {
          // AM/PM clock
          var hour = jstoi_q(value);
          if ((value=getMatch('p'))) {
            hour += value.toUpperCase()[0] === 'P' ? 12 : 0;
          }
          date.hour = hour;
        }
  
        // year
        if ((value=getMatch('Y'))) {
          // parse from four-digit year
          date.year = jstoi_q(value);
        } else if ((value=getMatch('y'))) {
          // parse from two-digit year...
          var year = jstoi_q(value);
          if ((value=getMatch('C'))) {
            // ...and century
            year += jstoi_q(value)*100;
          } else {
            // ...and rule-of-thumb
            year += year<69 ? 2000 : 1900;
          }
          date.year = year;
        }
  
        // month
        if ((value=getMatch('m'))) {
          // parse from month number
          date.month = jstoi_q(value)-1;
        } else if ((value=getMatch('b'))) {
          // parse from month name
          date.month = MONTH_NUMBERS[value.substring(0,3).toUpperCase()] || 0;
          // TODO: derive month from day in year+year, week number+day of week+year
        }
  
        // day
        if ((value=getMatch('d'))) {
          // get day of month directly
          date.day = jstoi_q(value);
        } else if ((value=getMatch('j'))) {
          // get day of month from day of year ...
          var day = jstoi_q(value);
          var leapYear = isLeapYear(date.year);
          for (var month=0; month<12; ++month) {
            var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month-1);
            if (day<=daysUntilMonth+(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
              date.day = day-daysUntilMonth;
            }
          }
        } else if ((value=getMatch('a'))) {
          // get day of month from weekday ...
          var weekDay = value.substring(0,3).toUpperCase();
          if ((value=getMatch('U'))) {
            // ... and week number (Sunday being first day of week)
            // Week number of the year (Sunday as the first day of the week) as a decimal number [00,53].
            // All days in a new year preceding the first Sunday are considered to be in week 0.
            var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
            var weekNumber = jstoi_q(value);
  
            // January 1st
            var janFirst = new Date(date.year, 0, 1);
            var endDate;
            if (janFirst.getDay() === 0) {
              // Jan 1st is a Sunday, and, hence in the 1st CW
              endDate = addDays(janFirst, weekDayNumber+7*(weekNumber-1));
            } else {
              // Jan 1st is not a Sunday, and, hence still in the 0th CW
              endDate = addDays(janFirst, 7-janFirst.getDay()+weekDayNumber+7*(weekNumber-1));
            }
            date.day = endDate.getDate();
            date.month = endDate.getMonth();
          } else if ((value=getMatch('W'))) {
            // ... and week number (Monday being first day of week)
            // Week number of the year (Monday as the first day of the week) as a decimal number [00,53].
            // All days in a new year preceding the first Monday are considered to be in week 0.
            var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
            var weekNumber = jstoi_q(value);
  
            // January 1st
            var janFirst = new Date(date.year, 0, 1);
            var endDate;
            if (janFirst.getDay()===1) {
              // Jan 1st is a Monday, and, hence in the 1st CW
               endDate = addDays(janFirst, weekDayNumber+7*(weekNumber-1));
            } else {
              // Jan 1st is not a Monday, and, hence still in the 0th CW
              endDate = addDays(janFirst, 7-janFirst.getDay()+1+weekDayNumber+7*(weekNumber-1));
            }
  
            date.day = endDate.getDate();
            date.month = endDate.getMonth();
          }
        }
  
        // time zone
        if ((value = getMatch('z'))) {
          // GMT offset as either 'Z' or +-HH:MM or +-HH or +-HHMM
          if (value.toLowerCase() === 'z'){
            date.gmtoff = 0;
          } else {          
            var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
            date.gmtoff = match[1] * 3600;
            if (match[2]) {
              date.gmtoff += date.gmtoff >0 ? match[2] * 60 : -match[2] * 60
            }
          }
        }
  
        /*
        tm_sec  int seconds after the minute  0-61*
        tm_min  int minutes after the hour  0-59
        tm_hour int hours since midnight  0-23
        tm_mday int day of the month  1-31
        tm_mon  int months since January  0-11
        tm_year int years since 1900
        tm_wday int days since Sunday 0-6
        tm_yday int days since January 1  0-365
        tm_isdst  int Daylight Saving Time flag
        tm_gmtoff long offset from GMT (seconds)
        */
  
        var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
        HEAP32[((tm)>>2)] = fullDate.getSeconds();
        HEAP32[(((tm)+(4))>>2)] = fullDate.getMinutes();
        HEAP32[(((tm)+(8))>>2)] = fullDate.getHours();
        HEAP32[(((tm)+(12))>>2)] = fullDate.getDate();
        HEAP32[(((tm)+(16))>>2)] = fullDate.getMonth();
        HEAP32[(((tm)+(20))>>2)] = fullDate.getFullYear()-1900;
        HEAP32[(((tm)+(24))>>2)] = fullDate.getDay();
        HEAP32[(((tm)+(28))>>2)] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth()-1)+fullDate.getDate()-1;
        HEAP32[(((tm)+(32))>>2)] = 0;
        HEAP32[(((tm)+(36))>>2)] = date.gmtoff;
   
        // we need to convert the matched sequence into an integer array to take care of UTF-8 characters > 0x7F
        // TODO: not sure that intArrayFromString handles all unicode characters correctly
        return buf+intArrayFromString(matches[0]).length-1;
      }
  
      return 0;
    };
  _strptime.sig = 'pppp';

  var _strptime_l = (buf, format, tm, locale) => _strptime(buf, format, tm);
  _strptime_l.sig = 'ppppp';



















  function ___syscall_shutdown(fd, how) {
  try {
  
      getSocketFromFD(fd);
      return -52; // unsupported feature
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  Module['___syscall_shutdown'] = ___syscall_shutdown;
  ___syscall_shutdown.sig = 'iiiiiii';
































































  var __dlsym_catchup_js = (handle, symbolIndex) => {
      var lib = LDSO.loadedLibsByHandle[handle];
      var symDict = lib.exports;
      var symName = Object.keys(symDict)[symbolIndex];
      var sym = symDict[symName];
      var result = addFunction(sym, sym.sig);
      return result;
    };
  __dlsym_catchup_js.sig = 'ppi';












  var FS_readFile = FS.readFile;









  
  
  
  var _setNetworkCallback = (event, userData, callback) => {
      function _callback(data) {
        callUserCallback(() => {
          if (event === 'error') {
            withStackSave(() => {
              var msg = stringToUTF8OnStack(data[2]);
              getWasmTableEntry(callback)(data[0], data[1], msg, userData);
            });
          } else {
            getWasmTableEntry(callback)(data, userData);
          }
        });
      };
  
      // FIXME(sbc): This has no corresponding Pop so will currently keep the
      // runtime alive indefinitely.
      
      SOCKFS.on(event, callback ? _callback : null);
    };

  var _emscripten_set_socket_error_callback = (userData, callback) =>
      _setNetworkCallback('error', userData, callback);
  _emscripten_set_socket_error_callback.sig = 'vpp';

  var _emscripten_set_socket_open_callback = (userData, callback) =>
      _setNetworkCallback('open', userData, callback);
  _emscripten_set_socket_open_callback.sig = 'vpp';

  var _emscripten_set_socket_listen_callback = (userData, callback) =>
      _setNetworkCallback('listen', userData, callback);
  _emscripten_set_socket_listen_callback.sig = 'vpp';

  var _emscripten_set_socket_connection_callback = (userData, callback) =>
      _setNetworkCallback('connection', userData, callback);
  _emscripten_set_socket_connection_callback.sig = 'vpp';

  var _emscripten_set_socket_message_callback = (userData, callback) =>
      _setNetworkCallback('message', userData, callback);
  _emscripten_set_socket_message_callback.sig = 'vpp';

  var _emscripten_set_socket_close_callback = (userData, callback) =>
      _setNetworkCallback('close', userData, callback);
  _emscripten_set_socket_close_callback.sig = 'vpp';


  var miniTempWebGLFloatBuffers = [];

  var miniTempWebGLIntBuffers = [];




  
  var _emscripten_webgl_enable_WEBGL_multi_draw = (ctx) => webgl_enable_WEBGL_multi_draw(GL.contexts[ctx].GLctx);
  _emscripten_webgl_enable_WEBGL_multi_draw.sig = 'ip';


  
  var _emscripten_webgl_enable_EXT_polygon_offset_clamp = (ctx) => webgl_enable_EXT_polygon_offset_clamp(GL.contexts[ctx].GLctx);
  _emscripten_webgl_enable_EXT_polygon_offset_clamp.sig = 'ip';


  
  var _emscripten_webgl_enable_EXT_clip_control = (ctx) => webgl_enable_EXT_clip_control(GL.contexts[ctx].GLctx);
  _emscripten_webgl_enable_EXT_clip_control.sig = 'ip';


  
  var _emscripten_webgl_enable_WEBGL_polygon_mode = (ctx) => webgl_enable_WEBGL_polygon_mode(GL.contexts[ctx].GLctx);
  _emscripten_webgl_enable_WEBGL_polygon_mode.sig = 'ip';
























































































































  var _glVertexPointer = (size, type, stride, ptr) => {
      throw 'Legacy GL function (glVertexPointer) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.';
    };
  _glVertexPointer.sig = 'viiip';

  var _glMatrixMode = () => {
      throw 'Legacy GL function (glMatrixMode) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.';
    };
  _glMatrixMode.sig = 'vi';

  var _glBegin = () => {
      throw 'Legacy GL function (glBegin) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.';
    };
  _glBegin.sig = 'vi';

  var _glLoadIdentity = () => {
      throw 'Legacy GL function (glLoadIdentity) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.';
    };
  _glLoadIdentity.sig = 'v';


































  
  /** @suppress {duplicate } */
  var _glMultiDrawArraysWEBGL = (mode, firsts, counts, drawcount) => {
      GLctx.multiDrawWebgl['multiDrawArraysWEBGL'](
        mode,
        HEAP32,
        ((firsts)>>2),
        HEAP32,
        ((counts)>>2),
        drawcount);
    };
  _glMultiDrawArraysWEBGL.sig = 'vippi';
  var _glMultiDrawArrays = _glMultiDrawArraysWEBGL;
  _glMultiDrawArrays.sig = 'vippi';

  
  var _glMultiDrawArraysANGLE = _glMultiDrawArraysWEBGL;


  
  /** @suppress {duplicate } */
  var _glMultiDrawArraysInstancedWEBGL = (mode, firsts, counts, instanceCounts, drawcount) => {
      GLctx.multiDrawWebgl['multiDrawArraysInstancedWEBGL'](
        mode,
        HEAP32,
        ((firsts)>>2),
        HEAP32,
        ((counts)>>2),
        HEAP32,
        ((instanceCounts)>>2),
        drawcount);
    };
  _glMultiDrawArraysInstancedWEBGL.sig = 'vipppi';
  var _glMultiDrawArraysInstancedANGLE = _glMultiDrawArraysInstancedWEBGL;


  
  /** @suppress {duplicate } */
  var _glMultiDrawElementsWEBGL = (mode, counts, type, offsets, drawcount) => {
      GLctx.multiDrawWebgl['multiDrawElementsWEBGL'](
        mode,
        HEAP32,
        ((counts)>>2),
        type,
        HEAP32,
        ((offsets)>>2),
        drawcount);
    };
  _glMultiDrawElementsWEBGL.sig = 'vipipi';
  var _glMultiDrawElements = _glMultiDrawElementsWEBGL;
  _glMultiDrawElements.sig = 'vipipi';

  
  var _glMultiDrawElementsANGLE = _glMultiDrawElementsWEBGL;


  
  /** @suppress {duplicate } */
  var _glMultiDrawElementsInstancedWEBGL = (mode, counts, type, offsets, instanceCounts, drawcount) => {
      GLctx.multiDrawWebgl['multiDrawElementsInstancedWEBGL'](
        mode,
        HEAP32,
        ((counts)>>2),
        type,
        HEAP32,
        ((offsets)>>2),
        HEAP32,
        ((instanceCounts)>>2),
        drawcount);
    };
  _glMultiDrawElementsInstancedWEBGL.sig = 'vipippi';
  var _glMultiDrawElementsInstancedANGLE = _glMultiDrawElementsInstancedWEBGL;













  var _glClearDepth = (x0) => GLctx.clearDepth(x0);
  _glClearDepth.sig = 'vd';


















  var _glDepthRange = (x0, x1) => GLctx.depthRange(x0, x1);
  _glDepthRange.sig = 'vdd';
































































































































  var _emscripten_glVertexPointer = _glVertexPointer;
  _emscripten_glVertexPointer.sig = 'viiip';

  var _emscripten_glMatrixMode = _glMatrixMode;
  _emscripten_glMatrixMode.sig = 'vi';

  var _emscripten_glBegin = _glBegin;
  _emscripten_glBegin.sig = 'vi';

  var _emscripten_glLoadIdentity = _glLoadIdentity;
  _emscripten_glLoadIdentity.sig = 'v';


































  var _emscripten_glMultiDrawArrays = _glMultiDrawArrays;
  _emscripten_glMultiDrawArrays.sig = 'vippi';

  var _emscripten_glMultiDrawArraysANGLE = _glMultiDrawArraysANGLE;

  var _emscripten_glMultiDrawArraysWEBGL = _glMultiDrawArraysWEBGL;

  var _emscripten_glMultiDrawArraysInstancedANGLE = _glMultiDrawArraysInstancedANGLE;

  var _emscripten_glMultiDrawArraysInstancedWEBGL = _glMultiDrawArraysInstancedWEBGL;

  var _emscripten_glMultiDrawElements = _glMultiDrawElements;
  _emscripten_glMultiDrawElements.sig = 'vipipi';

  var _emscripten_glMultiDrawElementsANGLE = _glMultiDrawElementsANGLE;

  var _emscripten_glMultiDrawElementsWEBGL = _glMultiDrawElementsWEBGL;

  var _emscripten_glMultiDrawElementsInstancedANGLE = _glMultiDrawElementsInstancedANGLE;

  var _emscripten_glMultiDrawElementsInstancedWEBGL = _glMultiDrawElementsInstancedWEBGL;










  var _emscripten_glClearDepth = _glClearDepth;
  _emscripten_glClearDepth.sig = 'vd';


















  var _emscripten_glDepthRange = _glDepthRange;
  _emscripten_glDepthRange.sig = 'vdd';























  var writeGLArray = (arr, dst, dstLength, heapType) => {
      var len = arr.length;
      var writeLength = dstLength < len ? dstLength : len;
      var heap = heapType ? HEAPF32 : HEAP32;
      // Works because HEAPF32 and HEAP32 have the same bytes-per-element
      dst = ((dst)>>2);
      for (var i = 0; i < writeLength; ++i) {
        heap[dst + i] = arr[i];
      }
      return len;
    };




  
  /** @suppress {duplicate } */
  var _emscripten_webgl_do_commit_frame = () => {
      if (!GL.currentContext || !GL.currentContext.GLctx) {
        return -3;
      }
  
      if (!GL.currentContext.attributes.explicitSwapControl) {
        return -3;
      }
      // We would do GL.currentContext.GLctx.commit(); here, but the current implementation
      // in browsers has removed it - swap is implicit, so this function is a no-op for now
      // (until/unless the spec changes).
      return 0;
    };
  _emscripten_webgl_do_commit_frame.sig = 'i';
  var _emscripten_webgl_commit_frame = _emscripten_webgl_do_commit_frame;
  _emscripten_webgl_commit_frame.sig = 'i';




  var _emscripten_webgl_get_drawing_buffer_size = (contextHandle, width, height) => {
      var GLContext = GL.getContext(contextHandle);
  
      if (!GLContext || !GLContext.GLctx || !width || !height) {
        return -5;
      }
      HEAP32[((width)>>2)] = GLContext.GLctx.drawingBufferWidth;
      HEAP32[((height)>>2)] = GLContext.GLctx.drawingBufferHeight;
      return 0;
    };
  _emscripten_webgl_get_drawing_buffer_size.sig = 'ippp';


  
  var _emscripten_webgl_get_context_attributes = (c, a) => {
      if (!a) return -5;
      c = GL.contexts[c];
      if (!c) return -3;
      var t = c.GLctx;
      if (!t) return -3;
      t = t.getContextAttributes();
  
      HEAP8[a] = t.alpha;
      HEAP8[(a)+(1)] = t.depth;
      HEAP8[(a)+(2)] = t.stencil;
      HEAP8[(a)+(3)] = t.antialias;
      HEAP8[(a)+(4)] = t.premultipliedAlpha;
      HEAP8[(a)+(5)] = t.preserveDrawingBuffer;
      var power = t['powerPreference'] && webglPowerPreferences.indexOf(t['powerPreference']);
      HEAP32[(((a)+(8))>>2)] = power;
      HEAP8[(a)+(12)] = t.failIfMajorPerformanceCaveat;
      HEAP32[(((a)+(16))>>2)] = c.version;
      HEAP32[(((a)+(20))>>2)] = 0;
      HEAP8[(a)+(24)] = c.attributes.enableExtensionsByDefault;
      return 0;
    };
  _emscripten_webgl_get_context_attributes.sig = 'ipp';

  
  var _emscripten_webgl_destroy_context = (contextHandle) => {
      if (GL.currentContext == contextHandle) GL.currentContext = 0;
      GL.deleteContext(contextHandle);
    };
  _emscripten_webgl_destroy_context.sig = 'ip';

  
  
  
  
  
  
  
  var _emscripten_webgl_enable_extension = (contextHandle, extension) => {
      var context = GL.getContext(contextHandle);
      var extString = UTF8ToString(extension);
      if (extString.startsWith('GL_')) extString = extString.substr(3); // Allow enabling extensions both with "GL_" prefix and without.
  
      // Switch-board that pulls in code for all GL extensions, even if those are not used :/
      // Build with -sGL_SUPPORT_SIMPLE_ENABLE_EXTENSIONS=0 to avoid this.
  
      if (extString == 'WEBGL_draw_instanced_base_vertex_base_instance') webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance(GLctx);
      if (extString == 'WEBGL_multi_draw_instanced_base_vertex_base_instance') webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance(GLctx);
  
      if (extString == 'WEBGL_multi_draw') webgl_enable_WEBGL_multi_draw(GLctx);
      if (extString == 'EXT_polygon_offset_clamp') webgl_enable_EXT_polygon_offset_clamp(GLctx);
      if (extString == 'EXT_clip_control') webgl_enable_EXT_clip_control(GLctx);
      if (extString == 'WEBGL_polygon_mode') webgl_enable_WEBGL_polygon_mode(GLctx);
  
      var ext = context.GLctx.getExtension(extString);
      return !!ext;
    };
  _emscripten_webgl_enable_extension.sig = 'ipp';


  
  
  
  var registerWebGlEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {
  
      var webGlEventHandlerFunc = (e = event) => {
        if (getWasmTableEntry(callbackfunc)(eventTypeId, 0, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: findEventTarget(target),
        eventTypeString,
        callbackfunc,
        handlerFunc: webGlEventHandlerFunc,
        useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    };

  
  var _emscripten_set_webglcontextlost_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) => {
      registerWebGlEventCallback(target, userData, useCapture, callbackfunc, 31, "webglcontextlost", targetThread);
      return 0;
    };
  _emscripten_set_webglcontextlost_callback_on_thread.sig = 'ippipp';

  
  var _emscripten_set_webglcontextrestored_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) => {
      registerWebGlEventCallback(target, userData, useCapture, callbackfunc, 32, "webglcontextrestored", targetThread);
      return 0;
    };
  _emscripten_set_webglcontextrestored_callback_on_thread.sig = 'ippipp';

  var _emscripten_is_webgl_context_lost = (contextHandle) =>
      !GL.contexts[contextHandle] || GL.contexts[contextHandle].GLctx.isContextLost();
  _emscripten_is_webgl_context_lost.sig = 'ip';

  
  var _emscripten_webgl_get_supported_extensions = () =>
      stringToNewUTF8(GLctx.getSupportedExtensions().join(' '));
  _emscripten_webgl_get_supported_extensions.sig = 'p';

  var _emscripten_webgl_get_program_parameter_d = (program, param) =>
      GLctx.getProgramParameter(GL.programs[program], param);
  _emscripten_webgl_get_program_parameter_d.sig = 'dii';

  
  var _emscripten_webgl_get_program_info_log_utf8 = (program) =>
      stringToNewUTF8(GLctx.getProgramInfoLog(GL.programs[program]));
  _emscripten_webgl_get_program_info_log_utf8.sig = 'pi';

  var _emscripten_webgl_get_shader_parameter_d = (shader, param) =>
      GLctx.getShaderParameter(GL.shaders[shader], param);
  _emscripten_webgl_get_shader_parameter_d.sig = 'dii';

  
  var _emscripten_webgl_get_shader_info_log_utf8 = (shader) =>
      stringToNewUTF8(GLctx.getShaderInfoLog(GL.shaders[shader]));
  _emscripten_webgl_get_shader_info_log_utf8.sig = 'pi';

  
  var _emscripten_webgl_get_shader_source_utf8 = (shader) =>
      stringToNewUTF8(GLctx.getShaderSource(GL.shaders[shader]));
  _emscripten_webgl_get_shader_source_utf8.sig = 'pi';

  var _emscripten_webgl_get_vertex_attrib_d = (index, param) =>
      GLctx.getVertexAttrib(index, param);
  _emscripten_webgl_get_vertex_attrib_d.sig = 'dii';

  var _emscripten_webgl_get_vertex_attrib_o = (index, param) => {
      var obj = GLctx.getVertexAttrib(index, param);
      return obj?.name;
    };
  _emscripten_webgl_get_vertex_attrib_o.sig = 'iii';

  
  var _emscripten_webgl_get_vertex_attrib_v = (index, param, dst, dstLength, dstType) =>
      writeGLArray(GLctx.getVertexAttrib(index, param), dst, dstLength, dstType);
  _emscripten_webgl_get_vertex_attrib_v.sig = 'iiipii';

  
  var _emscripten_webgl_get_uniform_d = (program, location) =>
      GLctx.getUniform(GL.programs[program], webglGetUniformLocation(location));
  _emscripten_webgl_get_uniform_d.sig = 'dii';

  
  
  var _emscripten_webgl_get_uniform_v = (program, location, dst, dstLength, dstType) =>
      writeGLArray(GLctx.getUniform(GL.programs[program], webglGetUniformLocation(location)), dst, dstLength, dstType);
  _emscripten_webgl_get_uniform_v.sig = 'iiipii';

  
  var _emscripten_webgl_get_parameter_v = (param, dst, dstLength, dstType) =>
      writeGLArray(GLctx.getParameter(param), dst, dstLength, dstType);
  _emscripten_webgl_get_parameter_v.sig = 'iipii';

  var _emscripten_webgl_get_parameter_d = (param) => GLctx.getParameter(param);
  _emscripten_webgl_get_parameter_d.sig = 'di';

  var _emscripten_webgl_get_parameter_o = (param) => {
      var obj = GLctx.getParameter(param);
      return obj?.name;
    };
  _emscripten_webgl_get_parameter_o.sig = 'ii';

  
  var _emscripten_webgl_get_parameter_utf8 = (param) => stringToNewUTF8(GLctx.getParameter(param));
  _emscripten_webgl_get_parameter_utf8.sig = 'pi';

  
  var _emscripten_webgl_get_parameter_i64v = (param, dst) => writeI53ToI64(dst, GLctx.getParameter(param));
  _emscripten_webgl_get_parameter_i64v.sig = 'vip';

































































































  
  
  
  var _glutPostRedisplay = () => {
      if (GLUT.displayFunc && !GLUT.requestedAnimationFrame) {
        GLUT.requestedAnimationFrame = true;
        MainLoop.requestAnimationFrame(() => {
          GLUT.requestedAnimationFrame = false;
          MainLoop.runIter(() => getWasmTableEntry(GLUT.displayFunc)());
        });
      }
    };
  _glutPostRedisplay.sig = 'v';
  
  
  var GLUT = {
  initTime:null,
  idleFunc:null,
  displayFunc:null,
  keyboardFunc:null,
  keyboardUpFunc:null,
  specialFunc:null,
  specialUpFunc:null,
  reshapeFunc:null,
  motionFunc:null,
  passiveMotionFunc:null,
  mouseFunc:null,
  buttons:0,
  modifiers:0,
  initWindowWidth:256,
  initWindowHeight:256,
  initDisplayMode:18,
  windowX:0,
  windowY:0,
  windowWidth:0,
  windowHeight:0,
  requestedAnimationFrame:false,
  saveModifiers:(event) => {
        GLUT.modifiers = 0;
        if (event['shiftKey'])
          GLUT.modifiers += 1; /* GLUT_ACTIVE_SHIFT */
        if (event['ctrlKey'])
          GLUT.modifiers += 2; /* GLUT_ACTIVE_CTRL */
        if (event['altKey'])
          GLUT.modifiers += 4; /* GLUT_ACTIVE_ALT */
      },
  onMousemove:(event) => {
        /* Send motion event only if the motion changed, prevents
         * spamming our app with uncessary callback call. It does happen in
         * Chrome on Windows.
         */
        var lastX = Browser.mouseX;
        var lastY = Browser.mouseY;
        Browser.calculateMouseEvent(event);
        var newX = Browser.mouseX;
        var newY = Browser.mouseY;
        if (newX == lastX && newY == lastY) return;
  
        if (GLUT.buttons == 0 && event.target == Module["canvas"] && GLUT.passiveMotionFunc) {
          event.preventDefault();
          GLUT.saveModifiers(event);
          getWasmTableEntry(GLUT.passiveMotionFunc)(lastX, lastY);
        } else if (GLUT.buttons != 0 && GLUT.motionFunc) {
          event.preventDefault();
          GLUT.saveModifiers(event);
          getWasmTableEntry(GLUT.motionFunc)(lastX, lastY);
        }
      },
  getSpecialKey:(keycode) => {
          var key = null;
          switch (keycode) {
            case 8:  key = 120 /* backspace */; break;
            case 46: key = 111 /* delete */; break;
  
            case 0x70 /*DOM_VK_F1*/: key = 1 /* GLUT_KEY_F1 */; break;
            case 0x71 /*DOM_VK_F2*/: key = 2 /* GLUT_KEY_F2 */; break;
            case 0x72 /*DOM_VK_F3*/: key = 3 /* GLUT_KEY_F3 */; break;
            case 0x73 /*DOM_VK_F4*/: key = 4 /* GLUT_KEY_F4 */; break;
            case 0x74 /*DOM_VK_F5*/: key = 5 /* GLUT_KEY_F5 */; break;
            case 0x75 /*DOM_VK_F6*/: key = 6 /* GLUT_KEY_F6 */; break;
            case 0x76 /*DOM_VK_F7*/: key = 7 /* GLUT_KEY_F7 */; break;
            case 0x77 /*DOM_VK_F8*/: key = 8 /* GLUT_KEY_F8 */; break;
            case 0x78 /*DOM_VK_F9*/: key = 9 /* GLUT_KEY_F9 */; break;
            case 0x79 /*DOM_VK_F10*/: key = 10 /* GLUT_KEY_F10 */; break;
            case 0x7a /*DOM_VK_F11*/: key = 11 /* GLUT_KEY_F11 */; break;
            case 0x7b /*DOM_VK_F12*/: key = 12 /* GLUT_KEY_F12 */; break;
            case 0x25 /*DOM_VK_LEFT*/: key = 100 /* GLUT_KEY_LEFT */; break;
            case 0x26 /*DOM_VK_UP*/: key = 101 /* GLUT_KEY_UP */; break;
            case 0x27 /*DOM_VK_RIGHT*/: key = 102 /* GLUT_KEY_RIGHT */; break;
            case 0x28 /*DOM_VK_DOWN*/: key = 103 /* GLUT_KEY_DOWN */; break;
            case 0x21 /*DOM_VK_PAGE_UP*/: key = 104 /* GLUT_KEY_PAGE_UP */; break;
            case 0x22 /*DOM_VK_PAGE_DOWN*/: key = 105 /* GLUT_KEY_PAGE_DOWN */; break;
            case 0x24 /*DOM_VK_HOME*/: key = 106 /* GLUT_KEY_HOME */; break;
            case 0x23 /*DOM_VK_END*/: key = 107 /* GLUT_KEY_END */; break;
            case 0x2d /*DOM_VK_INSERT*/: key = 108 /* GLUT_KEY_INSERT */; break;
  
            case 16   /*DOM_VK_SHIFT*/:
            case 0x05 /*DOM_VK_LEFT_SHIFT*/:
              key = 112 /* GLUT_KEY_SHIFT_L */;
              break;
            case 0x06 /*DOM_VK_RIGHT_SHIFT*/:
              key = 113 /* GLUT_KEY_SHIFT_R */;
              break;
  
            case 17   /*DOM_VK_CONTROL*/:
            case 0x03 /*DOM_VK_LEFT_CONTROL*/:
              key = 114 /* GLUT_KEY_CONTROL_L */;
              break;
            case 0x04 /*DOM_VK_RIGHT_CONTROL*/:
              key = 115 /* GLUT_KEY_CONTROL_R */;
              break;
  
            case 18   /*DOM_VK_ALT*/:
            case 0x02 /*DOM_VK_LEFT_ALT*/:
              key = 116 /* GLUT_KEY_ALT_L */;
              break;
            case 0x01 /*DOM_VK_RIGHT_ALT*/:
              key = 117 /* GLUT_KEY_ALT_R */;
              break;
          };
          return key;
      },
  getASCIIKey:(event) => {
        if (event['ctrlKey'] || event['altKey'] || event['metaKey']) return null;
  
        var keycode = event['keyCode'];
  
        /* The exact list is soooo hard to find in a canonical place! */
  
        if (48 <= keycode && keycode <= 57)
          return keycode; // numeric  TODO handle shift?
        if (65 <= keycode && keycode <= 90)
          return event['shiftKey'] ? keycode : keycode + 32;
        if (96 <= keycode && keycode <= 105)
          return keycode - 48; // numpad numbers
        if (106 <= keycode && keycode <= 111)
          return keycode - 106 + 42; // *,+-./  TODO handle shift?
  
        switch (keycode) {
          case 9:  // tab key
          case 13: // return key
          case 27: // escape
          case 32: // space
          case 61: // equal
            return keycode;
        }
  
        var s = event['shiftKey'];
        switch (keycode) {
          case 186: return s ? 58 : 59; // colon / semi-colon
          case 187: return s ? 43 : 61; // add / equal (these two may be wrong)
          case 188: return s ? 60 : 44; // less-than / comma
          case 189: return s ? 95 : 45; // dash
          case 190: return s ? 62 : 46; // greater-than / period
          case 191: return s ? 63 : 47; // forward slash
          case 219: return s ? 123 : 91; // open bracket
          case 220: return s ? 124 : 47; // back slash
          case 221: return s ? 125 : 93; // close bracket
          case 222: return s ? 34 : 39; // single quote
        }
  
        return null;
      },
  onKeydown:(event) => {
        if (GLUT.specialFunc || GLUT.keyboardFunc) {
          var key = GLUT.getSpecialKey(event['keyCode']);
          if (key !== null) {
            if (GLUT.specialFunc) {
              event.preventDefault();
              GLUT.saveModifiers(event);
              getWasmTableEntry(GLUT.specialFunc)(key, Browser.mouseX, Browser.mouseY);
            }
          } else {
            key = GLUT.getASCIIKey(event);
            if (key !== null && GLUT.keyboardFunc) {
              event.preventDefault();
              GLUT.saveModifiers(event);
              getWasmTableEntry(GLUT.keyboardFunc)(key, Browser.mouseX, Browser.mouseY);
            }
          }
        }
      },
  onKeyup:(event) => {
        if (GLUT.specialUpFunc || GLUT.keyboardUpFunc) {
          var key = GLUT.getSpecialKey(event['keyCode']);
          if (key !== null) {
            if (GLUT.specialUpFunc) {
              event.preventDefault ();
              GLUT.saveModifiers(event);
              getWasmTableEntry(GLUT.specialUpFunc)(key, Browser.mouseX, Browser.mouseY);
            }
          } else {
            key = GLUT.getASCIIKey(event);
            if (key !== null && GLUT.keyboardUpFunc) {
              event.preventDefault ();
              GLUT.saveModifiers(event);
              getWasmTableEntry(GLUT.keyboardUpFunc)(key, Browser.mouseX, Browser.mouseY);
            }
          }
        }
      },
  touchHandler:(event) => {
        if (event.target != Module['canvas']) {
          return;
        }
  
        var touches = event.changedTouches,
            main = touches[0],
            type = "";
  
        switch (event.type) {
          case "touchstart": type = "mousedown"; break;
          case "touchmove": type = "mousemove"; break;
          case "touchend": type = "mouseup"; break;
          default: return;
        }
  
        var simulatedEvent = document.createEvent("MouseEvent");
        simulatedEvent.initMouseEvent(type, true, true, window, 1,
                                      main.screenX, main.screenY,
                                      main.clientX, main.clientY, false,
                                      false, false, false, 0/*main*/, null);
  
        main.target.dispatchEvent(simulatedEvent);
        event.preventDefault();
      },
  onMouseButtonDown:(event) => {
        Browser.calculateMouseEvent(event);
  
        GLUT.buttons |= (1 << event['button']);
  
        if (event.target == Module["canvas"] && GLUT.mouseFunc) {
          try {
            event.target.setCapture();
          } catch (e) {}
          event.preventDefault();
          GLUT.saveModifiers(event);
          getWasmTableEntry(GLUT.mouseFunc)(event['button'], 0/*GLUT_DOWN*/, Browser.mouseX, Browser.mouseY);
        }
      },
  onMouseButtonUp:(event) => {
        Browser.calculateMouseEvent(event);
  
        GLUT.buttons &= ~(1 << event['button']);
  
        if (GLUT.mouseFunc) {
          event.preventDefault();
          GLUT.saveModifiers(event);
          getWasmTableEntry(GLUT.mouseFunc)(event['button'], 1/*GLUT_UP*/, Browser.mouseX, Browser.mouseY);
        }
      },
  onMouseWheel:(event) => {
        Browser.calculateMouseEvent(event);
  
        // cross-browser wheel delta
        var e = window.event || event; // old IE support
        // Note the minus sign that flips browser wheel direction (positive direction scrolls page down) to native wheel direction (positive direction is mouse wheel up)
        var delta = -Browser.getMouseWheelDelta(event);
        delta = (delta == 0) ? 0 : (delta > 0 ? Math.max(delta, 1) : Math.min(delta, -1)); // Quantize to integer so that minimum scroll is at least +/- 1.
  
        var button = 3; // wheel up
        if (delta < 0) {
          button = 4; // wheel down
        }
  
        if (GLUT.mouseFunc) {
          event.preventDefault();
          GLUT.saveModifiers(event);
          getWasmTableEntry(GLUT.mouseFunc)(button, 0/*GLUT_DOWN*/, Browser.mouseX, Browser.mouseY);
        }
      },
  onFullscreenEventChange:(event) => {
        var width;
        var height;
        if (document["fullscreen"] || document["fullScreen"] || document["mozFullScreen"] || document["webkitIsFullScreen"]) {
          width = screen["width"];
          height = screen["height"];
        } else {
          width = GLUT.windowWidth;
          height = GLUT.windowHeight;
          // TODO set position
          document.removeEventListener('fullscreenchange', GLUT.onFullscreenEventChange, true);
          document.removeEventListener('mozfullscreenchange', GLUT.onFullscreenEventChange, true);
          document.removeEventListener('webkitfullscreenchange', GLUT.onFullscreenEventChange, true);
        }
        Browser.setCanvasSize(width, height, true); // N.B. GLUT.reshapeFunc is also registered as a canvas resize callback.
                                                    // Just call it once here.
        /* Can't call _glutReshapeWindow as that requests cancelling fullscreen. */
        if (GLUT.reshapeFunc) {
          // out("GLUT.reshapeFunc (from FS): " + width + ", " + height);
          getWasmTableEntry(GLUT.reshapeFunc)(width, height);
        }
        _glutPostRedisplay();
      },
  };

  var _glutGetModifiers = () => GLUT.modifiers;
  _glutGetModifiers.sig = 'i';

  
  
  var _glutInit = (argcp, argv) => {
      // Ignore arguments
      GLUT.initTime = Date.now();
  
      var isTouchDevice = 'ontouchstart' in document.documentElement;
      if (isTouchDevice) {
        // onMouseButtonDown, onMouseButtonUp and onMousemove handlers
        // depend on Browser.mouseX / Browser.mouseY fields. Those fields
        // don't get updated by touch events. So register a touchHandler
        // function that translates the touch events to mouse events.
  
        // GLUT doesn't support touch, mouse only, so from touch events we
        // are only looking at single finger touches to emulate left click,
        // so we can use workaround and convert all touch events in mouse
        // events. See touchHandler.
        window.addEventListener("touchmove", GLUT.touchHandler, true);
        window.addEventListener("touchstart", GLUT.touchHandler, true);
        window.addEventListener("touchend", GLUT.touchHandler, true);
      }
  
      window.addEventListener("keydown", GLUT.onKeydown, true);
      window.addEventListener("keyup", GLUT.onKeyup, true);
      window.addEventListener("mousemove", GLUT.onMousemove, true);
      window.addEventListener("mousedown", GLUT.onMouseButtonDown, true);
      window.addEventListener("mouseup", GLUT.onMouseButtonUp, true);
      // IE9, Chrome, Safari, Opera
      window.addEventListener("mousewheel", GLUT.onMouseWheel, true);
      // Firefox
      window.addEventListener("DOMMouseScroll", GLUT.onMouseWheel, true);
  
      Browser.resizeListeners.push((width, height) => {
        if (GLUT.reshapeFunc) {
          getWasmTableEntry(GLUT.reshapeFunc)(width, height);
        }
      });
  
      __ATEXIT__.push(() => {
        if (isTouchDevice) {
          window.removeEventListener("touchmove", GLUT.touchHandler, true);
          window.removeEventListener("touchstart", GLUT.touchHandler, true);
          window.removeEventListener("touchend", GLUT.touchHandler, true);
        }
  
        window.removeEventListener("keydown", GLUT.onKeydown, true);
        window.removeEventListener("keyup", GLUT.onKeyup, true);
        window.removeEventListener("mousemove", GLUT.onMousemove, true);
        window.removeEventListener("mousedown", GLUT.onMouseButtonDown, true);
        window.removeEventListener("mouseup", GLUT.onMouseButtonUp, true);
        // IE9, Chrome, Safari, Opera
        window.removeEventListener("mousewheel", GLUT.onMouseWheel, true);
        // Firefox
        window.removeEventListener("DOMMouseScroll", GLUT.onMouseWheel, true);
  
        Module["canvas"].width = Module["canvas"].height = 1;
      });
    };
  _glutInit.sig = 'vpp';

  var _glutInitWindowSize = (width, height) => {
      Browser.setCanvasSize( GLUT.initWindowWidth = width,
                             GLUT.initWindowHeight = height );
    };
  _glutInitWindowSize.sig = 'vii';

  var _glutInitWindowPosition = (x, y) => {};
  _glutInitWindowPosition.sig = 'vii';

  var _glutGet = (type) => {
      switch (type) {
        case 100: /* GLUT_WINDOW_X */
          return 0; /* TODO */
        case 101: /* GLUT_WINDOW_Y */
          return 0; /* TODO */
        case 102: /* GLUT_WINDOW_WIDTH */
          return Module['canvas'].width;
        case 103: /* GLUT_WINDOW_HEIGHT */
          return Module['canvas'].height;
        case 200: /* GLUT_SCREEN_WIDTH */
          return Module['canvas'].width;
        case 201: /* GLUT_SCREEN_HEIGHT */
          return Module['canvas'].height;
        case 500: /* GLUT_INIT_WINDOW_X */
          return 0; /* TODO */
        case 501: /* GLUT_INIT_WINDOW_Y */
          return 0; /* TODO */
        case 502: /* GLUT_INIT_WINDOW_WIDTH */
          return GLUT.initWindowWidth;
        case 503: /* GLUT_INIT_WINDOW_HEIGHT */
          return GLUT.initWindowHeight;
        case 700: /* GLUT_ELAPSED_TIME */
          var now = Date.now();
          return now - GLUT.initTime;
        case 0x0069: /* GLUT_WINDOW_STENCIL_SIZE */
          return GLctx.getContextAttributes().stencil ? 8 : 0;
        case 0x006A: /* GLUT_WINDOW_DEPTH_SIZE */
          return GLctx.getContextAttributes().depth ? 8 : 0;
        case 0x006E: /* GLUT_WINDOW_ALPHA_SIZE */
          return GLctx.getContextAttributes().alpha ? 8 : 0;
        case 0x0078: /* GLUT_WINDOW_NUM_SAMPLES */
          return GLctx.getContextAttributes().antialias ? 1 : 0;
  
        default:
          throw "glutGet(" + type + ") not implemented yet";
      }
    };
  _glutGet.sig = 'ii';

  
  
  var _glutIdleFunc = (func) => {
      function callback() {
        if (GLUT.idleFunc) {
          getWasmTableEntry(GLUT.idleFunc)();
          safeSetTimeout(callback, 4); // HTML spec specifies a 4ms minimum delay on the main thread; workers might get more, but we standardize here
        }
      }
      if (!GLUT.idleFunc) {
        safeSetTimeout(callback, 0);
      }
      GLUT.idleFunc = func;
    };
  _glutIdleFunc.sig = 'vp';

  
  
  var _glutTimerFunc = (msec, func, value) =>
      safeSetTimeout(() => getWasmTableEntry(func)(value), msec);
  _glutTimerFunc.sig = 'vipi';

  var _glutDisplayFunc = (func) => {
      GLUT.displayFunc = func;
    };
  _glutDisplayFunc.sig = 'vp';

  var _glutKeyboardFunc = (func) => {
      GLUT.keyboardFunc = func;
    };
  _glutKeyboardFunc.sig = 'vp';

  var _glutKeyboardUpFunc = (func) => {
      GLUT.keyboardUpFunc = func;
    };
  _glutKeyboardUpFunc.sig = 'vp';

  var _glutSpecialFunc = (func) => {
      GLUT.specialFunc = func;
    };
  _glutSpecialFunc.sig = 'vp';

  var _glutSpecialUpFunc = (func) => {
      GLUT.specialUpFunc = func;
    };
  _glutSpecialUpFunc.sig = 'vp';

  var _glutReshapeFunc = (func) => {
      GLUT.reshapeFunc = func;
    };
  _glutReshapeFunc.sig = 'vp';

  var _glutMotionFunc = (func) => {
      GLUT.motionFunc = func;
    };
  _glutMotionFunc.sig = 'vp';

  var _glutPassiveMotionFunc = (func) => {
      GLUT.passiveMotionFunc = func;
    };
  _glutPassiveMotionFunc.sig = 'vp';

  var _glutMouseFunc = (func) => {
      GLUT.mouseFunc = func;
    };
  _glutMouseFunc.sig = 'vp';

  var _glutSetCursor = (cursor) => {
      var cursorStyle = 'auto';
      switch (cursor) {
        case 0x0000: /* GLUT_CURSOR_RIGHT_ARROW */
          // No equivalent css cursor style, fallback to 'auto'
          break;
        case 0x0001: /* GLUT_CURSOR_LEFT_ARROW */
          // No equivalent css cursor style, fallback to 'auto'
          break;
        case 0x0002: /* GLUT_CURSOR_INFO */
          cursorStyle = 'pointer';
          break;
        case 0x0003: /* GLUT_CURSOR_DESTROY */
          // No equivalent css cursor style, fallback to 'auto'
          break;
        case 0x0004: /* GLUT_CURSOR_HELP */
          cursorStyle = 'help';
          break;
        case 0x0005: /* GLUT_CURSOR_CYCLE */
          // No equivalent css cursor style, fallback to 'auto'
          break;
        case 0x0006: /* GLUT_CURSOR_SPRAY */
          // No equivalent css cursor style, fallback to 'auto'
          break;
        case 0x0007: /* GLUT_CURSOR_WAIT */
          cursorStyle = 'wait';
          break;
        case 0x0008: /* GLUT_CURSOR_TEXT */
          cursorStyle = 'text';
          break;
        case 0x0009: /* GLUT_CURSOR_CROSSHAIR */
        case 0x0066: /* GLUT_CURSOR_FULL_CROSSHAIR */
          cursorStyle = 'crosshair';
          break;
        case 0x000A: /* GLUT_CURSOR_UP_DOWN */
          cursorStyle = 'ns-resize';
          break;
        case 0x000B: /* GLUT_CURSOR_LEFT_RIGHT */
          cursorStyle = 'ew-resize';
          break;
        case 0x000C: /* GLUT_CURSOR_TOP_SIDE */
          cursorStyle = 'n-resize';
          break;
        case 0x000D: /* GLUT_CURSOR_BOTTOM_SIDE */
          cursorStyle = 's-resize';
          break;
        case 0x000E: /* GLUT_CURSOR_LEFT_SIDE */
          cursorStyle = 'w-resize';
          break;
        case 0x000F: /* GLUT_CURSOR_RIGHT_SIDE */
          cursorStyle = 'e-resize';
          break;
        case 0x0010: /* GLUT_CURSOR_TOP_LEFT_CORNER */
          cursorStyle = 'nw-resize';
          break;
        case 0x0011: /* GLUT_CURSOR_TOP_RIGHT_CORNER */
          cursorStyle = 'ne-resize';
          break;
        case 0x0012: /* GLUT_CURSOR_BOTTOM_RIGHT_CORNER */
          cursorStyle = 'se-resize';
          break;
        case 0x0013: /* GLUT_CURSOR_BOTTOM_LEFT_CORNER */
          cursorStyle = 'sw-resize';
          break;
        case 0x0064: /* GLUT_CURSOR_INHERIT */
          break;
        case 0x0065: /* GLUT_CURSOR_NONE */
          cursorStyle = 'none';
          break;
        default:
          throw "glutSetCursor: Unknown cursor type: " + cursor;
      }
      Module['canvas'].style.cursor = cursorStyle;
    };
  _glutSetCursor.sig = 'vi';

  
  var _glutCreateWindow = (name) => {
      var contextAttributes = {
        antialias: ((GLUT.initDisplayMode & 0x0080 /*GLUT_MULTISAMPLE*/) != 0),
        depth: ((GLUT.initDisplayMode & 0x0010 /*GLUT_DEPTH*/) != 0),
        stencil: ((GLUT.initDisplayMode & 0x0020 /*GLUT_STENCIL*/) != 0),
        alpha: ((GLUT.initDisplayMode & 0x0008 /*GLUT_ALPHA*/) != 0)
      };
      if (!Browser.createContext(Module['canvas'], /*useWebGL=*/true, /*setInModule=*/true, contextAttributes)) {
        return 0; // failure
      }
      return 1; // a new GLUT window ID for the created context
    };
  _glutCreateWindow.sig = 'ip';

  
  var _glutDestroyWindow = (name) => {
      delete Module['ctx'];
      return 1;
    };
  _glutDestroyWindow.sig = 'vi';

  
  
  
  var _glutReshapeWindow = (width, height) => {
      Browser.exitFullscreen();
      Browser.setCanvasSize(width, height, true); // N.B. GLUT.reshapeFunc is also registered as a canvas resize callback.
                                                  // Just call it once here.
      if (GLUT.reshapeFunc) {
        getWasmTableEntry(GLUT.reshapeFunc)(width, height);
      }
      _glutPostRedisplay();
    };
  _glutReshapeWindow.sig = 'vii';

  
  
  var _glutPositionWindow = (x, y) => {
      Browser.exitFullscreen();
      /* TODO */
      _glutPostRedisplay();
    };
  _glutPositionWindow.sig = 'vii';

  
  
  var _glutFullScreen = () => {
      GLUT.windowX = 0; // TODO
      GLUT.windowY = 0; // TODO
      GLUT.windowWidth  = Module['canvas'].width;
      GLUT.windowHeight = Module['canvas'].height;
      document.addEventListener('fullscreenchange', GLUT.onFullscreenEventChange, true);
      document.addEventListener('mozfullscreenchange', GLUT.onFullscreenEventChange, true);
      document.addEventListener('webkitfullscreenchange', GLUT.onFullscreenEventChange, true);
      Browser.requestFullscreen(/*lockPointer=*/false, /*resizeCanvas=*/false);
    };
  _glutFullScreen.sig = 'v';

  var _glutInitDisplayMode = (mode) => GLUT.initDisplayMode = mode;
  _glutInitDisplayMode.sig = 'vi';

  var _glutSwapBuffers = () => {};
  _glutSwapBuffers.sig = 'v';


  
  
  
  var _glutMainLoop = () => {
      _glutReshapeWindow(Module['canvas'].width, Module['canvas'].height);
      _glutPostRedisplay();
      throw 'unwind';
    };
  _glutMainLoop.sig = 'v';

  var _XOpenDisplay = (name) => 1;
  _XOpenDisplay.sig = 'pp';

  var _XCreateWindow = (display, parent, x, y, width, height, border_width, depth, class_, visual, valuemask, attributes) => {
      // All we can do is set the width and height
      Browser.setCanvasSize(width, height);
      return 2;
    };
  _XCreateWindow.sig = 'pppiiiiiiippp';

  var _XChangeWindowAttributes = (display, window, valuemask, attributes) => {};
  _XChangeWindowAttributes.sig = 'ipppp';

  var _XSetWMHints = (display, win, hints) => {};
  _XSetWMHints.sig = 'ippp';

  var _XMapWindow = (display, win) => {};
  _XMapWindow.sig = 'ipp';

  var _XStoreName = (display, win, name) => {};
  _XStoreName.sig = 'ippp';

  var _XInternAtom = (display, name_, hmm)  => 0;
  _XInternAtom.sig = 'pppi';

  var _XSendEvent = (display, win, propagate, event_mask, even_send) => {};
  _XSendEvent.sig = 'ippipp';

  var _XPending = (display) => 0;
  _XPending.sig = 'ip';



  var _eglInitialize = (display, majorVersion, minorVersion) => {
      if (display != 62000) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      if (majorVersion) {
        HEAP32[((majorVersion)>>2)] = 1; // Advertise EGL Major version: '1'
      }
      if (minorVersion) {
        HEAP32[((minorVersion)>>2)] = 4; // Advertise EGL Minor version: '4'
      }
      EGL.defaultDisplayInitialized = true;
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 1;
    };
  _eglInitialize.sig = 'ippp';

  var _eglTerminate = (display) => {
      if (display != 62000) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      EGL.currentContext = 0;
      EGL.currentReadSurface = 0;
      EGL.currentDrawSurface = 0;
      EGL.defaultDisplayInitialized = false;
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 1;
    };
  _eglTerminate.sig = 'ip';

  var _eglGetConfigs = (display, configs, config_size, numConfigs) =>
      EGL.chooseConfig(display, 0, configs, config_size, numConfigs);
  _eglGetConfigs.sig = 'ippip';


  var _eglGetConfigAttrib = (display, config, attribute, value) => {
      if (display != 62000) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      if (config != 62002) {
        EGL.setErrorCode(0x3005 /* EGL_BAD_CONFIG */);
        return 0;
      }
      if (!value) {
        EGL.setErrorCode(0x300C /* EGL_BAD_PARAMETER */);
        return 0;
      }
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      switch (attribute) {
      case 0x3020: // EGL_BUFFER_SIZE
        HEAP32[((value)>>2)] = EGL.contextAttributes.alpha ? 32 : 24;
        return 1;
      case 0x3021: // EGL_ALPHA_SIZE
        HEAP32[((value)>>2)] = EGL.contextAttributes.alpha ? 8 : 0;
        return 1;
      case 0x3022: // EGL_BLUE_SIZE
        HEAP32[((value)>>2)] = 8;
        return 1;
      case 0x3023: // EGL_GREEN_SIZE
        HEAP32[((value)>>2)] = 8;
        return 1;
      case 0x3024: // EGL_RED_SIZE
        HEAP32[((value)>>2)] = 8;
        return 1;
      case 0x3025: // EGL_DEPTH_SIZE
        HEAP32[((value)>>2)] = EGL.contextAttributes.depth ? 24 : 0;
        return 1;
      case 0x3026: // EGL_STENCIL_SIZE
        HEAP32[((value)>>2)] = EGL.contextAttributes.stencil ? 8 : 0;
        return 1;
      case 0x3027: // EGL_CONFIG_CAVEAT
        // We can return here one of EGL_NONE (0x3038), EGL_SLOW_CONFIG (0x3050) or EGL_NON_CONFORMANT_CONFIG (0x3051).
        HEAP32[((value)>>2)] = 0x3038;
        return 1;
      case 0x3028: // EGL_CONFIG_ID
        HEAP32[((value)>>2)] = 62002;
        return 1;
      case 0x3029: // EGL_LEVEL
        HEAP32[((value)>>2)] = 0;
        return 1;
      case 0x302A: // EGL_MAX_PBUFFER_HEIGHT
        HEAP32[((value)>>2)] = 4096;
        return 1;
      case 0x302B: // EGL_MAX_PBUFFER_PIXELS
        HEAP32[((value)>>2)] = 16777216;
        return 1;
      case 0x302C: // EGL_MAX_PBUFFER_WIDTH
        HEAP32[((value)>>2)] = 4096;
        return 1;
      case 0x302D: // EGL_NATIVE_RENDERABLE
        HEAP32[((value)>>2)] = 0;
        return 1;
      case 0x302E: // EGL_NATIVE_VISUAL_ID
        HEAP32[((value)>>2)] = 0;
        return 1;
      case 0x302F: // EGL_NATIVE_VISUAL_TYPE
        HEAP32[((value)>>2)] = 0x3038;
        return 1;
      case 0x3031: // EGL_SAMPLES
        HEAP32[((value)>>2)] = EGL.contextAttributes.antialias ? 4 : 0;
        return 1;
      case 0x3032: // EGL_SAMPLE_BUFFERS
        HEAP32[((value)>>2)] = EGL.contextAttributes.antialias ? 1 : 0;
        return 1;
      case 0x3033: // EGL_SURFACE_TYPE
        HEAP32[((value)>>2)] = 0x4;
        return 1;
      case 0x3034: // EGL_TRANSPARENT_TYPE
        // If this returns EGL_TRANSPARENT_RGB (0x3052), transparency is used through color-keying. No such thing applies to Emscripten canvas.
        HEAP32[((value)>>2)] = 0x3038;
        return 1;
      case 0x3035: // EGL_TRANSPARENT_BLUE_VALUE
      case 0x3036: // EGL_TRANSPARENT_GREEN_VALUE
      case 0x3037: // EGL_TRANSPARENT_RED_VALUE
        // "If EGL_TRANSPARENT_TYPE is EGL_NONE, then the values for EGL_TRANSPARENT_RED_VALUE, EGL_TRANSPARENT_GREEN_VALUE, and EGL_TRANSPARENT_BLUE_VALUE are undefined."
        HEAP32[((value)>>2)] = -1;
        return 1;
      case 0x3039: // EGL_BIND_TO_TEXTURE_RGB
      case 0x303A: // EGL_BIND_TO_TEXTURE_RGBA
        HEAP32[((value)>>2)] = 0;
        return 1;
      case 0x303B: // EGL_MIN_SWAP_INTERVAL
        HEAP32[((value)>>2)] = 0;
        return 1;
      case 0x303C: // EGL_MAX_SWAP_INTERVAL
        HEAP32[((value)>>2)] = 1;
        return 1;
      case 0x303D: // EGL_LUMINANCE_SIZE
      case 0x303E: // EGL_ALPHA_MASK_SIZE
        HEAP32[((value)>>2)] = 0;
        return 1;
      case 0x303F: // EGL_COLOR_BUFFER_TYPE
        // EGL has two types of buffers: EGL_RGB_BUFFER and EGL_LUMINANCE_BUFFER.
        HEAP32[((value)>>2)] = 0x308E;
        return 1;
      case 0x3040: // EGL_RENDERABLE_TYPE
        // A bit combination of EGL_OPENGL_ES_BIT,EGL_OPENVG_BIT,EGL_OPENGL_ES2_BIT and EGL_OPENGL_BIT.
        HEAP32[((value)>>2)] = 0x4;
        return 1;
      case 0x3042: // EGL_CONFORMANT
        // "EGL_CONFORMANT is a mask indicating if a client API context created with respect to the corresponding EGLConfig will pass the required conformance tests for that API."
        HEAP32[((value)>>2)] = 0;
        return 1;
      default:
        EGL.setErrorCode(0x3004 /* EGL_BAD_ATTRIBUTE */);
        return 0;
      }
    };
  _eglGetConfigAttrib.sig = 'ippip';

  var _eglCreateWindowSurface = (display, config, win, attrib_list) => {
      if (display != 62000) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      if (config != 62002) {
        EGL.setErrorCode(0x3005 /* EGL_BAD_CONFIG */);
        return 0;
      }
      // TODO: Examine attrib_list! Parameters that can be present there are:
      // - EGL_RENDER_BUFFER (must be EGL_BACK_BUFFER)
      // - EGL_VG_COLORSPACE (can't be set)
      // - EGL_VG_ALPHA_FORMAT (can't be set)
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 62006; /* Magic ID for Emscripten 'default surface' */
    };
  _eglCreateWindowSurface.sig = 'pppip';

  var _eglDestroySurface = (display, surface) => {
      if (display != 62000) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      if (surface != 62006 /* Magic ID for the only EGLSurface supported by Emscripten */) {
        EGL.setErrorCode(0x300D /* EGL_BAD_SURFACE */);
        return 1;
      }
      if (EGL.currentReadSurface == surface) {
        EGL.currentReadSurface = 0;
      }
      if (EGL.currentDrawSurface == surface) {
        EGL.currentDrawSurface = 0;
      }
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 1; /* Magic ID for Emscripten 'default surface' */
    };
  _eglDestroySurface.sig = 'ipp';

  
  var _eglCreateContext = (display, config, hmm, contextAttribs) => {
      if (display != 62000) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
  
      // EGL 1.4 spec says default EGL_CONTEXT_CLIENT_VERSION is GLES1, but this is not supported by Emscripten.
      // So user must pass EGL_CONTEXT_CLIENT_VERSION == 2 to initialize EGL.
      var glesContextVersion = 1;
      for (;;) {
        var param = HEAP32[((contextAttribs)>>2)];
        if (param == 0x3098 /*EGL_CONTEXT_CLIENT_VERSION*/) {
          glesContextVersion = HEAP32[(((contextAttribs)+(4))>>2)];
        } else if (param == 0x3038 /*EGL_NONE*/) {
          break;
        } else {
          /* EGL1.4 specifies only EGL_CONTEXT_CLIENT_VERSION as supported attribute */
          EGL.setErrorCode(0x3004 /*EGL_BAD_ATTRIBUTE*/);
          return 0;
        }
        contextAttribs += 8;
      }
      if (glesContextVersion < 2 || glesContextVersion > 3) {
        EGL.setErrorCode(0x3005 /* EGL_BAD_CONFIG */);
        return 0; /* EGL_NO_CONTEXT */
      }
  
      EGL.contextAttributes.majorVersion = glesContextVersion - 1; // WebGL 1 is GLES 2, WebGL2 is GLES3
      EGL.contextAttributes.minorVersion = 0;
  
      EGL.context = GL.createContext(Module['canvas'], EGL.contextAttributes);
  
      if (EGL.context != 0) {
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
  
        // Run callbacks so that GL emulation works
        GL.makeContextCurrent(EGL.context);
        Browser.useWebGL = true;
        Browser.moduleContextCreatedCallbacks.forEach((callback) => callback());
  
        // Note: This function only creates a context, but it shall not make it active.
        GL.makeContextCurrent(null);
        return 62004;
      } else {
        EGL.setErrorCode(0x3009 /* EGL_BAD_MATCH */); // By the EGL 1.4 spec, an implementation that does not support GLES2 (WebGL in this case), this error code is set.
        return 0; /* EGL_NO_CONTEXT */
      }
    };
  _eglCreateContext.sig = 'ppppp';

  
  var _eglDestroyContext = (display, context) => {
      if (display != 62000) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      if (context != 62004) {
        EGL.setErrorCode(0x3006 /* EGL_BAD_CONTEXT */);
        return 0;
      }
  
      GL.deleteContext(EGL.context);
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      if (EGL.currentContext == context) {
        EGL.currentContext = 0;
      }
      return 1 /* EGL_TRUE */;
    };
  _eglDestroyContext.sig = 'ipp';

  var _eglQuerySurface = (display, surface, attribute, value) => {
      if (display != 62000) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      if (surface != 62006 /* Magic ID for Emscripten 'default surface' */) {
        EGL.setErrorCode(0x300D /* EGL_BAD_SURFACE */);
        return 0;
      }
      if (!value) {
        EGL.setErrorCode(0x300C /* EGL_BAD_PARAMETER */);
        return 0;
      }
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      switch (attribute) {
      case 0x3028: // EGL_CONFIG_ID
        HEAP32[((value)>>2)] = 62002;
          return 1;
      case 0x3058: // EGL_LARGEST_PBUFFER
        // Odd EGL API: If surface is not a pbuffer surface, 'value' should not be written to. It's not specified as an error, so true should(?) be returned.
        // Existing Android implementation seems to do so at least.
        return 1;
      case 0x3057: // EGL_WIDTH
        HEAP32[((value)>>2)] = Module["canvas"].width;
        return 1;
      case 0x3056: // EGL_HEIGHT
        HEAP32[((value)>>2)] = Module["canvas"].height;
        return 1;
      case 0x3090: // EGL_HORIZONTAL_RESOLUTION
        HEAP32[((value)>>2)] = -1;
        return 1;
      case 0x3091: // EGL_VERTICAL_RESOLUTION
        HEAP32[((value)>>2)] = -1;
        return 1;
      case 0x3092: // EGL_PIXEL_ASPECT_RATIO
        HEAP32[((value)>>2)] = -1;
        return 1;
      case 0x3086: // EGL_RENDER_BUFFER
        // The main surface is bound to the visible canvas window - it's always backbuffered.
        // Alternative to EGL_BACK_BUFFER would be EGL_SINGLE_BUFFER.
        HEAP32[((value)>>2)] = 0x3084;
        return 1;
      case 0x3099: // EGL_MULTISAMPLE_RESOLVE
        HEAP32[((value)>>2)] = 0x309A;
        return 1;
      case 0x3093: // EGL_SWAP_BEHAVIOR
        // The two possibilities are EGL_BUFFER_PRESERVED and EGL_BUFFER_DESTROYED. Slightly unsure which is the
        // case for browser environment, but advertise the 'weaker' behavior to be sure.
        HEAP32[((value)>>2)] = 0x3095;
        return 1;
      case 0x3080: // EGL_TEXTURE_FORMAT
      case 0x3081: // EGL_TEXTURE_TARGET
      case 0x3082: // EGL_MIPMAP_TEXTURE
      case 0x3083: // EGL_MIPMAP_LEVEL
        // This is a window surface, not a pbuffer surface. Spec:
        // "Querying EGL_TEXTURE_FORMAT, EGL_TEXTURE_TARGET, EGL_MIPMAP_TEXTURE, or EGL_MIPMAP_LEVEL for a non-pbuffer surface is not an error, but value is not modified."
        // So pass-through.
        return 1;
      default:
        EGL.setErrorCode(0x3004 /* EGL_BAD_ATTRIBUTE */);
        return 0;
      }
    };
  _eglQuerySurface.sig = 'ippip';

  var _eglQueryContext = (display, context, attribute, value) => {
      if (display != 62000) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      //\todo An EGL_NOT_INITIALIZED error is generated if EGL is not initialized for dpy.
      if (context != 62004) {
        EGL.setErrorCode(0x3006 /* EGL_BAD_CONTEXT */);
        return 0;
      }
      if (!value) {
        EGL.setErrorCode(0x300C /* EGL_BAD_PARAMETER */);
        return 0;
      }
  
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      switch (attribute) {
        case 0x3028: // EGL_CONFIG_ID
          HEAP32[((value)>>2)] = 62002;
          return 1;
        case 0x3097: // EGL_CONTEXT_CLIENT_TYPE
          HEAP32[((value)>>2)] = 0x30A0;
          return 1;
        case 0x3098: // EGL_CONTEXT_CLIENT_VERSION
          HEAP32[((value)>>2)] = EGL.contextAttributes.majorVersion + 1;
          return 1;
        case 0x3086: // EGL_RENDER_BUFFER
          // The context is bound to the visible canvas window - it's always backbuffered.
          // Alternative to EGL_BACK_BUFFER would be EGL_SINGLE_BUFFER.
          HEAP32[((value)>>2)] = 0x3084;
          return 1;
        default:
          EGL.setErrorCode(0x3004 /* EGL_BAD_ATTRIBUTE */);
          return 0;
      }
    };
  _eglQueryContext.sig = 'ippip';

  var _eglGetError = () => EGL.errorCode;
  _eglGetError.sig = 'i';

  
  var _eglQueryString = (display, name) => {
      if (display != 62000) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      //\todo An EGL_NOT_INITIALIZED error is generated if EGL is not initialized for dpy.
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      if (EGL.stringCache[name]) return EGL.stringCache[name];
      var ret;
      switch (name) {
        case 0x3053 /* EGL_VENDOR */: ret = stringToNewUTF8("Emscripten"); break;
        case 0x3054 /* EGL_VERSION */: ret = stringToNewUTF8("1.4 Emscripten EGL"); break;
        case 0x3055 /* EGL_EXTENSIONS */:  ret = stringToNewUTF8(""); break; // Currently not supporting any EGL extensions.
        case 0x308D /* EGL_CLIENT_APIS */: ret = stringToNewUTF8("OpenGL_ES"); break;
        default:
          EGL.setErrorCode(0x300C /* EGL_BAD_PARAMETER */);
          return 0;
      }
      EGL.stringCache[name] = ret;
      return ret;
    };
  _eglQueryString.sig = 'ppi';

  var _eglBindAPI = (api) => {
      if (api == 0x30A0 /* EGL_OPENGL_ES_API */) {
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
        return 1;
      }
      // if (api == 0x30A1 /* EGL_OPENVG_API */ || api == 0x30A2 /* EGL_OPENGL_API */) {
      EGL.setErrorCode(0x300C /* EGL_BAD_PARAMETER */);
      return 0;
    };
  _eglBindAPI.sig = 'ii';

  var _eglQueryAPI = () => {
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 0x30A0; // EGL_OPENGL_ES_API
    };
  _eglQueryAPI.sig = 'i';

  var _eglWaitClient = () => {
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 1;
    };
  _eglWaitClient.sig = 'i';

  var _eglWaitNative = (nativeEngineId) => {
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 1;
    };
  _eglWaitNative.sig = 'ii';

  
  var _eglWaitGL = _eglWaitClient;
  _eglWaitGL.sig = 'i';

  
  var _eglSwapInterval = (display, interval) => {
      if (display != 62000) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0;
      }
      if (interval == 0) _emscripten_set_main_loop_timing(0, 0);
      else _emscripten_set_main_loop_timing(1, interval);
  
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 1;
    };
  _eglSwapInterval.sig = 'ipi';

  
  var _eglMakeCurrent = (display, draw, read, context) => {
      if (display != 62000) {
        EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
        return 0 /* EGL_FALSE */;
      }
      //\todo An EGL_NOT_INITIALIZED error is generated if EGL is not initialized for dpy.
      if (context != 0 && context != 62004) {
        EGL.setErrorCode(0x3006 /* EGL_BAD_CONTEXT */);
        return 0;
      }
      if ((read != 0 && read != 62006) || (draw != 0 && draw != 62006 /* Magic ID for Emscripten 'default surface' */)) {
        EGL.setErrorCode(0x300D /* EGL_BAD_SURFACE */);
        return 0;
      }
  
      GL.makeContextCurrent(context ? EGL.context : null);
  
      EGL.currentContext = context;
      EGL.currentDrawSurface = draw;
      EGL.currentReadSurface = read;
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 1 /* EGL_TRUE */;
    };
  _eglMakeCurrent.sig = 'ipppp';

  var _eglGetCurrentContext = () => EGL.currentContext;
  _eglGetCurrentContext.sig = 'p';

  var _eglGetCurrentSurface = (readdraw) => {
      if (readdraw == 0x305A /* EGL_READ */) {
        return EGL.currentReadSurface;
      } else if (readdraw == 0x3059 /* EGL_DRAW */) {
        return EGL.currentDrawSurface;
      } else {
        EGL.setErrorCode(0x300C /* EGL_BAD_PARAMETER */);
        return 0 /* EGL_NO_SURFACE */;
      }
    };
  _eglGetCurrentSurface.sig = 'pi';


  
  var _eglSwapBuffers = (dpy, surface) => {
  
      if (!EGL.defaultDisplayInitialized) {
        EGL.setErrorCode(0x3001 /* EGL_NOT_INITIALIZED */);
      } else if (!GLctx) {
        EGL.setErrorCode(0x3002 /* EGL_BAD_ACCESS */);
      } else if (GLctx.isContextLost()) {
        EGL.setErrorCode(0x300E /* EGL_CONTEXT_LOST */);
      } else {
        // According to documentation this does an implicit flush.
        // Due to discussion at https://github.com/emscripten-core/emscripten/pull/1871
        // the flush was removed since this _may_ result in slowing code down.
        //_glFlush();
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
        return 1 /* EGL_TRUE */;
      }
      return 0 /* EGL_FALSE */;
    };
  _eglSwapBuffers.sig = 'ipp';

  var _eglReleaseThread = () => {
      // Equivalent to eglMakeCurrent with EGL_NO_CONTEXT and EGL_NO_SURFACE.
      EGL.currentContext = 0;
      EGL.currentReadSurface = 0;
      EGL.currentDrawSurface = 0;
      // EGL spec v1.4 p.55:
      // "calling eglGetError immediately following a successful call to eglReleaseThread should not be done.
      //  Such a call will return EGL_SUCCESS - but will also result in reallocating per-thread state."
      EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
      return 1 /* EGL_TRUE */;
    };
  _eglReleaseThread.sig = 'i';

  var _uuid_clear = (uu) => zeroMemory(uu, 16);
  _uuid_clear.sig = 'vp';

  var _uuid_compare = (uu1, uu2) => _memcmp(uu1, uu2, 16);
  _uuid_compare.sig = 'ipp';

  var _uuid_copy = (dst, src) => _memcpy(dst, src, 16);
  _uuid_copy.sig = 'vpp';

  var _uuid_generate = (out) => {
      // void uuid_generate(uuid_t out);
      var uuid = null;
  
      if (ENVIRONMENT_IS_NODE) {
      } else if (ENVIRONMENT_IS_WEB &&
                 typeof window.crypto != 'undefined' &&
                 typeof window.crypto.getRandomValues != 'undefined') {
        // If crypto.getRandomValues is available try to use it.
        uuid = new Uint8Array(16);
        window.crypto.getRandomValues(uuid);
      }
  
      // Fall back to Math.random if a higher quality random number generator is not available.
      if (!uuid) {
        uuid = new Array(16);
        var d = new Date().getTime();
        for (var i = 0; i < 16; i++) {
          var r = ((d + Math.random() * 256) % 256)|0;
          d = (d / 256)|0;
          uuid[i] = r;
        }
      }
  
      // Makes uuid compliant to RFC-4122
      uuid[6] = (uuid[6] & 0x0F) | 0x40; // uuid version
      uuid[8] = (uuid[8] & 0x3F) | 0x80; // uuid variant
      writeArrayToMemory(uuid, out);
    };
  _uuid_generate.sig = 'vp';

  var _uuid_is_null = (uu) => {
      // int uuid_is_null(const uuid_t uu);
      for (var i = 0; i < 4; i++, uu = (uu+4)|0) {
        var val = HEAP32[((uu)>>2)];
        if (val) {
          return 0;
        }
      }
      return 1;
    };
  _uuid_is_null.sig = 'ip';

  var _uuid_parse = (inp, uu) => {
      // int uuid_parse(const char *in, uuid_t uu);
      inp = UTF8ToString(inp);
      if (inp.length === 36) {
        var i = 0;
        var uuid = new Array(16);
        inp.toLowerCase().replace(/[0-9a-f]{2}/g, function(byte) {
          if (i < 16) {
            uuid[i++] = parseInt(byte, 16);
          }
        });
  
        if (i < 16) {
          return -1;
        }
        writeArrayToMemory(uuid, uu);
        return 0;
      }
      return -1;
    };
  _uuid_parse.sig = 'ipp';

  /** @param {number|boolean=} upper */
  var _uuid_unparse = (uu, out, upper) => {
      // void uuid_unparse(const uuid_t uu, char *out);
      var i = 0;
      var uuid = 'xxxx-xx-xx-xx-xxxxxx'.replace(/[x]/g, function(c) {
        var r = upper ? (HEAPU8[(uu)+(i)]).toString(16).toUpperCase() :
                        (HEAPU8[(uu)+(i)]).toString(16);
        r = (r.length === 1) ? '0' + r : r; // Zero pad single digit hex values
        i++;
        return r;
      });
      stringToUTF8(uuid, out, 37); // Always fixed 36 bytes of ASCII characters and a trailing \0.
    };
  _uuid_unparse.sig = 'vpp';

  var _uuid_unparse_lower = (uu, out) => {
      // void uuid_unparse_lower(const uuid_t uu, char *out);
      _uuid_unparse(uu, out);
    };
  _uuid_unparse_lower.sig = 'vpp';

  var _uuid_unparse_upper = (uu, out) => {
      // void uuid_unparse_upper(const uuid_t uu, char *out);
      _uuid_unparse(uu, out, true);
    };
  _uuid_unparse_upper.sig = 'vpp';

  var _uuid_type = (uu) => 4;
  _uuid_type.sig = 'ip';

  var _uuid_variant = (uu) => 1;
  _uuid_variant.sig = 'ip';

  
  
  
  
  var GLEW = {
  isLinaroFork:1,
  extensions:null,
  error:{
  0:null,
  1:null,
  2:null,
  3:null,
  4:null,
  5:null,
  6:null,
  7:null,
  8:null,
  },
  version:{
  1:null,
  2:null,
  3:null,
  4:null,
  },
  errorStringConstantFromCode(error) {
        if (GLEW.isLinaroFork) {
          switch (error) {
            case 4:return "OpenGL ES lib expected, found OpenGL lib"; // GLEW_ERROR_NOT_GLES_VERSION
            case 5:return "OpenGL lib expected, found OpenGL ES lib"; // GLEW_ERROR_GLES_VERSION
            case 6:return "Missing EGL version"; // GLEW_ERROR_NO_EGL_VERSION
            case 7:return "EGL 1.1 and up are supported"; // GLEW_ERROR_EGL_VERSION_10_ONLY
            default:break;
          }
        }
  
        switch (error) {
          case 0:return "No error"; // GLEW_OK || GLEW_NO_ERROR
          case 1:return "Missing GL version"; // GLEW_ERROR_NO_GL_VERSION
          case 2:return "GL 1.1 and up are supported"; // GLEW_ERROR_GL_VERSION_10_ONLY
          case 3:return "GLX 1.2 and up are supported"; // GLEW_ERROR_GLX_VERSION_11_ONLY
          default:return null;
        }
      },
  errorString(error) {
        if (!GLEW.error[error]) {
          var string = GLEW.errorStringConstantFromCode(error);
          if (!string) {
            string = "Unknown error";
            error = 8; // prevent array from growing more than this
          }
          GLEW.error[error] = stringToNewUTF8(string);
        }
        return GLEW.error[error];
      },
  versionStringConstantFromCode(name) {
        switch (name) {
          case 1:return "1.10.0"; // GLEW_VERSION
          case 2:return "1"; // GLEW_VERSION_MAJOR
          case 3:return "10"; // GLEW_VERSION_MINOR
          case 4:return "0"; // GLEW_VERSION_MICRO
          default:return null;
        }
      },
  versionString(name) {
        if (!GLEW.version[name]) {
          var string = GLEW.versionStringConstantFromCode(name);
          if (!string)
            return 0;
          GLEW.version[name] = stringToNewUTF8(string);
        }
        return GLEW.version[name];
      },
  extensionIsSupported(name) {
        GLEW.extensions ||= webglGetExtensions();
  
        if (GLEW.extensions.includes(name))
          return 1;
  
        // extensions from GLEmulations do not come unprefixed
        // so, try with prefix
        return (GLEW.extensions.includes("GL_" + name));
      },
  };

  var _glewInit = () => 0;
  _glewInit.sig = 'i';

  
  var _glewIsSupported = (name) => {
      var exts = UTF8ToString(name).split(' ');
      for (var i = 0; i < exts.length; ++i) {
        if (!GLEW.extensionIsSupported(exts[i]))
          return 0;
      }
      return 1;
    };
  _glewIsSupported.sig = 'ip';

  
  var _glewGetExtension = (name) => GLEW.extensionIsSupported(UTF8ToString(name));
  _glewGetExtension.sig = 'ip';

  var _glewGetErrorString = (error) => GLEW.errorString(error);
  _glewGetErrorString.sig = 'pi';

  var _glewGetString = (name) => GLEW.versionString(name);
  _glewGetString.sig = 'pi';

  var IDBStore = {
  indexedDB() {
      if (typeof indexedDB != 'undefined') return indexedDB;
      var ret = null;
      if (typeof window == 'object') ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      assert(ret, 'IDBStore used, but indexedDB not supported');
      return ret;
    },
  DB_VERSION:22,
  DB_STORE_NAME:"FILE_DATA",
  dbs:{
  },
  blobs:[0],
  getDB(name, callback) {
      // check the cache first
      var db = IDBStore.dbs[name];
      if (db) {
        return callback(null, db);
      }
      var req;
      try {
        req = IDBStore.indexedDB().open(name, IDBStore.DB_VERSION);
      } catch (e) {
        return callback(e);
      }
      req.onupgradeneeded = (e) => {
        var db = /** @type {IDBDatabase} */ (e.target.result);
        var transaction = e.target.transaction;
        var fileStore;
        if (db.objectStoreNames.contains(IDBStore.DB_STORE_NAME)) {
          fileStore = transaction.objectStore(IDBStore.DB_STORE_NAME);
        } else {
          fileStore = db.createObjectStore(IDBStore.DB_STORE_NAME);
        }
      };
      req.onsuccess = () => {
        db = /** @type {IDBDatabase} */ (req.result);
        // add to the cache
        IDBStore.dbs[name] = db;
        callback(null, db);
      };
      req.onerror = function(event) {
        callback(event.target.error || 'unknown error');
        event.preventDefault();
      };
    },
  getStore(dbName, type, callback) {
      IDBStore.getDB(dbName, (error, db) => {
        if (error) return callback(error);
        var transaction = db.transaction([IDBStore.DB_STORE_NAME], type);
        transaction.onerror = (event) => {
          callback(event.target.error || 'unknown error');
          event.preventDefault();
        };
        var store = transaction.objectStore(IDBStore.DB_STORE_NAME);
        callback(null, store);
      });
    },
  getFile(dbName, id, callback) {
      IDBStore.getStore(dbName, 'readonly', (err, store) => {
        if (err) return callback(err);
        var req = store.get(id);
        req.onsuccess = (event) => {
          var result = event.target.result;
          if (!result) {
            return callback(`file ${id} not found`);
          }
          return callback(null, result);
        };
        req.onerror = callback;
      });
    },
  setFile(dbName, id, data, callback) {
      IDBStore.getStore(dbName, 'readwrite', (err, store) => {
        if (err) return callback(err);
        var req = store.put(data, id);
        req.onsuccess = (event) => callback();
        req.onerror = callback;
      });
    },
  deleteFile(dbName, id, callback) {
      IDBStore.getStore(dbName, 'readwrite', (err, store) => {
        if (err) return callback(err);
        var req = store.delete(id);
        req.onsuccess = (event) => callback();
        req.onerror = callback;
      });
    },
  existsFile(dbName, id, callback) {
      IDBStore.getStore(dbName, 'readonly', (err, store) => {
        if (err) return callback(err);
        var req = store.count(id);
        req.onsuccess = (event) => callback(null, event.target.result > 0);
        req.onerror = callback;
      });
    },
  clearStore(dbName, callback) {
      IDBStore.getStore(dbName, 'readwrite', (err, store) => {
        if (err) return callback(err);
        var req = store.clear();
        req.onsuccess = (event) => callback();
        req.onerror = callback;
      });
    },
  };

  
  
  
  
  
  
  var _emscripten_idb_async_load = (db, id, arg, onload, onerror) => {
      ;
      IDBStore.getFile(UTF8ToString(db), UTF8ToString(id), (error, byteArray) => {
        
        callUserCallback(() => {
          if (error) {
            if (onerror) getWasmTableEntry(onerror)(arg);
            return;
          }
          var buffer = _malloc(byteArray.length);
          HEAPU8.set(byteArray, buffer);
          getWasmTableEntry(onload)(arg, buffer, byteArray.length);
          _free(buffer);
        });
      });
    };
  _emscripten_idb_async_load.sig = 'vppppp';

  
  
  
  
  
  var _emscripten_idb_async_store = (db, id, ptr, num, arg, onstore, onerror) => {
      // note that we copy the data here, as these are async operatins - changes
      // to HEAPU8 meanwhile should not affect us!
      ;
      IDBStore.setFile(UTF8ToString(db), UTF8ToString(id), new Uint8Array(HEAPU8.subarray(ptr, ptr+num)), (error) => {
        
        callUserCallback(() => {
          if (error) {
            if (onerror) getWasmTableEntry(onerror)(arg);
            return;
          }
          if (onstore) getWasmTableEntry(onstore)(arg);
        });
      });
    };
  _emscripten_idb_async_store.sig = 'vpppippp';

  
  
  
  
  var _emscripten_idb_async_delete = (db, id, arg, ondelete, onerror) => {
      ;
      IDBStore.deleteFile(UTF8ToString(db), UTF8ToString(id), (error) => {
        
        callUserCallback(() => {
          if (error) {
            if (onerror) getWasmTableEntry(onerror)(arg);
            return;
          }
          if (ondelete) getWasmTableEntry(ondelete)(arg);
        });
      });
    };
  _emscripten_idb_async_delete.sig = 'vppppp';

  
  
  
  
  var _emscripten_idb_async_exists = (db, id, arg, oncheck, onerror) => {
      ;
      IDBStore.existsFile(UTF8ToString(db), UTF8ToString(id), (error, exists) => {
        
        callUserCallback(() => {
          if (error) {
            if (onerror) getWasmTableEntry(onerror)(arg);
            return;
          }
          if (oncheck) getWasmTableEntry(oncheck)(arg, exists);
        });
      });
    };
  _emscripten_idb_async_exists.sig = 'vppppp';

  
  
  
  
  var _emscripten_idb_async_clear = (db, arg, onclear, onerror) => {
      ;
      IDBStore.clearStore(UTF8ToString(db), (error) => {
        
        callUserCallback(() => {
          if (error) {
            if (onerror) getWasmTableEntry(onerror)(arg);
            return;
          }
          if (onclear) getWasmTableEntry(onclear)(arg);
        });
      });
    };
  _emscripten_idb_async_clear.sig = 'vpppp';

  var _emscripten_idb_load = (db, id, pbuffer, pnum, perror) => {
      throw 'Please compile your program with async support in order to use synchronous operations like emscripten_idb_load, etc.';
    };
  _emscripten_idb_load.sig = 'vppppp';

  var _emscripten_idb_store = (db, id, ptr, num, perror) => {
      throw 'Please compile your program with async support in order to use synchronous operations like emscripten_idb_store, etc.';
    };
  _emscripten_idb_store.sig = 'vpppip';

  var _emscripten_idb_delete = (db, id, perror) => {
      throw 'Please compile your program with async support in order to use synchronous operations like emscripten_idb_delete, etc.';
    };
  _emscripten_idb_delete.sig = 'vppp';

  var _emscripten_idb_exists = (db, id, pexists, perror) => {
      throw 'Please compile your program with async support in order to use synchronous operations like emscripten_idb_exists, etc.';
    };
  _emscripten_idb_exists.sig = 'vpppp';

  var _emscripten_idb_clear = (db, perror) => {
      throw 'Please compile your program with async support in order to use synchronous operations like emscripten_idb_clear, etc.';
    };
  _emscripten_idb_clear.sig = 'vpp';

  var runAndAbortIfError = (func) => {
      try {
        return func();
      } catch (e) {
        abort(e);
      }
    };


  var _emscripten_wget = (url, file) => {
      throw 'Please compile your program with async support in order to use asynchronous operations like emscripten_wget';
    };
  Module['_emscripten_wget'] = _emscripten_wget;
  _emscripten_wget.sig = 'ipp';


  var _emscripten_scan_registers = (func) => {
      throw 'Please compile your program with async support in order to use asynchronous operations like emscripten_scan_registers';
    };
  _emscripten_scan_registers.sig = 'vp';

  var _emscripten_fiber_swap = (oldFiber, newFiber) => {
      throw 'Please compile your program with async support in order to use asynchronous operations like emscripten_fiber_swap';
    };
  _emscripten_fiber_swap.sig = 'vpp';

  
  
  var _SDL_GetTicks = () => (Date.now() - SDL.startTime)|0;
  _SDL_GetTicks.sig = 'i';
  
  var _SDL_LockSurface = (surf) => {
      var surfData = SDL.surfaces[surf];
  
      surfData.locked++;
      if (surfData.locked > 1) return 0;
  
      if (!surfData.buffer) {
        surfData.buffer = _malloc(surfData.width * surfData.height * 4);
        HEAPU32[(((surf)+(20))>>2)] = surfData.buffer;
      }
  
      // Mark in C/C++-accessible SDL structure
      // SDL_Surface has the following fields: Uint32 flags, SDL_PixelFormat *format; int w, h; Uint16 pitch; void *pixels; ...
      // So we have fields all of the same size, and 5 of them before us.
      // TODO: Use macros like in library.js
      HEAPU32[(((surf)+(20))>>2)] = surfData.buffer;
  
      if (surf == SDL.screen && Module.screenIsReadOnly && surfData.image) return 0;
  
      if (SDL.defaults.discardOnLock) {
        if (!surfData.image) {
          surfData.image = surfData.ctx.createImageData(surfData.width, surfData.height);
        }
        if (!SDL.defaults.opaqueFrontBuffer) return;
      } else {
        surfData.image = surfData.ctx.getImageData(0, 0, surfData.width, surfData.height);
      }
  
      // Emulate desktop behavior and kill alpha values on the locked surface. (very costly!) Set SDL.defaults.opaqueFrontBuffer = false
      // if you don't want this.
      if (surf == SDL.screen && SDL.defaults.opaqueFrontBuffer) {
        var data = surfData.image.data;
        var num = data.length;
        for (var i = 0; i < num/4; i++) {
          data[i*4+3] = 255; // opacity, as canvases blend alpha
        }
      }
  
      if (SDL.defaults.copyOnLock && !SDL.defaults.discardOnLock) {
        // Copy pixel data to somewhere accessible to 'C/C++'
        if (surfData.isFlagSet(2097152)) {
          // If this is needed then
          // we should compact the data from 32bpp to 8bpp index.
          // I think best way to implement this is use
          // additional colorMap hash (color->index).
          // Something like this:
          //
          // var size = surfData.width * surfData.height;
          // var data = '';
          // for (var i = 0; i<size; i++) {
          //   var color = SDL.translateRGBAToColor(
          //     surfData.image.data[i*4   ],
          //     surfData.image.data[i*4 +1],
          //     surfData.image.data[i*4 +2],
          //     255);
          //   var index = surfData.colorMap[color];
          //   HEAP8[(surfData.buffer)+(i)] = index;
          // }
          throw 'CopyOnLock is not supported for SDL_LockSurface with SDL_HWPALETTE flag set' + new Error().stack;
        } else {
          HEAPU8.set(surfData.image.data, surfData.buffer);
        }
      }
  
      return 0;
    };
  _SDL_LockSurface.sig = 'ip';
  
  
  
  
  
  
  var SDL = {
  defaults:{
  width:320,
  height:200,
  copyOnLock:true,
  discardOnLock:false,
  opaqueFrontBuffer:true,
  },
  version:null,
  surfaces:{
  },
  canvasPool:[],
  events:[],
  fonts:[null],
  audios:[null],
  rwops:[null],
  music:{
  audio:null,
  volume:1,
  },
  mixerFrequency:22050,
  mixerFormat:32784,
  mixerNumChannels:2,
  mixerChunkSize:1024,
  channelMinimumNumber:0,
  GL:false,
  glAttributes:{
  0:3,
  1:3,
  2:2,
  3:0,
  4:0,
  5:1,
  6:16,
  7:0,
  8:0,
  9:0,
  10:0,
  11:0,
  12:0,
  13:0,
  14:0,
  15:1,
  16:0,
  17:0,
  18:0,
  },
  keyboardState:null,
  keyboardMap:{
  },
  canRequestFullscreen:false,
  isRequestingFullscreen:false,
  textInput:false,
  unicode:false,
  ttfContext:null,
  audio:null,
  startTime:null,
  initFlags:0,
  buttonState:0,
  modState:0,
  DOMButtons:[0,0,0],
  DOMEventToSDLEvent:{
  },
  TOUCH_DEFAULT_ID:0,
  eventHandler:null,
  eventHandlerContext:null,
  eventHandlerTemp:0,
  keyCodes:{
  16:1249,
  17:1248,
  18:1250,
  20:1081,
  33:1099,
  34:1102,
  35:1101,
  36:1098,
  37:1104,
  38:1106,
  39:1103,
  40:1105,
  44:316,
  45:1097,
  46:127,
  91:1251,
  93:1125,
  96:1122,
  97:1113,
  98:1114,
  99:1115,
  100:1116,
  101:1117,
  102:1118,
  103:1119,
  104:1120,
  105:1121,
  106:1109,
  107:1111,
  109:1110,
  110:1123,
  111:1108,
  112:1082,
  113:1083,
  114:1084,
  115:1085,
  116:1086,
  117:1087,
  118:1088,
  119:1089,
  120:1090,
  121:1091,
  122:1092,
  123:1093,
  124:1128,
  125:1129,
  126:1130,
  127:1131,
  128:1132,
  129:1133,
  130:1134,
  131:1135,
  132:1136,
  133:1137,
  134:1138,
  135:1139,
  144:1107,
  160:94,
  161:33,
  162:34,
  163:35,
  164:36,
  165:37,
  166:38,
  167:95,
  168:40,
  169:41,
  170:42,
  171:43,
  172:124,
  173:45,
  174:123,
  175:125,
  176:126,
  181:127,
  182:129,
  183:128,
  188:44,
  190:46,
  191:47,
  192:96,
  219:91,
  220:92,
  221:93,
  222:39,
  224:1251,
  },
  scanCodes:{
  8:42,
  9:43,
  13:40,
  27:41,
  32:44,
  35:204,
  39:53,
  44:54,
  46:55,
  47:56,
  48:39,
  49:30,
  50:31,
  51:32,
  52:33,
  53:34,
  54:35,
  55:36,
  56:37,
  57:38,
  58:203,
  59:51,
  61:46,
  91:47,
  92:49,
  93:48,
  96:52,
  97:4,
  98:5,
  99:6,
  100:7,
  101:8,
  102:9,
  103:10,
  104:11,
  105:12,
  106:13,
  107:14,
  108:15,
  109:16,
  110:17,
  111:18,
  112:19,
  113:20,
  114:21,
  115:22,
  116:23,
  117:24,
  118:25,
  119:26,
  120:27,
  121:28,
  122:29,
  127:76,
  305:224,
  308:226,
  316:70,
  },
  loadRect(rect) {
        return {
          x: HEAP32[((rect)>>2)],
          y: HEAP32[(((rect)+(4))>>2)],
          w: HEAP32[(((rect)+(8))>>2)],
          h: HEAP32[(((rect)+(12))>>2)]
        };
      },
  updateRect(rect, r) {
        HEAP32[((rect)>>2)] = r.x;
        HEAP32[(((rect)+(4))>>2)] = r.y;
        HEAP32[(((rect)+(8))>>2)] = r.w;
        HEAP32[(((rect)+(12))>>2)] = r.h;
      },
  intersectionOfRects(first, second) {
        var leftX = Math.max(first.x, second.x);
        var leftY = Math.max(first.y, second.y);
        var rightX = Math.min(first.x + first.w, second.x + second.w);
        var rightY = Math.min(first.y + first.h, second.y + second.h);
  
        return {
          x: leftX,
          y: leftY,
          w: Math.max(leftX, rightX) - leftX,
          h: Math.max(leftY, rightY) - leftY
        }
      },
  checkPixelFormat(fmt) {
      },
  loadColorToCSSRGB(color) {
        var rgba = HEAP32[((color)>>2)];
        return 'rgb(' + (rgba&255) + ',' + ((rgba >> 8)&255) + ',' + ((rgba >> 16)&255) + ')';
      },
  loadColorToCSSRGBA(color) {
        var rgba = HEAP32[((color)>>2)];
        return 'rgba(' + (rgba&255) + ',' + ((rgba >> 8)&255) + ',' + ((rgba >> 16)&255) + ',' + (((rgba >> 24)&255)/255) + ')';
      },
  translateColorToCSSRGBA:(rgba) =>
        'rgba(' + (rgba&0xff) + ',' + (rgba>>8 & 0xff) + ',' + (rgba>>16 & 0xff) + ',' + (rgba>>>24)/0xff + ')',
  translateRGBAToCSSRGBA:(r, g, b, a) =>
        'rgba(' + (r&0xff) + ',' + (g&0xff) + ',' + (b&0xff) + ',' + (a&0xff)/255 + ')',
  translateRGBAToColor:(r, g, b, a) => r | g << 8 | b << 16 | a << 24,
  makeSurface(width, height, flags, usePageCanvas, source, rmask, gmask, bmask, amask) {
        var is_SDL_HWSURFACE = flags & 134217729;
        var is_SDL_HWPALETTE = flags & 2097152;
        var is_SDL_OPENGL = flags & 67108864;
  
        var surf = _malloc(60);
        var pixelFormat = _malloc(44);
        // surface with SDL_HWPALETTE flag is 8bpp surface (1 byte)
        var bpp = is_SDL_HWPALETTE ? 1 : 4;
        var buffer = 0;
  
        // preemptively initialize this for software surfaces,
        // otherwise it will be lazily initialized inside of SDL_LockSurface
        if (!is_SDL_HWSURFACE && !is_SDL_OPENGL) {
          buffer = _malloc(width * height * 4);
        }
  
        HEAP32[((surf)>>2)] = flags;
        HEAPU32[(((surf)+(4))>>2)] = pixelFormat;
        HEAP32[(((surf)+(8))>>2)] = width;
        HEAP32[(((surf)+(12))>>2)] = height;
        HEAP32[(((surf)+(16))>>2)] = width * bpp;  // assuming RGBA or indexed for now,
                                                                                          // since that is what ImageData gives us in browsers
        HEAPU32[(((surf)+(20))>>2)] = buffer;
  
        HEAP32[(((surf)+(36))>>2)] = 0;
        HEAP32[(((surf)+(40))>>2)] = 0;
        HEAP32[(((surf)+(44))>>2)] = Module["canvas"].width;
        HEAP32[(((surf)+(48))>>2)] = Module["canvas"].height;
  
        HEAP32[(((surf)+(56))>>2)] = 1;
  
        HEAP32[((pixelFormat)>>2)] = -2042224636;
        HEAP32[(((pixelFormat)+(4))>>2)] = 0;// TODO
        HEAP8[(pixelFormat)+(8)] = bpp * 8;
        HEAP8[(pixelFormat)+(9)] = bpp;
  
        HEAP32[(((pixelFormat)+(12))>>2)] = rmask || 0x000000ff;
        HEAP32[(((pixelFormat)+(16))>>2)] = gmask || 0x0000ff00;
        HEAP32[(((pixelFormat)+(20))>>2)] = bmask || 0x00ff0000;
        HEAP32[(((pixelFormat)+(24))>>2)] = amask || 0xff000000;
  
        // Decide if we want to use WebGL or not
        SDL.GL = SDL.GL || is_SDL_OPENGL;
        var canvas;
        if (!usePageCanvas) {
          if (SDL.canvasPool.length > 0) {
            canvas = SDL.canvasPool.pop();
          } else {
            canvas = document.createElement('canvas');
          }
          canvas.width = width;
          canvas.height = height;
        } else {
          canvas = Module['canvas'];
        }
  
        var webGLContextAttributes = {
          antialias: ((SDL.glAttributes[13] != 0) && (SDL.glAttributes[14] > 1)),
          depth: (SDL.glAttributes[6] > 0),
          stencil: (SDL.glAttributes[7] > 0),
          alpha: (SDL.glAttributes[3] > 0)
        };
  
        var ctx = Browser.createContext(canvas, is_SDL_OPENGL, usePageCanvas, webGLContextAttributes);
  
        SDL.surfaces[surf] = {
          width,
          height,
          canvas,
          ctx,
          surf,
          buffer,
          pixelFormat,
          alpha: 255,
          flags,
          locked: 0,
          usePageCanvas,
          source,
  
          isFlagSet: (flag) => flags & flag
        };
  
        return surf;
      },
  copyIndexedColorData(surfData, rX, rY, rW, rH) {
        // HWPALETTE works with palette
        // set by SDL_SetColors
        if (!surfData.colors) {
          return;
        }
  
        var fullWidth  = Module['canvas'].width;
        var fullHeight = Module['canvas'].height;
  
        var startX  = rX || 0;
        var startY  = rY || 0;
        var endX    = (rW || (fullWidth - startX)) + startX;
        var endY    = (rH || (fullHeight - startY)) + startY;
  
        var buffer  = surfData.buffer;
  
        if (!surfData.image.data32) {
          surfData.image.data32 = new Uint32Array(surfData.image.data.buffer);
        }
        var data32   = surfData.image.data32;
  
        var colors32 = surfData.colors32;
  
        for (var y = startY; y < endY; ++y) {
          var base = y * fullWidth;
          for (var x = startX; x < endX; ++x) {
            data32[base + x] = colors32[HEAPU8[(buffer)+(base + x)]];
          }
        }
      },
  freeSurface(surf) {
        var refcountPointer = surf + 56;
        var refcount = HEAP32[((refcountPointer)>>2)];
        if (refcount > 1) {
          HEAP32[((refcountPointer)>>2)] = refcount - 1;
          return;
        }
  
        var info = SDL.surfaces[surf];
        if (!info.usePageCanvas && info.canvas) SDL.canvasPool.push(info.canvas);
        if (info.buffer) _free(info.buffer);
        _free(info.pixelFormat);
        _free(surf);
        SDL.surfaces[surf] = null;
  
        if (surf === SDL.screen) {
          SDL.screen = null;
        }
      },
  blitSurface(src, srcrect, dst, dstrect, scale) {
        var srcData = SDL.surfaces[src];
        var dstData = SDL.surfaces[dst];
        var sr, dr;
        if (srcrect) {
          sr = SDL.loadRect(srcrect);
        } else {
          sr = { x: 0, y: 0, w: srcData.width, h: srcData.height };
        }
        if (dstrect) {
          dr = SDL.loadRect(dstrect);
        } else {
          dr = { x: 0, y: 0, w: srcData.width, h: srcData.height };
        }
        if (dstData.clipRect) {
          var widthScale = (!scale || sr.w === 0) ? 1 : sr.w / dr.w;
          var heightScale = (!scale || sr.h === 0) ? 1 : sr.h / dr.h;
  
          dr = SDL.intersectionOfRects(dstData.clipRect, dr);
  
          sr.w = dr.w * widthScale;
          sr.h = dr.h * heightScale;
  
          if (dstrect) {
            SDL.updateRect(dstrect, dr);
          }
        }
        var blitw, blith;
        if (scale) {
          blitw = dr.w; blith = dr.h;
        } else {
          blitw = sr.w; blith = sr.h;
        }
        if (sr.w === 0 || sr.h === 0 || blitw === 0 || blith === 0) {
          return 0;
        }
        var oldAlpha = dstData.ctx.globalAlpha;
        dstData.ctx.globalAlpha = srcData.alpha/255;
        dstData.ctx.drawImage(srcData.canvas, sr.x, sr.y, sr.w, sr.h, dr.x, dr.y, blitw, blith);
        dstData.ctx.globalAlpha = oldAlpha;
        if (dst != SDL.screen) {
          // XXX As in IMG_Load, for compatibility we write out |pixels|
          warnOnce('WARNING: copying canvas data to memory for compatibility');
          _SDL_LockSurface(dst);
          dstData.locked--; // The surface is not actually locked in this hack
        }
        return 0;
      },
  downFingers:{
  },
  savedKeydown:null,
  receiveEvent(event) {
        function unpressAllPressedKeys() {
          // Un-press all pressed keys: TODO
          for (var keyCode of Object.values(SDL.keyboardMap)) {
            SDL.events.push({
              type: 'keyup',
              keyCode,
            });
          }
        };
        switch (event.type) {
          case 'touchstart':
          case 'touchmove': {
            event.preventDefault();
  
            var touches = [];
  
            // Clear out any touchstart events that we've already processed
            if (event.type === 'touchstart') {
              for (var i = 0; i < event.touches.length; i++) {
                var touch = event.touches[i];
                if (SDL.downFingers[touch.identifier] != true) {
                  SDL.downFingers[touch.identifier] = true;
                  touches.push(touch);
                }
              }
            } else {
              touches = event.touches;
            }
  
            var firstTouch = touches[0];
            if (firstTouch) {
              if (event.type == 'touchstart') {
                SDL.DOMButtons[0] = 1;
              }
              var mouseEventType;
              switch (event.type) {
                case 'touchstart': mouseEventType = 'mousedown'; break;
                case 'touchmove': mouseEventType = 'mousemove'; break;
              }
              var mouseEvent = {
                type: mouseEventType,
                button: 0,
                pageX: firstTouch.clientX,
                pageY: firstTouch.clientY
              };
              SDL.events.push(mouseEvent);
            }
  
            for (var i = 0; i < touches.length; i++) {
              var touch = touches[i];
              SDL.events.push({
                type: event.type,
                touch
              });
            };
            break;
          }
          case 'touchend': {
            event.preventDefault();
  
            // Remove the entry in the SDL.downFingers hash
            // because the finger is no longer down.
            for (var i = 0; i < event.changedTouches.length; i++) {
              var touch = event.changedTouches[i];
              if (SDL.downFingers[touch.identifier] === true) {
                delete SDL.downFingers[touch.identifier];
              }
            }
  
            var mouseEvent = {
              type: 'mouseup',
              button: 0,
              pageX: event.changedTouches[0].clientX,
              pageY: event.changedTouches[0].clientY
            };
            SDL.DOMButtons[0] = 0;
            SDL.events.push(mouseEvent);
  
            for (var i = 0; i < event.changedTouches.length; i++) {
              var touch = event.changedTouches[i];
              SDL.events.push({
                type: 'touchend',
                touch
              });
            };
            break;
          }
          case 'DOMMouseScroll':
          case 'mousewheel':
          case 'wheel':
            // Flip the wheel direction to translate from browser wheel direction
            // (+:down) to SDL direction (+:up)
            var delta = -Browser.getMouseWheelDelta(event);
            // Quantize to integer so that minimum scroll is at least +/- 1.
            delta = (delta == 0) ? 0 : (delta > 0 ? Math.max(delta, 1) : Math.min(delta, -1));
  
            // Simulate old-style SDL events representing mouse wheel input as buttons
            // Subtract one since JS->C marshalling is defined to add one back.
            var button = (delta > 0 ? 4 : 5) - 1;
            SDL.events.push({ type: 'mousedown', button, pageX: event.pageX, pageY: event.pageY });
            SDL.events.push({ type: 'mouseup', button, pageX: event.pageX, pageY: event.pageY });
  
            // Pass a delta motion event.
            SDL.events.push({ type: 'wheel', deltaX: 0, deltaY: delta });
            // If we don't prevent this, then 'wheel' event will be sent again by
            // the browser as 'DOMMouseScroll' and we will receive this same event
            // the second time.
            event.preventDefault();
            break;
          case 'mousemove':
            if (SDL.DOMButtons[0] === 1) {
              SDL.events.push({
                type: 'touchmove',
                touch: {
                  identifier: 0,
                  deviceID: -1,
                  pageX: event.pageX,
                  pageY: event.pageY
                }
              });
            }
            if (Browser.pointerLock) {
              // workaround for firefox bug 750111
              if ('mozMovementX' in event) {
                event['movementX'] = event['mozMovementX'];
                event['movementY'] = event['mozMovementY'];
              }
              // workaround for Firefox bug 782777
              if (event['movementX'] == 0 && event['movementY'] == 0) {
                // ignore a mousemove event if it doesn't contain any movement info
                // (without pointer lock, we infer movement from pageX/pageY, so this check is unnecessary)
                event.preventDefault();
                return;
              }
            }
            // fall through
          case 'keydown':
          case 'keyup':
          case 'keypress':
          case 'mousedown':
          case 'mouseup':
            // If we preventDefault on keydown events, the subsequent keypress events
            // won't fire. However, it's fine (and in some cases necessary) to
            // preventDefault for keys that don't generate a character. Otherwise,
            // preventDefault is the right thing to do in general.
            if (event.type !== 'keydown' || (!SDL.unicode && !SDL.textInput) || (event.key == 'Backspace' || event.key == 'Tab')) {
              event.preventDefault();
            }
  
            if (event.type == 'mousedown') {
              SDL.DOMButtons[event.button] = 1;
              SDL.events.push({
                type: 'touchstart',
                touch: {
                  identifier: 0,
                  deviceID: -1,
                  pageX: event.pageX,
                  pageY: event.pageY
                }
              });
            } else if (event.type == 'mouseup') {
              // ignore extra ups, can happen if we leave the canvas while pressing down, then return,
              // since we add a mouseup in that case
              if (!SDL.DOMButtons[event.button]) {
                return;
              }
  
              SDL.events.push({
                type: 'touchend',
                touch: {
                  identifier: 0,
                  deviceID: -1,
                  pageX: event.pageX,
                  pageY: event.pageY
                }
              });
              SDL.DOMButtons[event.button] = 0;
            }
  
            // We can only request fullscreen as the result of user input.
            // Due to this limitation, we toggle a boolean on keydown which
            // SDL_WM_ToggleFullScreen will check and subsequently set another
            // flag indicating for us to request fullscreen on the following
            // keyup. This isn't perfect, but it enables SDL_WM_ToggleFullScreen
            // to work as the result of a keypress (which is an extremely
            // common use case).
            if (event.type === 'keydown' || event.type === 'mousedown') {
              SDL.canRequestFullscreen = true;
            } else if (event.type === 'keyup' || event.type === 'mouseup') {
              if (SDL.isRequestingFullscreen) {
                Module['requestFullscreen'](/*lockPointer=*/true, /*resizeCanvas=*/true);
                SDL.isRequestingFullscreen = false;
              }
              SDL.canRequestFullscreen = false;
            }
  
            // SDL expects a unicode character to be passed to its keydown events.
            // Unfortunately, the browser APIs only provide a charCode property on
            // keypress events, so we must backfill in keydown events with their
            // subsequent keypress event's charCode.
            if (event.type === 'keypress' && SDL.savedKeydown) {
              // charCode is read-only
              SDL.savedKeydown.keypressCharCode = event.charCode;
              SDL.savedKeydown = null;
            } else if (event.type === 'keydown') {
              SDL.savedKeydown = event;
            }
  
            // Don't push keypress events unless SDL_StartTextInput has been called.
            if (event.type !== 'keypress' || SDL.textInput) {
              SDL.events.push(event);
            }
            break;
          case 'mouseout':
            // Un-press all pressed mouse buttons, because we might miss the release outside of the canvas
            for (var i = 0; i < 3; i++) {
              if (SDL.DOMButtons[i]) {
                SDL.events.push({
                  type: 'mouseup',
                  button: i,
                  pageX: event.pageX,
                  pageY: event.pageY
                });
                SDL.DOMButtons[i] = 0;
              }
            }
            event.preventDefault();
            break;
          case 'focus':
            SDL.events.push(event);
            event.preventDefault();
            break;
          case 'blur':
            SDL.events.push(event);
            unpressAllPressedKeys();
            event.preventDefault();
            break;
          case 'visibilitychange':
            SDL.events.push({
              type: 'visibilitychange',
              visible: !document.hidden
            });
            unpressAllPressedKeys();
            event.preventDefault();
            break;
          case 'unload':
            if (MainLoop.runner) {
              SDL.events.push(event);
              // Force-run a main event loop, since otherwise this event will never be caught!
              MainLoop.runner();
            }
            return;
          case 'resize':
            SDL.events.push(event);
            // manually triggered resize event doesn't have a preventDefault member
            if (event.preventDefault) {
              event.preventDefault();
            }
            break;
        }
        if (SDL.events.length >= 10000) {
          err('SDL event queue full, dropping events');
          SDL.events = SDL.events.slice(0, 10000);
        }
        // If we have a handler installed, this will push the events to the app
        // instead of the app polling for them.
        SDL.flushEventsToHandler();
        return;
      },
  lookupKeyCodeForEvent(event) {
        var code = event.keyCode;
        if (code >= 65 && code <= 90) { // ASCII A-Z
          code += 32; // make lowercase for SDL
        } else {
          // Look up DOM code in the keyCodes table with fallback for ASCII codes
          // which can match between DOM codes and SDL keycodes (allows keyCodes
          // to be smaller).
          code = SDL.keyCodes[code] || (code < 128 ? code : 0);
          // If this is one of the modifier keys (224 | 1<<10 - 227 | 1<<10), and the event specifies that it is
          // a right key, add 4 to get the right key SDL key code.
          if (event.location === 2 /*KeyboardEvent.DOM_KEY_LOCATION_RIGHT*/ && code >= (224 | 1<<10) && code <= (227 | 1<<10)) {
            code += 4;
          }
        }
        return code;
      },
  handleEvent(event) {
        if (event.handled) return;
        event.handled = true;
  
        switch (event.type) {
          case 'touchstart':
          case 'touchend':
          case 'touchmove': {
            Browser.calculateMouseEvent(event);
            break;
          }
          case 'keydown':
          case 'keyup': {
            var down = event.type === 'keydown';
            var code = SDL.lookupKeyCodeForEvent(event);
            // Ignore key events that we don't (yet) map to SDL keys
            if (!code) return;
            // Assigning a boolean to HEAP8, that's alright but Closure would like to warn about it.
            // TODO(https://github.com/emscripten-core/emscripten/issues/16311):
            // This is kind of ugly hack.  Perhaps we can find a better way?
            /** @suppress{checkTypes} */
            HEAP8[(SDL.keyboardState)+(code)] = down;
            // TODO: lmeta, rmeta, numlock, capslock, KMOD_MODE, KMOD_RESERVED
            SDL.modState =
              (HEAP8[(SDL.keyboardState)+(1248)] ? 64 : 0) |
              (HEAP8[(SDL.keyboardState)+(1249)] ? 1 : 0) |
              (HEAP8[(SDL.keyboardState)+(1250)] ? 256 : 0) |
              (HEAP8[(SDL.keyboardState)+(1252)] ? 128 : 0) |
              (HEAP8[(SDL.keyboardState)+(1253)] ? 2 : 0) |
              (HEAP8[(SDL.keyboardState)+(1254)] ? 512 : 0);
            if (down) {
              SDL.keyboardMap[code] = event.keyCode; // save the DOM input, which we can use to unpress it during blur
            } else {
              delete SDL.keyboardMap[code];
            }
  
            break;
          }
          case 'mousedown':
          case 'mouseup':
            if (event.type == 'mousedown') {
              // SDL_BUTTON(x) is defined as (1 << ((x)-1)).  SDL buttons are 1-3,
              // and DOM buttons are 0-2, so this means that the below formula is
              // correct.
              SDL.buttonState |= 1 << event.button;
            } else if (event.type == 'mouseup') {
              SDL.buttonState &= ~(1 << event.button);
            }
            // fall through
          case 'mousemove': {
            Browser.calculateMouseEvent(event);
            break;
          }
        }
      },
  flushEventsToHandler() {
        if (!SDL.eventHandler) return;
  
        while (SDL.pollEvent(SDL.eventHandlerTemp)) {
          getWasmTableEntry(SDL.eventHandler)(SDL.eventHandlerContext, SDL.eventHandlerTemp);
        }
      },
  pollEvent(ptr) {
        if (SDL.initFlags & 512 && SDL.joystickEventState) {
          // If SDL_INIT_JOYSTICK was supplied AND the joystick system is configured
          // to automatically query for events, query for joystick events.
          SDL.queryJoysticks();
        }
        if (ptr) {
          while (SDL.events.length > 0) {
            if (SDL.makeCEvent(SDL.events.shift(), ptr) !== false) return 1;
          }
          return 0;
        }
        // XXX: somewhat risky in that we do not check if the event is real or not
        // (makeCEvent returns false) if no pointer supplied
        return SDL.events.length > 0;
      },
  makeCEvent(event, ptr) {
        if (typeof event == 'number') {
          // This is a pointer to a copy of a native C event that was SDL_PushEvent'ed
          _memcpy(ptr, event, 28);
          _free(event); // the copy is no longer needed
          return;
        }
  
        SDL.handleEvent(event);
  
        switch (event.type) {
          case 'keydown': case 'keyup': {
            var down = event.type === 'keydown';
            var key = SDL.lookupKeyCodeForEvent(event);
            // Ignore key events that we don't (yet) map to SDL keys
            if (!key) return false;
            var scan;
            if (key >= 1024) {
              scan = key - 1024;
            } else {
              scan = SDL.scanCodes[key] || key;
            }
  
            HEAP32[((ptr)>>2)] = SDL.DOMEventToSDLEvent[event.type];
            HEAP8[(ptr)+(8)] = down ? 1 : 0;
            HEAP8[(ptr)+(9)] = 0; // TODO
            HEAP32[(((ptr)+(12))>>2)] = scan;
            HEAP32[(((ptr)+(16))>>2)] = key;
            HEAP16[(((ptr)+(20))>>1)] = SDL.modState;
            // some non-character keys (e.g. backspace and tab) won't have keypressCharCode set, fill in with the keyCode.
            HEAP32[(((ptr)+(24))>>2)] = event.keypressCharCode || key;
  
            break;
          }
          case 'keypress': {
            HEAP32[((ptr)>>2)] = SDL.DOMEventToSDLEvent[event.type];
            // Not filling in windowID for now
            var cStr = intArrayFromString(String.fromCharCode(event.charCode));
            for (var i = 0; i < cStr.length; ++i) {
              HEAP8[(ptr)+(8 + i)] = cStr[i];
            }
            break;
          }
          case 'mousedown': case 'mouseup': case 'mousemove': {
            if (event.type != 'mousemove') {
              var down = event.type === 'mousedown';
              HEAP32[((ptr)>>2)] = SDL.DOMEventToSDLEvent[event.type];
              HEAP32[(((ptr)+(4))>>2)] = 0;
              HEAP32[(((ptr)+(8))>>2)] = 0;
              HEAP32[(((ptr)+(12))>>2)] = 0;
              HEAP8[(ptr)+(16)] = event.button+1; // DOM buttons are 0-2, SDL 1-3
              HEAP8[(ptr)+(17)] = down ? 1 : 0;
              HEAP32[(((ptr)+(20))>>2)] = Browser.mouseX;
              HEAP32[(((ptr)+(24))>>2)] = Browser.mouseY;
            } else {
              HEAP32[((ptr)>>2)] = SDL.DOMEventToSDLEvent[event.type];
              HEAP32[(((ptr)+(4))>>2)] = 0;
              HEAP32[(((ptr)+(8))>>2)] = 0;
              HEAP32[(((ptr)+(12))>>2)] = 0;
              HEAP32[(((ptr)+(16))>>2)] = SDL.buttonState;
              HEAP32[(((ptr)+(20))>>2)] = Browser.mouseX;
              HEAP32[(((ptr)+(24))>>2)] = Browser.mouseY;
              HEAP32[(((ptr)+(28))>>2)] = Browser.mouseMovementX;
              HEAP32[(((ptr)+(32))>>2)] = Browser.mouseMovementY;
            }
            break;
          }
          case 'wheel': {
            HEAP32[((ptr)>>2)] = SDL.DOMEventToSDLEvent[event.type];
            HEAP32[(((ptr)+(16))>>2)] = event.deltaX;
            HEAP32[(((ptr)+(20))>>2)] = event.deltaY;
            break;
          }
          case 'touchstart': case 'touchend': case 'touchmove': {
            var touch = event.touch;
            if (!Browser.touches[touch.identifier]) break;
            var w = Module['canvas'].width;
            var h = Module['canvas'].height;
            var x = Browser.touches[touch.identifier].x / w;
            var y = Browser.touches[touch.identifier].y / h;
            var lx = Browser.lastTouches[touch.identifier].x / w;
            var ly = Browser.lastTouches[touch.identifier].y / h;
            var dx = x - lx;
            var dy = y - ly;
            if (touch['deviceID'] === undefined) touch.deviceID = SDL.TOUCH_DEFAULT_ID;
            if (dx === 0 && dy === 0 && event.type === 'touchmove') return false; // don't send these if nothing happened
            HEAP32[((ptr)>>2)] = SDL.DOMEventToSDLEvent[event.type];
            HEAP32[(((ptr)+(4))>>2)] = _SDL_GetTicks();
            HEAP64[(((ptr)+(8))>>3)] = BigInt(touch.deviceID);
            HEAP64[(((ptr)+(16))>>3)] = BigInt(touch.identifier);
            HEAPF32[(((ptr)+(24))>>2)] = x;
            HEAPF32[(((ptr)+(28))>>2)] = y;
            HEAPF32[(((ptr)+(32))>>2)] = dx;
            HEAPF32[(((ptr)+(36))>>2)] = dy;
            if (touch.force !== undefined) {
              HEAPF32[(((ptr)+(40))>>2)] = touch.force;
            } else { // No pressure data, send a digital 0/1 pressure.
              HEAPF32[(((ptr)+(40))>>2)] = event.type == "touchend" ? 0 : 1;
            }
            break;
          }
          case 'unload': {
            HEAP32[((ptr)>>2)] = SDL.DOMEventToSDLEvent[event.type];
            break;
          }
          case 'resize': {
            HEAP32[((ptr)>>2)] = SDL.DOMEventToSDLEvent[event.type];
            HEAP32[(((ptr)+(4))>>2)] = event.w;
            HEAP32[(((ptr)+(8))>>2)] = event.h;
            break;
          }
          case 'joystick_button_up': case 'joystick_button_down': {
            var state = event.type === 'joystick_button_up' ? 0 : 1;
            HEAP32[((ptr)>>2)] = SDL.DOMEventToSDLEvent[event.type];
            HEAP8[(ptr)+(4)] = event.index;
            HEAP8[(ptr)+(5)] = event.button;
            HEAP8[(ptr)+(6)] = state;
            break;
          }
          case 'joystick_axis_motion': {
            HEAP32[((ptr)>>2)] = SDL.DOMEventToSDLEvent[event.type];
            HEAP8[(ptr)+(4)] = event.index;
            HEAP8[(ptr)+(5)] = event.axis;
            HEAP32[(((ptr)+(8))>>2)] = SDL.joystickAxisValueConversion(event.value);
            break;
          }
          case 'focus': {
            HEAP32[((ptr)>>2)] = SDL.DOMEventToSDLEvent[event.type];
            HEAP32[(((ptr)+(4))>>2)] = 0;
            HEAP8[(ptr)+(8)] = 12;
            break;
          }
          case 'blur': {
            HEAP32[((ptr)>>2)] = SDL.DOMEventToSDLEvent[event.type];
            HEAP32[(((ptr)+(4))>>2)] = 0;
            HEAP8[(ptr)+(8)] = 13;
            break;
          }
          case 'visibilitychange': {
            var visibilityEventID = event.visible ? 1 : 2;
            HEAP32[((ptr)>>2)] = SDL.DOMEventToSDLEvent[event.type];
            HEAP32[(((ptr)+(4))>>2)] = 0;
            HEAP8[(ptr)+(8)] = visibilityEventID;
            break;
          }
          default: throw 'Unhandled SDL event: ' + event.type;
        }
      },
  makeFontString(height, fontName) {
        if (fontName.charAt(0) != "'" && fontName.charAt(0) != '"') {
          // https://developer.mozilla.org/ru/docs/Web/CSS/font-family
          // Font family names containing whitespace should be quoted.
          // BTW, quote all font names is easier than searching spaces
          fontName = '"' + fontName + '"';
        }
        return height + 'px ' + fontName + ', serif';
      },
  estimateTextWidth(fontData, text) {
        var h = fontData.size;
        var fontString = SDL.makeFontString(h, fontData.name);
        var tempCtx = SDL.ttfContext;
        tempCtx.font = fontString;
        var ret = tempCtx.measureText(text).width | 0;
        return ret;
      },
  allocateChannels(num) { // called from Mix_AllocateChannels and init
        if (SDL.numChannels && SDL.numChannels >= num && num != 0) return;
        SDL.numChannels = num;
        SDL.channels = [];
        for (var i = 0; i < num; i++) {
          SDL.channels[i] = {
            audio: null,
            volume: 1.0
          };
        }
      },
  setGetVolume(info, volume) {
        if (!info) return 0;
        var ret = info.volume * 128; // MIX_MAX_VOLUME
        if (volume != -1) {
          info.volume = Math.min(Math.max(volume, 0), 128) / 128;
          if (info.audio) {
            try {
              info.audio.volume = info.volume; // For <audio> element
              if (info.audio.webAudioGainNode) info.audio.webAudioGainNode['gain']['value'] = info.volume; // For WebAudio playback
            } catch(e) {
              err(`setGetVolume failed to set audio volume: ${e}`);
            }
          }
        }
        return ret;
      },
  setPannerPosition(info, x, y, z) {
        info?.audio?.webAudioPannerNode?.['setPosition'](x, y, z);
      },
  playWebAudio(audio) {
        if (!audio) return;
        if (audio.webAudioNode) return; // This instance is already playing, don't start again.
        if (!SDL.webAudioAvailable()) return;
        try {
          var webAudio = audio.resource.webAudio;
          audio.paused = false;
          if (!webAudio.decodedBuffer) {
            if (webAudio.onDecodeComplete === undefined) {
              abort("Cannot play back audio object that was not loaded");
            }
            webAudio.onDecodeComplete.push(() => { if (!audio.paused) SDL.playWebAudio(audio); });
            return;
          }
          audio.webAudioNode = SDL.audioContext['createBufferSource']();
          audio.webAudioNode['buffer'] = webAudio.decodedBuffer;
          audio.webAudioNode['loop'] = audio.loop;
          audio.webAudioNode['onended'] = audio['onended']; // For <media> element compatibility, route the onended signal to the instance.
  
          audio.webAudioPannerNode = SDL.audioContext['createPanner']();
          // avoid Chrome bug
          // If posz = 0, the sound will come from only the right.
          // By posz = -0.5 (slightly ahead), the sound will come from right and left correctly.
          audio.webAudioPannerNode["setPosition"](0, 0, -.5);
          audio.webAudioPannerNode['panningModel'] = 'equalpower';
  
          // Add an intermediate gain node to control volume.
          audio.webAudioGainNode = SDL.audioContext['createGain']();
          audio.webAudioGainNode['gain']['value'] = audio.volume;
  
          audio.webAudioNode['connect'](audio.webAudioPannerNode);
          audio.webAudioPannerNode['connect'](audio.webAudioGainNode);
          audio.webAudioGainNode['connect'](SDL.audioContext['destination']);
  
          audio.webAudioNode['start'](0, audio.currentPosition);
          audio.startTime = SDL.audioContext['currentTime'] - audio.currentPosition;
        } catch(e) {
          err(`playWebAudio failed: ${e}`);
        }
      },
  pauseWebAudio(audio) {
        if (!audio) return;
        if (audio.webAudioNode) {
          try {
            // Remember where we left off, so that if/when we resume, we can
            // restart the playback at a proper place.
            audio.currentPosition = (SDL.audioContext['currentTime'] - audio.startTime) % audio.resource.webAudio.decodedBuffer.duration;
            // Important: When we reach here, the audio playback is stopped by the
            // user. But when calling .stop() below, the Web Audio graph will send
            // the onended signal, but we don't want to process that, since
            // pausing should not clear/destroy the audio channel.
            audio.webAudioNode['onended'] = undefined;
            audio.webAudioNode.stop(0); // 0 is a default parameter, but WebKit is confused by it #3861
            audio.webAudioNode = undefined;
          } catch(e) {
            err(`pauseWebAudio failed: ${e}`);
          }
        }
        audio.paused = true;
      },
  openAudioContext() {
        // Initialize Web Audio API if we haven't done so yet. Note: Only
        // initialize Web Audio context ever once on the web page, since
        // initializing multiple times fails on Chrome saying 'audio resources
        // have been exhausted'.
        if (!SDL.audioContext) {
          if (typeof AudioContext != 'undefined') {
            SDL.audioContext = new AudioContext();
          } else if (typeof webkitAudioContext != 'undefined') {
            SDL.audioContext = new webkitAudioContext();
          }
        }
      },
  webAudioAvailable:() => !!SDL.audioContext,
  fillWebAudioBufferFromHeap(heapPtr, sizeSamplesPerChannel, dstAudioBuffer) {
        // The input audio data is interleaved across the channels, i.e. [L, R, L,
        // R, L, R, ...] and is either 8-bit, 16-bit or float as supported by the
        // SDL API. The output audio wave data for Web Audio API must be in planar
        // buffers of [-1,1]-normalized Float32 data, so perform a buffer
        // conversion for the data.
        var audio = SDL.audio;
        var numChannels = audio.channels;
        for (var c = 0; c < numChannels; ++c) {
          var channelData = dstAudioBuffer['getChannelData'](c);
          if (channelData.length != sizeSamplesPerChannel) {
            throw 'Web Audio output buffer length mismatch! Destination size: ' + channelData.length + ' samples vs expected ' + sizeSamplesPerChannel + ' samples!';
          }
          if (audio.format == 32784) {
            for (var j = 0; j < sizeSamplesPerChannel; ++j) {
              channelData[j] = (HEAP16[(((heapPtr)+((j*numChannels + c)*2))>>1)]) / 0x8000;
            }
          } else if (audio.format == 8) {
            for (var j = 0; j < sizeSamplesPerChannel; ++j) {
              var v = (HEAP8[(heapPtr)+(j*numChannels + c)]);
              channelData[j] = ((v >= 0) ? v-128 : v+128) /128;
            }
          } else if (audio.format == 33056) {
            for (var j = 0; j < sizeSamplesPerChannel; ++j) {
              channelData[j] = (HEAPF32[(((heapPtr)+((j*numChannels + c)*4))>>2)]);
            }
          } else {
            throw 'Invalid SDL audio format ' + audio.format + '!';
          }
        }
      },
  joystickEventState:1,
  lastJoystickState:{
  },
  joystickNamePool:{
  },
  recordJoystickState(joystick, state) {
        // Standardize button state.
        var buttons = new Array(state.buttons.length);
        for (var i = 0; i < state.buttons.length; i++) {
          buttons[i] = SDL.getJoystickButtonState(state.buttons[i]);
        }
  
        SDL.lastJoystickState[joystick] = {
          buttons,
          axes: state.axes.slice(0),
          timestamp: state.timestamp,
          index: state.index,
          id: state.id
        };
      },
  getJoystickButtonState(button) {
        if (typeof button == 'object') {
          // Current gamepad API editor's draft (Firefox Nightly)
          // https://dvcs.w3.org/hg/gamepad/raw-file/default/gamepad.html#idl-def-GamepadButton
          return button['pressed'];
        }
        // Current gamepad API working draft (Firefox / Chrome Stable)
        // http://www.w3.org/TR/2012/WD-gamepad-20120529/#gamepad-interface
        return button > 0;
      },
  queryJoysticks() {
        for (var joystick in SDL.lastJoystickState) {
          var state = SDL.getGamepad(joystick - 1);
          var prevState = SDL.lastJoystickState[joystick];
          // If joystick was removed, state returns null.
          if (typeof state == 'undefined') return;
          if (state === null) return;
          // Check only if the timestamp has differed.
          // NOTE: Timestamp is not available in Firefox.
          // NOTE: Timestamp is currently not properly set for the GearVR controller
          //       on Samsung Internet: it is always zero.
          if (typeof state.timestamp != 'number' || state.timestamp != prevState.timestamp || !state.timestamp) {
            var i;
            for (i = 0; i < state.buttons.length; i++) {
              var buttonState = SDL.getJoystickButtonState(state.buttons[i]);
              // NOTE: The previous state already has a boolean representation of
              //       its button, so no need to standardize its button state here.
              if (buttonState !== prevState.buttons[i]) {
                // Insert button-press event.
                SDL.events.push({
                  type: buttonState ? 'joystick_button_down' : 'joystick_button_up',
                  joystick,
                  index: joystick - 1,
                  button: i
                });
              }
            }
            for (i = 0; i < state.axes.length; i++) {
              if (state.axes[i] !== prevState.axes[i]) {
                // Insert axes-change event.
                SDL.events.push({
                  type: 'joystick_axis_motion',
                  joystick,
                  index: joystick - 1,
                  axis: i,
                  value: state.axes[i]
                });
              }
            }
  
            SDL.recordJoystickState(joystick, state);
          }
        }
      },
  joystickAxisValueConversion(value) {
        // Make sure value is properly clamped
        value = Math.min(1, Math.max(value, -1));
        // Ensures that 0 is 0, 1 is 32767, and -1 is 32768.
        return Math.ceil(((value+1) * 32767.5) - 32768);
      },
  getGamepads() {
        var fcn = navigator.getGamepads || navigator.webkitGamepads || navigator.mozGamepads || navigator.gamepads || navigator.webkitGetGamepads;
        if (fcn !== undefined) {
          // The function must be applied on the navigator object.
          return fcn.apply(navigator);
        }
        return [];
      },
  getGamepad(deviceIndex) {
        var gamepads = SDL.getGamepads();
        if (gamepads.length > deviceIndex && deviceIndex >= 0) {
          return gamepads[deviceIndex];
        }
        return null;
      },
  };

  var _SDL_Linked_Version = () => {
      if (SDL.version === null) {
        SDL.version = _malloc(3);
        HEAP8[SDL.version] = 1;
        HEAP8[(SDL.version)+(1)] = 3;
        HEAP8[(SDL.version)+(2)] = 0;
      }
      return SDL.version;
    };
  _SDL_Linked_Version.sig = 'p';

  
  
  /** @param{number} initFlags */
  var _SDL_Init = (initFlags) => {
      SDL.startTime = Date.now();
      SDL.initFlags = initFlags;
  
      // capture all key events. we just keep down and up, but also capture press to prevent default actions
      if (!Module['doNotCaptureKeyboard']) {
        var keyboardListeningElement = Module['keyboardListeningElement'] || document;
        keyboardListeningElement.addEventListener("keydown", SDL.receiveEvent);
        keyboardListeningElement.addEventListener("keyup", SDL.receiveEvent);
        keyboardListeningElement.addEventListener("keypress", SDL.receiveEvent);
        window.addEventListener("focus", SDL.receiveEvent);
        window.addEventListener("blur", SDL.receiveEvent);
        document.addEventListener("visibilitychange", SDL.receiveEvent);
      }
  
      window.addEventListener("unload", SDL.receiveEvent);
      SDL.keyboardState = _calloc(0x10000, 1); // Our SDL needs 512, but 64K is safe for older SDLs
      // Initialize this structure carefully for closure
      SDL.DOMEventToSDLEvent['keydown']    = 768;
      SDL.DOMEventToSDLEvent['keyup']      = 769;
      SDL.DOMEventToSDLEvent['keypress']   = 771;
      SDL.DOMEventToSDLEvent['mousedown']  = 1025;
      SDL.DOMEventToSDLEvent['mouseup']    = 1026;
      SDL.DOMEventToSDLEvent['mousemove']  = 1024;
      SDL.DOMEventToSDLEvent['wheel']      = 1027;
      SDL.DOMEventToSDLEvent['touchstart'] = 1792;
      SDL.DOMEventToSDLEvent['touchend']   = 1793;
      SDL.DOMEventToSDLEvent['touchmove']  = 1794;
      SDL.DOMEventToSDLEvent['unload']     = 256;
      SDL.DOMEventToSDLEvent['resize']     = 28673;
      SDL.DOMEventToSDLEvent['visibilitychange'] = 512;
      SDL.DOMEventToSDLEvent['focus']      = 512;
      SDL.DOMEventToSDLEvent['blur']       = 512;
  
      // These are not technically DOM events; the HTML gamepad API is poll-based.
      // However, we define them here, as the rest of the SDL code assumes that
      // all SDL events originate as DOM events.
      SDL.DOMEventToSDLEvent['joystick_axis_motion'] = 1536;
      SDL.DOMEventToSDLEvent['joystick_button_down'] = 1539;
      SDL.DOMEventToSDLEvent['joystick_button_up'] = 1540;
      return 0; // success
    };
  _SDL_Init.sig = 'ii';

  
  var _SDL_WasInit = (flags) => {
      if (SDL.startTime === null) {
        _SDL_Init(0);
      }
      return 1;
    };
  _SDL_WasInit.sig = 'ii';

  
  var _SDL_GetVideoInfo = () => {
      var ret = _calloc(20, 1);
      HEAP32[(((ret)+(12))>>2)] = Module["canvas"].width;
      HEAP32[(((ret)+(16))>>2)] = Module["canvas"].height;
      return ret;
    };
  _SDL_GetVideoInfo.sig = 'p';

  var _SDL_ListModes = (format, flags) => -1;
  _SDL_ListModes.sig = 'ppi';

  var _SDL_VideoModeOK = (width, height, depth, flags) => depth;
  _SDL_VideoModeOK.sig = 'iiiii';

  
  /** @suppress {duplicate } */
  var _SDL_VideoDriverName = (buf, max_size) => {
      if (SDL.startTime === null) {
        return 0; //return NULL
      }
      //driverName - emscripten_sdl_driver
      var driverName = [101, 109, 115, 99, 114, 105, 112, 116, 101,
        110, 95, 115, 100, 108, 95, 100, 114, 105, 118, 101, 114];
  
      var index = 0;
      var size  = driverName.length;
  
      if (max_size <= size) {
        size = max_size - 1; //-1 cause null-terminator
      }
  
      while (index < size) {
          var value = driverName[index];
          HEAP8[(buf)+(index)] = value;
          index++;
      }
  
      HEAP8[(buf)+(index)] = 0;
      return buf;
    };
  _SDL_VideoDriverName.sig = 'ppi';
  var _SDL_AudioDriverName = _SDL_VideoDriverName;
  _SDL_AudioDriverName.sig = 'ppi';


  
  var _SDL_SetVideoMode = (width, height, depth, flags) => {
      ['touchstart', 'touchend', 'touchmove',
       'mousedown', 'mouseup', 'mousemove',
       'mousewheel', 'wheel', 'mouseout',
       'DOMMouseScroll',
      ].forEach((e) => Module['canvas'].addEventListener(e, SDL.receiveEvent, true));
  
      var canvas = Module['canvas'];
  
      // (0,0) means 'use fullscreen' in native; in Emscripten, use the current canvas size.
      if (width == 0 && height == 0) {
        width = canvas.width;
        height = canvas.height;
      }
  
      if (!SDL.addedResizeListener) {
        SDL.addedResizeListener = true;
        Browser.resizeListeners.push((w, h) => {
          if (!SDL.settingVideoMode) {
            SDL.receiveEvent({ type: 'resize', w, h });
          }
        });
      }
  
      SDL.settingVideoMode = true; // SetVideoMode itself should not trigger resize events
      Browser.setCanvasSize(width, height);
      SDL.settingVideoMode = false;
  
      // Free the old surface first if there is one
      if (SDL.screen) {
        SDL.freeSurface(SDL.screen);
        assert(!SDL.screen);
      }
  
      if (SDL.GL) flags = flags | 67108864; // if we are using GL, then later calls to SetVideoMode may not mention GL, but we do need it. Once in GL mode, we never leave it.
  
      SDL.screen = SDL.makeSurface(width, height, flags, true, 'screen');
  
      return SDL.screen;
    };
  _SDL_SetVideoMode.sig = 'piiii';

  var _SDL_GetVideoSurface = () => SDL.screen;
  _SDL_GetVideoSurface.sig = 'p';

  var _SDL_AudioQuit = () => {
      for (var i = 0; i < SDL.numChannels; ++i) {
        var chan = /** @type {{ audio: (HTMLMediaElement|undefined) }} */ (SDL.channels[i]);
        if (chan.audio) {
          chan.audio.pause();
          chan.audio = undefined;
        }
      }
      var audio = /** @type {HTMLMediaElement} */ (SDL.music.audio);
      audio?.pause();
      SDL.music.audio = undefined;
    };
  _SDL_AudioQuit.sig = 'v';

  var _SDL_VideoQuit = () => out('SDL_VideoQuit called (and ignored)');
  _SDL_VideoQuit.sig = 'v';

  var _SDL_QuitSubSystem = (flags) => out('SDL_QuitSubSystem called (and ignored)');
  _SDL_QuitSubSystem.sig = 'vi';

  
  var _SDL_Quit = () => {
      _SDL_AudioQuit();
      out('SDL_Quit called (and ignored)');
    };
  _SDL_Quit.sig = 'v';


  var _SDL_UnlockSurface = (surf) => {
      assert(!SDL.GL); // in GL mode we do not keep around 2D canvases and contexts
  
      var surfData = SDL.surfaces[surf];
  
      if (!surfData.locked || --surfData.locked > 0) {
        return;
      }
  
      // Copy pixel data to image
      if (surfData.isFlagSet(2097152)) {
        SDL.copyIndexedColorData(surfData);
      } else if (!surfData.colors) {
        var data = surfData.image.data;
        var buffer = surfData.buffer;
        assert(buffer % 4 == 0, 'Invalid buffer offset: ' + buffer);
        var src = ((buffer)>>2);
        var dst = 0;
        var isScreen = surf == SDL.screen;
        var num;
        if (typeof CanvasPixelArray != 'undefined' && data instanceof CanvasPixelArray) {
          // IE10/IE11: ImageData objects are backed by the deprecated CanvasPixelArray,
          // not UInt8ClampedArray. These don't have buffers, so we need to revert
          // to copying a byte at a time. We do the undefined check because modern
          // browsers do not define CanvasPixelArray anymore.
          num = data.length;
          while (dst < num) {
            var val = HEAP32[src]; // This is optimized. Instead, we could do HEAP32[(((buffer)+(dst))>>2)];
            data[dst  ] = val & 0xff;
            data[dst+1] = (val >> 8) & 0xff;
            data[dst+2] = (val >> 16) & 0xff;
            data[dst+3] = isScreen ? 0xff : ((val >> 24) & 0xff);
            src++;
            dst += 4;
          }
        } else {
          var data32 = new Uint32Array(data.buffer);
          if (isScreen && SDL.defaults.opaqueFrontBuffer) {
            num = data32.length;
            // logically we need to do
            //      while (dst < num) {
            //          data32[dst++] = HEAP32[src++] | 0xff000000
            //      }
            // the following code is faster though, because
            // .set() is almost free - easily 10x faster due to
            // native memcpy efficiencies, and the remaining loop
            // just stores, not load + store, so it is faster
            data32.set(HEAP32.subarray(src, src + num));
            var data8 = new Uint8Array(data.buffer);
            var i = 3;
            var j = i + 4*num;
            if (num % 8 == 0) {
              // unrolling gives big speedups
              while (i < j) {
                data8[i] = 0xff;
                i = i + 4 | 0;
                data8[i] = 0xff;
                i = i + 4 | 0;
                data8[i] = 0xff;
                i = i + 4 | 0;
                data8[i] = 0xff;
                i = i + 4 | 0;
                data8[i] = 0xff;
                i = i + 4 | 0;
                data8[i] = 0xff;
                i = i + 4 | 0;
                data8[i] = 0xff;
                i = i + 4 | 0;
                data8[i] = 0xff;
                i = i + 4 | 0;
              }
             } else {
              while (i < j) {
                data8[i] = 0xff;
                i = i + 4 | 0;
              }
            }
          } else {
            data32.set(HEAP32.subarray(src, src + data32.length));
          }
        }
      } else {
        var width = Module['canvas'].width;
        var height = Module['canvas'].height;
        var s = surfData.buffer;
        var data = surfData.image.data;
        var colors = surfData.colors; // TODO: optimize using colors32
        for (var y = 0; y < height; y++) {
          var base = y*width*4;
          for (var x = 0; x < width; x++) {
            // See comment above about signs
            var val = HEAPU8[s++] * 4;
            var start = base + x*4;
            data[start]   = colors[val];
            data[start+1] = colors[val+1];
            data[start+2] = colors[val+2];
          }
          s += width*3;
        }
      }
      // Copy to canvas
      surfData.ctx.putImageData(surfData.image, 0, 0);
      // Note that we save the image, so future writes are fast. But, memory is not yet released
    };
  _SDL_UnlockSurface.sig = 'vp';

  var _SDL_Flip = (surf) => {
      // We actually do this in Unlock, since the screen surface has as its canvas
      // backing the page canvas element
    };
  _SDL_Flip.sig = 'ip';

  var _SDL_UpdateRect = (surf, x, y, w, h) => {
      // We actually do the whole screen in Unlock...
    };
  _SDL_UpdateRect.sig = 'vpiiii';

  var _SDL_UpdateRects = (surf, numrects, rects) => {
      // We actually do the whole screen in Unlock...
    };
  _SDL_UpdateRects.sig = 'vpip';

  var _SDL_Delay = (delay) => {
      if (!ENVIRONMENT_IS_WORKER) abort('SDL_Delay called on the main thread! Potential infinite loop, quitting. (consider building with async support like ASYNCIFY)');
      // horrible busy-wait, but in a worker it at least does not block rendering
      var now = Date.now();
      while (Date.now() - now < delay) {}
    };
  _SDL_Delay.sig = 'vi';

  
  
  var _SDL_WM_SetCaption = (title, icon) => {
      if (title) {
        _emscripten_set_window_title(title);
      }
      icon &&= UTF8ToString(icon);
    };
  _SDL_WM_SetCaption.sig = 'vpp';

  var _SDL_EnableKeyRepeat = (delay, interval) => {};
  _SDL_EnableKeyRepeat.sig = 'iii';

  /** @param {number} numKeys */
  var _SDL_GetKeyboardState = (numKeys) => {
      if (numKeys) {
        HEAP32[((numKeys)>>2)] = 65536;
      }
      return SDL.keyboardState;
    };
  _SDL_GetKeyboardState.sig = 'pp';

  
  var _SDL_GetKeyState = () => _SDL_GetKeyboardState(0);

  
  
  var _SDL_GetKeyName = (key) => {
      var name = '';
      /* ASCII A-Z or 0-9 */
      if ((key >= 97 && key <= 122) || (key >= 48 && key <= 57)) {
        name = String.fromCharCode(key);
      }
      var size = lengthBytesUTF8(name) + 1;
      SDL.keyName = _realloc(SDL.keyName, size);
      stringToUTF8(name, SDL.keyName, size);
      return SDL.keyName;
    };
  _SDL_GetKeyName.sig = 'pi';

  var _SDL_GetModState = () => SDL.modState;
  _SDL_GetModState.sig = 'i';

  var _SDL_GetMouseState = (x, y) => {
      if (x) HEAP32[((x)>>2)] = Browser.mouseX;
      if (y) HEAP32[((y)>>2)] = Browser.mouseY;
      return SDL.buttonState;
    };
  _SDL_GetMouseState.sig = 'ipp';

  var _SDL_WarpMouse = (x, y) => {
      return; // TODO: implement this in a non-buggy way. Need to keep relative mouse movements correct after calling this
      /*
      var rect = Module["canvas"].getBoundingClientRect();
      SDL.events.push({
        type: 'mousemove',
        pageX: x + (window.scrollX + rect.left),
        pageY: y + (window.scrollY + rect.top)
      });
      */
    };
  _SDL_WarpMouse.sig = 'vii';

  var _SDL_ShowCursor = (toggle) => {
      switch (toggle) {
        case 0: // SDL_DISABLE
          if (Browser.isFullscreen) { // only try to lock the pointer when in full screen mode
            Module['canvas'].requestPointerLock();
            return 0;
          }
          // else return SDL_ENABLE to indicate the failure
          return 1;
        case 1: // SDL_ENABLE
          Module['canvas'].exitPointerLock();
          return 1;
        case -1: // SDL_QUERY
          return !Browser.pointerLock;
        default:
          err(`SDL_ShowCursor called with unknown toggle parameter value: ${toggle}`);
          break;
      }
    };
  _SDL_ShowCursor.sig = 'ii';

  
  var _SDL_GetError = () => {
      SDL.errorMessage ||= stringToNewUTF8("unknown SDL-emscripten error");
      return SDL.errorMessage;
    };
  _SDL_GetError.sig = 'p';

  var _SDL_SetError = (fmt, varargs) => {};
  _SDL_SetError.sig = 'vpp';

  var _SDL_CreateRGBSurface = (flags, width, height, depth, rmask, gmask, bmask, amask) => SDL.makeSurface(width, height, flags, false, 'CreateRGBSurface', rmask, gmask, bmask, amask);
  _SDL_CreateRGBSurface.sig = 'piiiiiiii';

  var _SDL_CreateRGBSurfaceFrom = (pixels, width, height, depth, pitch, rmask, gmask, bmask, amask) => {
      var surf = SDL.makeSurface(width, height, 0, false, 'CreateRGBSurfaceFrom', rmask, gmask, bmask, amask);
  
      if (depth !== 32) {
        // TODO: Actually fill pixel data to created surface.
        // TODO: Take into account depth and pitch parameters.
        err('TODO: Partially unimplemented SDL_CreateRGBSurfaceFrom called!');
        return surf;
      }
  
      var data = SDL.surfaces[surf];
      var image = data.ctx.createImageData(width, height);
      var pitchOfDst = width * 4;
  
      for (var row = 0; row < height; ++row) {
        var baseOfSrc = row * pitch;
        var baseOfDst = row * pitchOfDst;
  
        for (var col = 0; col < width * 4; ++col) {
          image.data[baseOfDst + col] = HEAPU8[(pixels)+(baseOfDst + col)];
        }
      }
  
      data.ctx.putImageData(image, 0, 0);
  
      return surf;
    };
  _SDL_CreateRGBSurfaceFrom.sig = 'ppiiiiiiii';

  /** @param {number} format @param {number} flags */
  var _SDL_ConvertSurface = (surf, format, flags) => {
      if  (format) {
        SDL.checkPixelFormat(format);
      }
  
      var oldData = SDL.surfaces[surf];
      var ret = SDL.makeSurface(oldData.width, oldData.height, oldData.flags, false, 'copy:' + oldData.source);
      var newData = SDL.surfaces[ret];
  
      newData.ctx.globalCompositeOperation = "copy";
      newData.ctx.drawImage(oldData.canvas, 0, 0);
      newData.ctx.globalCompositeOperation = oldData.ctx.globalCompositeOperation;
      return ret;
    };
  _SDL_ConvertSurface.sig = 'pppi';

  
  var _SDL_DisplayFormatAlpha = (surf) => _SDL_ConvertSurface(surf, 0, 0);
  _SDL_DisplayFormatAlpha.sig = 'pp';

  var _SDL_FreeSurface = (surf) => {
      if (surf) SDL.freeSurface(surf);
    };
  _SDL_FreeSurface.sig = 'vp';

  var _SDL_UpperBlit = (src, srcrect, dst, dstrect) =>
      SDL.blitSurface(src, srcrect, dst, dstrect, false);
  _SDL_UpperBlit.sig = 'ipppp';

  var _SDL_UpperBlitScaled = (src, srcrect, dst, dstrect) =>
      SDL.blitSurface(src, srcrect, dst, dstrect, true);
  _SDL_UpperBlitScaled.sig = 'ipppp';

  
  var _SDL_LowerBlit = _SDL_UpperBlit;
  _SDL_LowerBlit.sig = 'ipppp';

  
  var _SDL_LowerBlitScaled = _SDL_UpperBlitScaled;
  _SDL_LowerBlitScaled.sig = 'ipppp';

  var _SDL_GetClipRect = (surf, rect) => {
      assert(rect);
  
      var surfData = SDL.surfaces[surf];
      var r = surfData.clipRect || { x: 0, y: 0, w: surfData.width, h: surfData.height };
      SDL.updateRect(rect, r);
    };
  _SDL_GetClipRect.sig = 'vpp';

  var _SDL_SetClipRect = (surf, rect) => {
      var surfData = SDL.surfaces[surf];
  
      if (rect) {
        surfData.clipRect = SDL.intersectionOfRects({ x: 0, y: 0, w: surfData.width, h: surfData.height }, SDL.loadRect(rect));
      } else {
        delete surfData.clipRect;
      }
    };
  _SDL_SetClipRect.sig = 'ipp';

  var _SDL_FillRect = (surf, rect, color) => {
      var surfData = SDL.surfaces[surf];
      assert(!surfData.locked); // but we could unlock and re-lock if we must..
  
      if (surfData.isFlagSet(2097152)) {
        //in SDL_HWPALETTE color is index (0..255)
        //so we should translate 1 byte value to
        //32 bit canvas
        color = surfData.colors32[color];
      }
  
      var r = rect ? SDL.loadRect(rect) : { x: 0, y: 0, w: surfData.width, h: surfData.height };
  
      if (surfData.clipRect) {
        r = SDL.intersectionOfRects(surfData.clipRect, r);
  
        if (rect) {
          SDL.updateRect(rect, r);
        }
      }
  
      surfData.ctx.save();
      surfData.ctx.fillStyle = SDL.translateColorToCSSRGBA(color);
      surfData.ctx.fillRect(r.x, r.y, r.w, r.h);
      surfData.ctx.restore();
      return 0;
    };
  _SDL_FillRect.sig = 'ippi';

  var _zoomSurface = (src, x, y, smooth) => {
      var srcData = SDL.surfaces[src];
      var w = srcData.width * x;
      var h = srcData.height * y;
      var ret = SDL.makeSurface(Math.abs(w), Math.abs(h), srcData.flags, false, 'zoomSurface');
      var dstData = SDL.surfaces[ret];
      if (x >= 0 && y >= 0) {
        dstData.ctx.drawImage(srcData.canvas, 0, 0, w, h);
      } else {
        dstData.ctx.save();
        dstData.ctx.scale(x < 0 ? -1 : 1, y < 0 ? -1 : 1);
        dstData.ctx.drawImage(srcData.canvas, w < 0 ? w : 0, h < 0 ? h : 0, Math.abs(w), Math.abs(h));
        // XXX I think this should work according to the spec, but currently
        // fails on FF: dstData.ctx.drawImage(srcData.canvas, 0, 0, w, h);
        dstData.ctx.restore();
      }
      return ret;
    };
  _zoomSurface.sig = 'ppddi';

  
  var _rotozoomSurface = (src, angle, zoom, smooth) => {
      if (angle % 360 === 0) {
        return _zoomSurface(src, zoom, zoom, smooth);
      }
      var srcData = SDL.surfaces[src];
      var w = srcData.width * zoom;
      var h = srcData.height * zoom;
      var diagonal = Math.ceil(Math.sqrt(Math.pow(w, 2) + Math.pow(h, 2)));
      var ret = SDL.makeSurface(diagonal, diagonal, srcData.flags, false, 'rotozoomSurface');
      var dstData = SDL.surfaces[ret];
      dstData.ctx.translate(diagonal / 2, diagonal / 2);
      dstData.ctx.rotate(-angle * Math.PI / 180);
      dstData.ctx.drawImage(srcData.canvas, -w / 2, -h / 2, w, h);
      return ret;
    };
  _rotozoomSurface.sig = 'ppddi';

  var _SDL_SetAlpha = (surf, flag, alpha) => {
      var surfData = SDL.surfaces[surf];
      surfData.alpha = alpha;
  
      if (!(flag & 65536)) { // !SDL_SRCALPHA
        surfData.alpha = 255;
      }
    };
  _SDL_SetAlpha.sig = 'ipii';

  var _SDL_SetColorKey = (surf, flag, key) => {
      // SetColorKey assigns one color to be rendered as transparent. I don't
      // think the canvas API allows for anything like this, and iterating through
      // each pixel to replace that color seems prohibitively expensive.
      warnOnce('SDL_SetColorKey is a no-op for performance reasons');
      return 0;
    };
  _SDL_SetColorKey.sig = 'ipii';


  var _SDL_PollEvent = (ptr) => SDL.pollEvent(ptr);
  _SDL_PollEvent.sig = 'ip';

  var _SDL_PushEvent = (ptr) => {
      var copy = _malloc(28);
      _memcpy(copy, ptr, 28);
      SDL.events.push(copy);
      return 0;
    };
  _SDL_PushEvent.sig = 'ip';

  var _SDL_PeepEvents = (events, requestedEventCount, action, from, to) => {
      switch (action) {
        case 2: { // SDL_GETEVENT
          // We only handle 1 event right now
          assert(requestedEventCount == 1);
  
          var index = 0;
          var retrievedEventCount = 0;
          // this should look through the entire queue until it has filled up the events
          // array
          while (index < SDL.events.length && retrievedEventCount < requestedEventCount) {
            var event = SDL.events[index];
            var type = SDL.DOMEventToSDLEvent[event.type];
            if (from <= type && type <= to) {
              if (SDL.makeCEvent(event, events) === false) {
                index++;
              } else {
                SDL.events.splice(index, 1);
                retrievedEventCount++;
              }
            } else {
              index++;
            }
          }
          return retrievedEventCount;
        }
        default: throw 'SDL_PeepEvents does not yet support that action: ' + action;
      }
    };
  _SDL_PeepEvents.sig = 'ipiiii';

  var _SDL_PumpEvents = () => SDL.events.forEach(SDL.handleEvent);
  _SDL_PumpEvents.sig = 'v';

  var _emscripten_SDL_SetEventHandler = (handler, userdata) => {
      SDL.eventHandler = handler;
      SDL.eventHandlerContext = userdata;
  
      // All SDLEvents take the same amount of memory
      SDL.eventHandlerTemp ||= _malloc(28);
    };
  _emscripten_SDL_SetEventHandler.sig = 'vpp';

  var _SDL_SetColors = (surf, colors, firstColor, nColors) => {
      var surfData = SDL.surfaces[surf];
  
      // we should create colors array
      // only once cause client code
      // often wants to change portion
      // of palette not all palette.
      if (!surfData.colors) {
        var buffer = new ArrayBuffer(256 * 4); // RGBA, A is unused, but faster this way
        surfData.colors = new Uint8Array(buffer);
        surfData.colors32 = new Uint32Array(buffer);
      }
  
      for (var i = 0; i < nColors; ++i) {
        var index = (firstColor + i) * 4;
        surfData.colors[index] = HEAPU8[(colors)+(i*4)];
        surfData.colors[index + 1] = HEAPU8[(colors)+(i*4 + 1)];
        surfData.colors[index + 2] = HEAPU8[(colors)+(i*4 + 2)];
        surfData.colors[index + 3] = 255; // opaque
      }
  
      return 1;
    };
  _SDL_SetColors.sig = 'ippii';

  
  var _SDL_SetPalette = (surf, flags, colors, firstColor, nColors) =>
      _SDL_SetColors(surf, colors, firstColor, nColors);
  _SDL_SetPalette.sig = 'ipipii';

  var _SDL_MapRGB = (fmt, r, g, b) => {
      SDL.checkPixelFormat(fmt);
      // We assume the machine is little-endian.
      return r&0xff|(g&0xff)<<8|(b&0xff)<<16|0xff000000;
    };
  _SDL_MapRGB.sig = 'ipiii';

  var _SDL_MapRGBA = (fmt, r, g, b, a) => {
      SDL.checkPixelFormat(fmt);
      // We assume the machine is little-endian.
      return r&0xff|(g&0xff)<<8|(b&0xff)<<16|(a&0xff)<<24;
    };
  _SDL_MapRGBA.sig = 'ipiiii';

  var _SDL_GetRGB = (pixel, fmt, r, g, b) => {
      SDL.checkPixelFormat(fmt);
      // We assume the machine is little-endian.
      if (r) {
        HEAP8[r] = pixel&0xff;
      }
      if (g) {
        HEAP8[g] = (pixel>>8)&0xff;
      }
      if (b) {
        HEAP8[b] = (pixel>>16)&0xff;
      }
    };
  _SDL_GetRGB.sig = 'vipppp';

  var _SDL_GetRGBA = (pixel, fmt, r, g, b, a) => {
      SDL.checkPixelFormat(fmt);
      // We assume the machine is little-endian.
      if (r) {
        HEAP8[r] = pixel&0xff;
      }
      if (g) {
        HEAP8[g] = (pixel>>8)&0xff;
      }
      if (b) {
        HEAP8[b] = (pixel>>16)&0xff;
      }
      if (a) {
        HEAP8[a] = (pixel>>24)&0xff;
      }
    };
  _SDL_GetRGBA.sig = 'vippppp';

  var _SDL_GetAppState = () => {
      var state = 0;
  
      if (Browser.pointerLock) {
        state |= 1;
      }
      if (document.hasFocus()) {
        state |= 2;
      }
      state |= 4;
  
      return state;
    };
  _SDL_GetAppState.sig = 'i';

  var _SDL_WM_GrabInput = () => {};
  _SDL_WM_GrabInput.sig = 'ii';

  var _SDL_WM_ToggleFullScreen = (surf) => {
      if (Browser.exitFullscreen()) {
        return 1;
      }
      if (!SDL.canRequestFullscreen) {
        return 0;
      }
      SDL.isRequestingFullscreen = true;
      return 1;
    };
  _SDL_WM_ToggleFullScreen.sig = 'ip';

  var _IMG_Init = (flags) => flags;
  _IMG_Init.sig = 'ii';

  
  
  var _SDL_FreeRW = (rwopsID) => {
      SDL.rwops[rwopsID] = null;
      while (SDL.rwops.length > 0 && SDL.rwops[SDL.rwops.length-1] === null) {
        SDL.rwops.pop();
      }
    };
  _SDL_FreeRW.sig = 'vp';
  
  
  
  
  
  
  var _IMG_Load_RW = (rwopsID, freeSrc) => {
      var sp = stackSave();
      try {
        // stb_image integration support
        var cleanup = () => {
          stackRestore(sp);
          if (rwops && freeSrc) _SDL_FreeRW(rwopsID);
        }
        var addCleanup = (func) => {
          var old = cleanup;
          cleanup = () => {
            old();
            func();
          }
        }
        var callStbImage = (func, params) => {
          var x = stackAlloc(4);
          var y = stackAlloc(4);
          var comp = stackAlloc(4);
          var data = Module['_' + func](...params, x, y, comp, 0);
          if (!data) return null;
          addCleanup(() => Module['_stbi_image_free'](data));
          return {
            rawData: true,
            data,
            width: HEAP32[((x)>>2)],
            height: HEAP32[((y)>>2)],
            size: HEAP32[((x)>>2)] * HEAP32[((y)>>2)] * HEAP32[((comp)>>2)],
            bpp: HEAP32[((comp)>>2)]
          };
        };
  
        var rwops = SDL.rwops[rwopsID];
        if (rwops === undefined) {
          return 0;
        }
  
        var raw;
        var filename = rwops.filename;
        if (filename === undefined) {
          warnOnce('Only file names that have been preloaded are supported for IMG_Load_RW. Consider using STB_IMAGE=1 if you want synchronous image decoding (see settings.js), or package files with --use-preload-plugins');
          return 0;
        }
  
        if (!raw) {
          filename = PATH_FS.resolve(filename);
          raw = Browser.preloadedImages[filename];
          if (!raw) {
            if (raw === null) err('Trying to reuse preloaded image, but freePreloadedMediaOnUse is set!');
            warnOnce('Cannot find preloaded image ' + filename);
            warnOnce('Cannot find preloaded image ' + filename + '. Consider using STB_IMAGE=1 if you want synchronous image decoding (see settings.js), or package files with --use-preload-plugins');
            return 0;
          } else if (Module['freePreloadedMediaOnUse']) {
            Browser.preloadedImages[filename] = null;
          }
        }
  
        var surf = SDL.makeSurface(raw.width, raw.height, 0, false, 'load:' + filename);
        var surfData = SDL.surfaces[surf];
        surfData.ctx.globalCompositeOperation = "copy";
        if (!raw.rawData) {
          surfData.ctx.drawImage(raw, 0, 0, raw.width, raw.height, 0, 0, raw.width, raw.height);
        } else {
          var imageData = surfData.ctx.getImageData(0, 0, surfData.width, surfData.height);
          if (raw.bpp == 4) {
            // rgba
            imageData.data.set(HEAPU8.subarray((raw.data), raw.data+raw.size));
          } else if (raw.bpp == 3) {
            // rgb
            var pixels = raw.size/3;
            var data = imageData.data;
            var sourcePtr = raw.data;
            var destPtr = 0;
            for (var i = 0; i < pixels; i++) {
              data[destPtr++] = HEAPU8[sourcePtr++];
              data[destPtr++] = HEAPU8[sourcePtr++];
              data[destPtr++] = HEAPU8[sourcePtr++];
              data[destPtr++] = 255;
            }
          } else if (raw.bpp == 2) {
            // grayscale + alpha
            var pixels = raw.size;
            var data = imageData.data;
            var sourcePtr = raw.data;
            var destPtr = 0;
            for (var i = 0; i < pixels; i++) {
              var gray = HEAPU8[sourcePtr++];
              var alpha = HEAPU8[sourcePtr++];
              data[destPtr++] = gray;
              data[destPtr++] = gray;
              data[destPtr++] = gray;
              data[destPtr++] = alpha;
            }
          } else if (raw.bpp == 1) {
            // grayscale
            var pixels = raw.size;
            var data = imageData.data;
            var sourcePtr = raw.data;
            var destPtr = 0;
            for (var i = 0; i < pixels; i++) {
              var value = HEAPU8[sourcePtr++];
              data[destPtr++] = value;
              data[destPtr++] = value;
              data[destPtr++] = value;
              data[destPtr++] = 255;
            }
          } else {
            err(`cannot handle bpp ${raw.bpp}`);
            return 0;
          }
          surfData.ctx.putImageData(imageData, 0, 0);
        }
        surfData.ctx.globalCompositeOperation = "source-over";
        // XXX SDL does not specify that loaded images must have available pixel data, in fact
        //     there are cases where you just want to blit them, so you just need the hardware
        //     accelerated version. However, code everywhere seems to assume that the pixels
        //     are in fact available, so we retrieve it here. This does add overhead though.
        _SDL_LockSurface(surf);
        surfData.locked--; // The surface is not actually locked in this hack
        if (SDL.GL) {
          // After getting the pixel data, we can free the canvas and context if we do not need to do 2D canvas blitting
          surfData.canvas = surfData.ctx = null;
        }
        return surf;
      } finally {
        cleanup();
      }
    };
  _IMG_Load_RW.sig = 'ppi';

  
  var _SDL_LoadBMP_RW = _IMG_Load_RW;
  _SDL_LoadBMP_RW.sig = 'ppi';

  
  
  /** @param {number} mode */
  var _SDL_RWFromFile = (_name, mode) => {
      var id = SDL.rwops.length; // TODO: recycle ids when they are null
      var filename = UTF8ToString(_name);
      SDL.rwops.push({ filename, mimetype: Browser.getMimetype(filename) });
      return id;
    };
  _SDL_RWFromFile.sig = 'ppp';
  
  var _IMG_Load = (filename) => {
      var rwops = _SDL_RWFromFile(filename, 0);
      var result = _IMG_Load_RW(rwops, 1);
      return result;
    };
  _IMG_Load.sig = 'pp';

  var _IMG_Quit = () => out('IMG_Quit called (and ignored)');
  _IMG_Quit.sig = 'v';

  
  
  
  
  var _SDL_OpenAudio = (desired, obtained) => {
      try {
        SDL.audio = {
          freq: HEAPU32[((desired)>>2)],
          format: HEAPU16[(((desired)+(4))>>1)],
          channels: HEAPU8[(desired)+(6)],
          samples: HEAPU16[(((desired)+(8))>>1)], // Samples in the CB buffer per single sound channel.
          callback: HEAPU32[(((desired)+(16))>>2)],
          userdata: HEAPU32[(((desired)+(20))>>2)],
          paused: true,
          timer: null
        };
        // The .silence field tells the constant sample value that corresponds to the safe un-skewed silence value for the wave data.
        if (SDL.audio.format == 8) {
          SDL.audio.silence = 128; // Audio ranges in [0, 255], so silence is half-way in between.
        } else if (SDL.audio.format == 32784) {
          SDL.audio.silence = 0; // Signed data in range [-32768, 32767], silence is 0.
        } else if (SDL.audio.format == 33056) {
          SDL.audio.silence = 0.0; // Float data in range [-1.0, 1.0], silence is 0.0
        } else {
          throw 'Invalid SDL audio format ' + SDL.audio.format + '!';
        }
        // Round the desired audio frequency up to the next 'common' frequency value.
        // Web Audio API spec states 'An implementation must support sample-rates in at least the range 22050 to 96000.'
        if (SDL.audio.freq <= 0) {
          throw 'Unsupported sound frequency ' + SDL.audio.freq + '!';
        } else if (SDL.audio.freq <= 22050) {
          SDL.audio.freq = 22050; // Take it safe and clamp everything lower than 22kHz to that.
        } else if (SDL.audio.freq <= 32000) {
          SDL.audio.freq = 32000;
        } else if (SDL.audio.freq <= 44100) {
          SDL.audio.freq = 44100;
        } else if (SDL.audio.freq <= 48000) {
          SDL.audio.freq = 48000;
        } else if (SDL.audio.freq <= 96000) {
          SDL.audio.freq = 96000;
        } else {
          throw `Unsupported sound frequency ${SDL.audio.freq}!`;
        }
        if (SDL.audio.channels == 0) {
          SDL.audio.channels = 1; // In SDL both 0 and 1 mean mono.
        } else if (SDL.audio.channels < 0 || SDL.audio.channels > 32) {
          throw `Unsupported number of audio channels for SDL audio: ${SDL.audio.channels}!`;
        } else if (SDL.audio.channels != 1 && SDL.audio.channels != 2) { // Unsure what SDL audio spec supports. Web Audio spec supports up to 32 channels.
          out(`Warning: Using untested number of audio channels ${SDL.audio.channels}`);
        }
        if (SDL.audio.samples < 128 || SDL.audio.samples > 524288 /* arbitrary cap */) {
          throw `Unsupported audio callback buffer size ${SDL.audio.samples}!`;
        } else if ((SDL.audio.samples & (SDL.audio.samples-1)) != 0) {
          throw `Audio callback buffer size ${SDL.audio.samples} must be a power-of-two!`;
        }
  
        var totalSamples = SDL.audio.samples*SDL.audio.channels;
        if (SDL.audio.format == 8) {
          SDL.audio.bytesPerSample = 1;
        } else if (SDL.audio.format == 32784) {
          SDL.audio.bytesPerSample = 2;
        } else if (SDL.audio.format == 33056) {
          SDL.audio.bytesPerSample = 4;
        } else {
          throw `Invalid SDL audio format ${SDL.audio.format}!`;
        }
        SDL.audio.bufferSize = totalSamples*SDL.audio.bytesPerSample;
        // Duration of a single queued buffer in seconds.
        SDL.audio.bufferDurationSecs = SDL.audio.bufferSize / SDL.audio.bytesPerSample / SDL.audio.channels / SDL.audio.freq;
        // Audio samples are played with a constant delay of this many seconds to account for browser and jitter.
        SDL.audio.bufferingDelay = 50 / 1000;
        SDL.audio.buffer = _malloc(SDL.audio.bufferSize);
  
        // To account for jittering in frametimes, always have multiple audio
        // buffers queued up for the audio output device.
        // This helps that we won't starve that easily if a frame takes long to complete.
        SDL.audio.numSimultaneouslyQueuedBuffers = Module['SDL_numSimultaneouslyQueuedBuffers'] || 5;
  
        // Pulls and queues new audio data if appropriate. This function gets
        // "over-called" in both requestAnimationFrames and setTimeouts to ensure
        // that we get the finest granularity possible and as many chances from
        // the browser to fill new audio data. This is because setTimeouts alone
        // have very poor granularity for audio streaming purposes, but also the
        // application might not be using emscripten_set_main_loop to drive the
        // main loop, so we cannot rely on that alone.
        SDL.audio.queueNewAudioData = () => {
          if (!SDL.audio) return;
  
          for (var i = 0; i < SDL.audio.numSimultaneouslyQueuedBuffers; ++i) {
            // Only queue new data if we don't have enough audio data already in queue. Otherwise skip this time slot
            // and wait to queue more in the next time the callback is run.
            var secsUntilNextPlayStart = SDL.audio.nextPlayTime - SDL.audioContext['currentTime'];
            if (secsUntilNextPlayStart >= SDL.audio.bufferingDelay + SDL.audio.bufferDurationSecs*SDL.audio.numSimultaneouslyQueuedBuffers) return;
  
            // Ask SDL audio data from the user code.
            getWasmTableEntry(SDL.audio.callback)(SDL.audio.userdata, SDL.audio.buffer, SDL.audio.bufferSize);
            // And queue it to be played after the currently playing audio stream.
            SDL.audio.pushAudio(SDL.audio.buffer, SDL.audio.bufferSize);
          }
        }
  
        // Create a callback function that will be routinely called to ask more audio data from the user application.
        SDL.audio.caller = () => {
          if (!SDL.audio) return;
  
          --SDL.audio.numAudioTimersPending;
  
          SDL.audio.queueNewAudioData();
  
          // Queue this callback function to be called again later to pull more audio data.
          var secsUntilNextPlayStart = SDL.audio.nextPlayTime - SDL.audioContext['currentTime'];
  
          // Queue the next audio frame push to be performed half-way when the previously queued buffer has finished playing.
          var preemptBufferFeedSecs = SDL.audio.bufferDurationSecs/2.0;
  
          if (SDL.audio.numAudioTimersPending < SDL.audio.numSimultaneouslyQueuedBuffers) {
            ++SDL.audio.numAudioTimersPending;
            SDL.audio.timer = safeSetTimeout(SDL.audio.caller, Math.max(0.0, 1000.0*(secsUntilNextPlayStart-preemptBufferFeedSecs)));
  
            // If we are risking starving, immediately queue an extra buffer.
            if (SDL.audio.numAudioTimersPending < SDL.audio.numSimultaneouslyQueuedBuffers) {
              ++SDL.audio.numAudioTimersPending;
              safeSetTimeout(SDL.audio.caller, 1.0);
            }
          }
        };
  
        SDL.audio.audioOutput = new Audio();
  
        // Initialize Web Audio API if we haven't done so yet. Note: Only initialize Web Audio context ever once on the web page,
        // since initializing multiple times fails on Chrome saying 'audio resources have been exhausted'.
        SDL.openAudioContext();
        if (!SDL.audioContext) throw 'Web Audio API is not available!';
        autoResumeAudioContext(SDL.audioContext);
        SDL.audio.nextPlayTime = 0; // Time in seconds when the next audio block is due to start.
  
        // The pushAudio function with a new audio buffer whenever there is new
        // audio data to schedule to be played back on the device.
        SDL.audio.pushAudio = (ptr, sizeBytes) => {
          try {
            if (SDL.audio.paused) return;
  
            var sizeSamples = sizeBytes / SDL.audio.bytesPerSample; // How many samples fit in the callback buffer?
            var sizeSamplesPerChannel = sizeSamples / SDL.audio.channels; // How many samples per a single channel fit in the cb buffer?
            if (sizeSamplesPerChannel != SDL.audio.samples) {
              throw 'Received mismatching audio buffer size!';
            }
            // Allocate new sound buffer to be played.
            var source = SDL.audioContext['createBufferSource']();
            var soundBuffer = SDL.audioContext['createBuffer'](SDL.audio.channels,sizeSamplesPerChannel,SDL.audio.freq);
            source['connect'](SDL.audioContext['destination']);
  
            SDL.fillWebAudioBufferFromHeap(ptr, sizeSamplesPerChannel, soundBuffer);
            // Workaround https://bugzilla.mozilla.org/show_bug.cgi?id=883675 by setting the buffer only after filling. The order is important here!
            source['buffer'] = soundBuffer;
  
            // Schedule the generated sample buffer to be played out at the correct time right after the previously scheduled
            // sample buffer has finished.
            var curtime = SDL.audioContext['currentTime'];
            // Don't ever start buffer playbacks earlier from current time than a given constant 'SDL.audio.bufferingDelay', since a browser
            // may not be able to mix that audio clip in immediately, and there may be subsequent jitter that might cause the stream to starve.
            var playtime = Math.max(curtime + SDL.audio.bufferingDelay, SDL.audio.nextPlayTime);
            if (typeof source['start'] != 'undefined') {
              source['start'](playtime); // New Web Audio API: sound sources are started with a .start() call.
            } else if (typeof source['noteOn'] != 'undefined') {
              source['noteOn'](playtime); // Support old Web Audio API specification which had the .noteOn() API.
            }
            /*
            // Uncomment to debug SDL buffer feed starves.
            if (SDL.audio.curBufferEnd) {
              var thisBufferStart = Math.round(playtime * SDL.audio.freq);
              if (thisBufferStart != SDL.audio.curBufferEnd) out('SDL starved ' + (thisBufferStart - SDL.audio.curBufferEnd) + ' samples!');
            }
            SDL.audio.curBufferEnd = Math.round(playtime * SDL.audio.freq + sizeSamplesPerChannel);
            */
  
            SDL.audio.nextPlayTime = playtime + SDL.audio.bufferDurationSecs;
          } catch(e) {
            err(`Web Audio API error playing back audio: ${e.toString()}`);
          }
        }
  
        if (obtained) {
          // Report back the initialized audio parameters.
          HEAP32[((obtained)>>2)] = SDL.audio.freq;
          HEAP16[(((obtained)+(4))>>1)] = SDL.audio.format;
          HEAP8[(obtained)+(6)] = SDL.audio.channels;
          HEAP8[(obtained)+(7)] = SDL.audio.silence;
          HEAP16[(((obtained)+(8))>>1)] = SDL.audio.samples;
          HEAPU32[(((obtained)+(16))>>2)] = SDL.audio.callback;
          HEAPU32[(((obtained)+(20))>>2)] = SDL.audio.userdata;
        }
        SDL.allocateChannels(32);
  
      } catch(e) {
        err(`Initializing SDL audio threw an exception: "${e.toString()}"! Continuing without audio`);
        SDL.audio = null;
        SDL.allocateChannels(0);
        if (obtained) {
          HEAP32[((obtained)>>2)] = 0;
          HEAP16[(((obtained)+(4))>>1)] = 0;
          HEAP8[(obtained)+(6)] = 0;
          HEAP8[(obtained)+(7)] = 0;
          HEAP16[(((obtained)+(8))>>1)] = 0;
          HEAPU32[(((obtained)+(16))>>2)] = 0;
          HEAPU32[(((obtained)+(20))>>2)] = 0;
        }
      }
      if (!SDL.audio) {
        return -1;
      }
      return 0;
    };
  _SDL_OpenAudio.sig = 'ipp';

  
  var _SDL_PauseAudio = (pauseOn) => {
      if (!SDL.audio) {
        return;
      }
      if (pauseOn) {
        if (SDL.audio.timer !== undefined) {
          clearTimeout(SDL.audio.timer);
          SDL.audio.numAudioTimersPending = 0;
          SDL.audio.timer = undefined;
        }
      } else if (!SDL.audio.timer) {
        // Start the audio playback timer callback loop.
        SDL.audio.numAudioTimersPending = 1;
        SDL.audio.timer = safeSetTimeout(SDL.audio.caller, 1);
      }
      SDL.audio.paused = pauseOn;
    };
  _SDL_PauseAudio.sig = 'vi';

  
  var _SDL_CloseAudio = () => {
      if (SDL.audio) {
        if (SDL.audio.callbackRemover) {
          SDL.audio.callbackRemover();
          SDL.audio.callbackRemover = null;
        }
        _SDL_PauseAudio(1);
        _free(SDL.audio.buffer);
        SDL.audio = null;
        SDL.allocateChannels(0);
      }
    };
  _SDL_CloseAudio.sig = 'v';

  var _SDL_LockAudio = () => {};
  _SDL_LockAudio.sig = 'v';

  var _SDL_UnlockAudio = () => {};
  _SDL_UnlockAudio.sig = 'v';

  var _SDL_CreateMutex = () => 0;
  _SDL_CreateMutex.sig = 'p';

  var _SDL_mutexP = (mutex) => 0;
  _SDL_mutexP.sig = 'ip';

  var _SDL_mutexV = (mutex) => 0;
  _SDL_mutexV.sig = 'ip';

  var _SDL_DestroyMutex = (mutex) => {};
  _SDL_DestroyMutex.sig = 'vp';

  var _SDL_CreateCond = () => 0;
  _SDL_CreateCond.sig = 'p';

  var _SDL_CondSignal = (cond) => {};
  _SDL_CondSignal.sig = 'ip';

  var _SDL_CondWait = (cond, mutex) => {};
  _SDL_CondWait.sig = 'ipp';

  var _SDL_DestroyCond = (cond) => {};
  _SDL_DestroyCond.sig = 'vp';

  var _SDL_StartTextInput = () => {
      SDL.textInput = true;
    };
  _SDL_StartTextInput.sig = 'v';

  var _SDL_StopTextInput = () => {
      SDL.textInput = false;
    };
  _SDL_StopTextInput.sig = 'v';

  var _Mix_Init = (flags) => {
      if (!flags) return 0;
      return 8; /* MIX_INIT_OGG */
    };
  _Mix_Init.sig = 'ii';

  var _Mix_Quit = () => {};
  _Mix_Quit.sig = 'v';

  
  var _Mix_OpenAudio = (frequency, format, channels, chunksize) => {
      SDL.openAudioContext();
      autoResumeAudioContext(SDL.audioContext);
      SDL.allocateChannels(32);
      // Just record the values for a later call to Mix_QuickLoad_RAW
      SDL.mixerFrequency = frequency;
      SDL.mixerFormat = format;
      SDL.mixerNumChannels = channels;
      SDL.mixerChunkSize = chunksize;
      return 0;
    };
  _Mix_OpenAudio.sig = 'iiiii';

  
  var _Mix_CloseAudio = _SDL_CloseAudio;
  _Mix_CloseAudio.sig = 'v';

  var _Mix_AllocateChannels = (num) => {
      SDL.allocateChannels(num);
      return num;
    };
  _Mix_AllocateChannels.sig = 'ii';

  var _Mix_ChannelFinished = (func) => {
      SDL.channelFinished = func;
    };
  _Mix_ChannelFinished.sig = 'vp';

  var _Mix_Volume = (channel, volume) => {
      if (channel == -1) {
        for (var i = 0; i < SDL.numChannels-1; i++) {
          _Mix_Volume(i, volume);
        }
        return _Mix_Volume(SDL.numChannels-1, volume);
      }
      return SDL.setGetVolume(SDL.channels[channel], volume);
    };
  _Mix_Volume.sig = 'iii';

  var _Mix_SetPanning = (channel, left, right) => {
      // SDL API uses [0-255], while PannerNode has an (x, y, z) position.
  
      // Normalizing.
      left /= 255;
      right /= 255;
  
      // Set the z coordinate a little forward, otherwise there won't be any
      // smooth transition between left and right.
      SDL.setPannerPosition(SDL.channels[channel], right - left, 0, 0.1);
      return 1;
    };
  _Mix_SetPanning.sig = 'iiii';

  
  
  
  /** @param {number} freesrc */
  var _Mix_LoadWAV_RW = (rwopsID, freesrc) => {
      var rwops = SDL.rwops[rwopsID];
  
      if (rwops === undefined)
        return 0;
  
      var filename = '';
      var audio;
      var webAudio;
      var bytes;
  
      if (rwops.filename !== undefined) {
        filename = PATH_FS.resolve(rwops.filename);
        var raw = Browser.preloadedAudios[filename];
        if (!raw) {
          if (raw === null) err('Trying to reuse preloaded audio, but freePreloadedMediaOnUse is set!');
          if (!Module['noAudioDecoding']) warnOnce('Cannot find preloaded audio ' + filename);
  
          // see if we can read the file-contents from the in-memory FS
          try {
            bytes = FS.readFile(filename);
          } catch (e) {
            err(`Couldn't find file for: ${filename}`);
            return 0;
          }
        }
        if (Module['freePreloadedMediaOnUse']) {
          Browser.preloadedAudios[filename] = null;
        }
        audio = raw;
      } else if (rwops.bytes !== undefined) {
        // For Web Audio context buffer decoding, we must make a clone of the
        // audio data, but for <media> element, a view to existing data is
        // sufficient.
        if (SDL.webAudioAvailable()) {
          bytes = HEAPU8.buffer.slice(rwops.bytes, rwops.bytes + rwops.count);
        } else {
          bytes = HEAPU8.subarray(rwops.bytes, rwops.bytes + rwops.count);
        }
      } else {
        return 0;
      }
  
      var arrayBuffer = bytes ? bytes.buffer || bytes : bytes;
  
      // To allow user code to work around browser bugs with audio playback on <audio> elements an Web Audio, enable
      // the user code to hook in a callback to decide on a file basis whether each file should use Web Audio or <audio> for decoding and playback.
      // In particular, see https://bugzilla.mozilla.org/show_bug.cgi?id=654787 and ?id=1012801 for tradeoffs.
      var canPlayWithWebAudio = Module['SDL_canPlayWithWebAudio'] === undefined || Module['SDL_canPlayWithWebAudio'](filename, arrayBuffer);
  
      if (bytes !== undefined && SDL.webAudioAvailable() && canPlayWithWebAudio) {
        audio = undefined;
        webAudio = {
          // The audio decoding process is asynchronous, which gives trouble if user
          // code plays the audio data back immediately after loading. Therefore
          // prepare an array of callback handlers to run when this audio decoding
          // is complete, which will then start the playback (with some delay).
          onDecodeComplete: [], // While this member array exists, decoding hasn't finished yet.
        }
        SDL.audioContext['decodeAudioData'](arrayBuffer, (data) => {
          webAudio.decodedBuffer = data;
          // Call all handlers that were waiting for this decode to finish, and
          // clear the handler list.
          webAudio.onDecodeComplete.forEach((e) => e());
          // Don't allow more callback handlers since audio has finished decoding.
          delete webAudio.onDecodeComplete;
        });
      } else if (audio === undefined && bytes) {
        // Here, we didn't find a preloaded audio but we either were passed a
        // filepath for which we loaded bytes, or we were passed some bytes
        var blob = new Blob([bytes], {type: rwops.mimetype});
        var url = URL.createObjectURL(blob);
        audio = new Audio();
        audio.src = url;
        audio.mozAudioChannelType = 'content'; // bugzilla 910340
      }
  
      var id = SDL.audios.length;
      // Keep the loaded audio in the audio arrays, ready for playback
      SDL.audios.push({
        source: filename,
        audio, // Points to the <audio> element, if loaded
        webAudio // Points to a Web Audio -specific resource object, if loaded
      });
      return id;
    };
  _Mix_LoadWAV_RW.sig = 'ppi';

  
  
  
  var _Mix_LoadWAV = (filename) => {
      var rwops = _SDL_RWFromFile(filename, 0);
      var result = _Mix_LoadWAV_RW(rwops, 0);
      _SDL_FreeRW(rwops);
      return result;
    };
  _Mix_LoadWAV.sig = 'pp';

  var _Mix_QuickLoad_RAW = (mem, len) => {
      var audio;
      var webAudio;
  
      var numSamples = len >> 1; // len is the length in bytes, and the array contains 16-bit PCM values
      var buffer = new Float32Array(numSamples);
      for (var i = 0; i < numSamples; ++i) {
        buffer[i] = (HEAP16[(((mem)+(i*2))>>1)]) / 0x8000; // hardcoded 16-bit audio, signed (TODO: reSign if not ta2?)
      }
  
      if (SDL.webAudioAvailable()) {
        webAudio = { decodedBuffer: buffer };
      } else {
        audio = new Audio();
        audio.mozAudioChannelType = 'content'; // bugzilla 910340
        // Record the number of channels and frequency for later usage
        audio.numChannels = SDL.mixerNumChannels;
        audio.frequency = SDL.mixerFrequency;
        // FIXME: doesn't make sense to keep the audio element in the buffer
      }
  
      var id = SDL.audios.length;
      SDL.audios.push({
        source: '',
        audio,
        webAudio,
        buffer
      });
      return id;
    };
  _Mix_QuickLoad_RAW.sig = 'ppi';

  var _Mix_FreeChunk = (id) => {
      SDL.audios[id] = null;
    };
  _Mix_FreeChunk.sig = 'vp';

  var _Mix_ReserveChannels = (num) => {
      SDL.channelMinimumNumber = num;
    };
  _Mix_ReserveChannels.sig = 'ii';

  
  var _Mix_HaltChannel = (channel) => {
      function halt(channel) {
        var info = /** @type {{ audio: HTMLMediaElement }} */ (SDL.channels[channel]);
        if (info.audio) {
          info.audio.pause();
          info.audio = null;
        }
        if (SDL.channelFinished) {
          getWasmTableEntry(SDL.channelFinished)(channel);
        }
      }
      if (channel != -1) {
        halt(channel);
      } else {
        for (var i = 0; i < SDL.channels.length; ++i) halt(i);
      }
      return 0;
    };
  _Mix_HaltChannel.sig = 'ii';
  
  
  var _Mix_PlayChannelTimed = (channel, id, loops, ticks) => {
      // TODO: handle fixed amount of N loops. Currently loops either 0 or infinite times.
      assert(ticks == -1);
  
      // Get the audio element associated with the ID
      var info = SDL.audios[id];
      if (!info) return -1;
      if (!info.audio && !info.webAudio) return -1;
  
      // If the user asks us to allocate a channel automatically, get the first
      // free one.
      if (channel == -1) {
        for (var i = SDL.channelMinimumNumber; i < SDL.numChannels; i++) {
          if (!SDL.channels[i].audio) {
            channel = i;
            break;
          }
        }
        if (channel == -1) {
          err(`All ${SDL.numChannels}  channels in use!`);
          return -1;
        }
      }
      var channelInfo = SDL.channels[channel];
      var audio;
      if (info.webAudio) {
        // Create an instance of the WebAudio object.
        // Make our instance look similar to the instance of a <media> to make api simple.
        audio = {
          resource: info, // This new object is an instance that refers to this existing resource.
          paused: false,
          currentPosition: 0,
          play() { SDL.playWebAudio(this); },
          pause() { SDL.pauseWebAudio(this); },
        };
      } else {
        // We clone the audio node to utilize the preloaded audio buffer, since
        // the browser has already preloaded the audio file.
        audio = info.audio.cloneNode(true);
        audio.numChannels = info.audio.numChannels;
        audio.frequency = info.audio.frequency;
      }
      audio['onended'] = function() { // TODO: cache these
        if (channelInfo.audio === this || channelInfo.audio.webAudioNode === this) { 
          channelInfo.audio.paused = true; channelInfo.audio = null; 
        }
        if (SDL.channelFinished) getWasmTableEntry(SDL.channelFinished)(channel);
      }
      if (channelInfo.audio) {
        _Mix_HaltChannel(channel);
      }
      channelInfo.audio = audio;
      // TODO: handle N loops. Behavior matches Mix_PlayMusic
      audio.loop = loops != 0;
      audio.volume = channelInfo.volume;
      audio.play();
      return channel;
    };
  _Mix_PlayChannelTimed.sig = 'iipii';

  var _Mix_FadingChannel = (channel) => 0;
  _Mix_FadingChannel.sig = 'ii';


  
  var _Mix_HaltMusic = () => {
      var audio = /** @type {HTMLMediaElement} */ (SDL.music.audio);
      if (audio) {
        audio.src = audio.src; // rewind <media> element
        audio.currentPosition = 0; // rewind Web Audio graph playback.
        audio.pause();
      }
      SDL.music.audio = null;
      if (SDL.hookMusicFinished) {
        getWasmTableEntry(SDL.hookMusicFinished)();
      }
      return 0;
    };
  _Mix_HaltMusic.sig = 'i';
  
  var _Mix_HookMusicFinished = (func) => {
      SDL.hookMusicFinished = func;
      if (SDL.music.audio) { // ensure the callback will be called, if a music is already playing
        SDL.music.audio['onended'] = _Mix_HaltMusic;
      }
    };
  _Mix_HookMusicFinished.sig = 'vp';

  var _Mix_VolumeMusic = (volume) => SDL.setGetVolume(SDL.music, volume);
  _Mix_VolumeMusic.sig = 'ii';

  
  var _Mix_LoadMUS_RW = (filename) => _Mix_LoadWAV_RW(filename, 0);
  _Mix_LoadMUS_RW.sig = 'pp';

  
  
  
  var _Mix_LoadMUS = (filename) => {
      var rwops = _SDL_RWFromFile(filename, 0);
      var result = _Mix_LoadMUS_RW(rwops);
      _SDL_FreeRW(rwops);
      return result;
    };
  _Mix_LoadMUS.sig = 'pp';

  
  var _Mix_FreeMusic = _Mix_FreeChunk;
  _Mix_FreeMusic.sig = 'vp';

  
  var _Mix_PlayMusic = (id, loops) => {
      // Pause old music if it exists.
      if (SDL.music.audio) {
        if (!SDL.music.audio.paused) err(`Music is already playing. ${SDL.music.source}`);
        SDL.music.audio.pause();
      }
      var info = SDL.audios[id];
      var audio;
      if (info.webAudio) { // Play via Web Audio API
        // Create an instance of the WebAudio object.
        audio = {
          resource: info, // This new webAudio object is an instance that refers to this existing resource.
          paused: false,
          currentPosition: 0,
          play() { SDL.playWebAudio(this); },
          pause() { SDL.pauseWebAudio(this); },
        };
      } else if (info.audio) { // Play via the <audio> element
        audio = info.audio;
      }
      audio['onended'] = function() {
        if (SDL.music.audio === this || SDL.music.audio?.webAudioNode === this) {
          _Mix_HaltMusic(); // will send callback
        }
      }
      audio.loop = loops != 0 && loops != 1; // TODO: handle N loops for finite N
      audio.volume = SDL.music.volume;
      SDL.music.audio = audio;
      audio.play();
      return 0;
    };
  _Mix_PlayMusic.sig = 'ipi';

  var _Mix_PauseMusic = () => {
      var audio = /** @type {HTMLMediaElement} */ (SDL.music.audio);
      audio?.pause();
    };
  _Mix_PauseMusic.sig = 'v';

  var _Mix_ResumeMusic = () => {
      var audio = SDL.music.audio;
      audio?.play();
    };
  _Mix_ResumeMusic.sig = 'v';


  
  var _Mix_FadeInMusicPos = _Mix_PlayMusic;
  _Mix_FadeInMusicPos.sig = 'ipiid';

  
  var _Mix_FadeOutMusic = _Mix_HaltMusic;
  _Mix_FadeOutMusic.sig = 'ii';

  var _Mix_PlayingMusic = () => (SDL.music.audio && !SDL.music.audio.paused);
  _Mix_PlayingMusic.sig = 'i';

  var _Mix_Playing = (channel) => {
      if (channel === -1) {
        var count = 0;
        for (var i = 0; i < SDL.channels.length; i++) {
          count += _Mix_Playing(i);
        }
        return count;
      }
      var info = SDL.channels[channel];
      if (info?.audio && !info.audio.paused) {
        return 1;
      }
      return 0;
    };
  _Mix_Playing.sig = 'ii';

  var _Mix_Pause = (channel) => {
      if (channel === -1) {
        for (var i = 0; i<SDL.channels.length;i++) {
          _Mix_Pause(i);
        }
        return;
      }
      /** @type {{ audio: HTMLMediaElement }} */
      var info = SDL.channels[channel];
      if (info?.audio) {
        info.audio.pause();
      } else {
        //err(`Mix_Pause: no sound found for channel: ${channel}`);
      }
    };
  _Mix_Pause.sig = 'vi';

  var _Mix_Paused = (channel) => {
      if (channel === -1) {
        var pausedCount = 0;
        for (var i = 0; i<SDL.channels.length;i++) {
          pausedCount += _Mix_Paused(i);
        }
        return pausedCount;
      }
      var info = SDL.channels[channel];
      return info?.audio?.paused ? 1 : 0;
    };
  _Mix_Paused.sig = 'ii';

  var _Mix_PausedMusic = () => SDL.music.audio?.paused ? 1 : 0;
  _Mix_PausedMusic.sig = 'i';

  var _Mix_Resume = (channel) => {
      if (channel === -1) {
        for (var i = 0; i<SDL.channels.length;i++) {
          _Mix_Resume(i);
        }
        return;
      }
      var info = SDL.channels[channel];
      if (info?.audio) info.audio.play();
    };
  _Mix_Resume.sig = 'vi';

  var _TTF_Init = () => {
      // OffscreenCanvas 2D is faster than Canvas for text operations, so we use
      // it if it's available.
      try {
        var offscreenCanvas = new OffscreenCanvas(0, 0);
        SDL.ttfContext = offscreenCanvas.getContext('2d');
        // Firefox support for OffscreenCanvas is still experimental, and it seems
        // like CI might be creating a context here but one that is not entirely
        // valid. Check that explicitly and fall back to a plain Canvas if we need
        // to. See https://github.com/emscripten-core/emscripten/issues/16242
        if (typeof SDL.ttfContext.measureText != 'function') {
          throw 'bad context';
        }
      } catch (ex) {
        var canvas = /** @type {HTMLCanvasElement} */(document.createElement('canvas'));
        SDL.ttfContext = canvas.getContext('2d');
      }
      return 0;
    };
  _TTF_Init.sig = 'i';

  
  var _TTF_OpenFont = (name, size) => {
      name = PATH.normalize(UTF8ToString(name));
      var id = SDL.fonts.length;
      SDL.fonts.push({
        name, // but we don't actually do anything with it..
        size
      });
      return id;
    };
  _TTF_OpenFont.sig = 'ppi';

  var _TTF_CloseFont = (font) => {
      SDL.fonts[font] = null;
    };
  _TTF_CloseFont.sig = 'vp';

  
  var _TTF_RenderText_Solid = (font, text, color) => {
      // XXX the font and color are ignored
      text = UTF8ToString(text) || ' '; // if given an empty string, still return a valid surface
      var fontData = SDL.fonts[font];
      var w = SDL.estimateTextWidth(fontData, text);
      var h = fontData.size;
      color = SDL.loadColorToCSSRGB(color); // XXX alpha breaks fonts?
      var fontString = SDL.makeFontString(h, fontData.name);
      var surf = SDL.makeSurface(w, h, 0, false, 'text:' + text); // bogus numbers..
      var surfData = SDL.surfaces[surf];
      surfData.ctx.save();
      surfData.ctx.fillStyle = color;
      surfData.ctx.font = fontString;
      // use bottom alignment, because it works
      // same in all browsers, more info here:
      // https://bugzilla.mozilla.org/show_bug.cgi?id=737852
      surfData.ctx.textBaseline = 'bottom';
      surfData.ctx.fillText(text, 0, h|0);
      surfData.ctx.restore();
      return surf;
    };
  _TTF_RenderText_Solid.sig = 'pppp';

  
  var _TTF_RenderText_Blended = _TTF_RenderText_Solid;
  _TTF_RenderText_Blended.sig = 'pppp';

  
  var _TTF_RenderText_Shaded = _TTF_RenderText_Solid;
  _TTF_RenderText_Shaded.sig = 'ppppp';

  
  var _TTF_RenderUTF8_Solid = _TTF_RenderText_Solid;
  _TTF_RenderUTF8_Solid.sig = 'pppp';

  
  
  /** @suppress {duplicate } */
  var _TTF_SizeText = (font, text, w, h) => {
      var fontData = SDL.fonts[font];
      if (w) {
        HEAP32[((w)>>2)] = SDL.estimateTextWidth(fontData, UTF8ToString(text));
      }
      if (h) {
        HEAP32[((h)>>2)] = fontData.size;
      }
      return 0;
    };
  _TTF_SizeText.sig = 'ipppp';
  var _TTF_SizeUTF8 = _TTF_SizeText;
  _TTF_SizeUTF8.sig = 'ipppp';


  var _TTF_GlyphMetrics = (font, ch, minx, maxx, miny, maxy, advance) => {
      var fontData = SDL.fonts[font];
      var width = SDL.estimateTextWidth(fontData,  String.fromCharCode(ch));
  
      if (advance) {
        HEAP32[((advance)>>2)] = width;
      }
      if (minx) {
        HEAP32[((minx)>>2)] = 0;
      }
      if (maxx) {
        HEAP32[((maxx)>>2)] = width;
      }
      if (miny) {
        HEAP32[((miny)>>2)] = 0;
      }
      if (maxy) {
        HEAP32[((maxy)>>2)] = fontData.size;
      }
    };
  _TTF_GlyphMetrics.sig = 'ipippppp';

  var _TTF_FontAscent = (font) => {
      var fontData = SDL.fonts[font];
      return (fontData.size*0.98)|0; // XXX
    };
  _TTF_FontAscent.sig = 'ip';

  var _TTF_FontDescent = (font) => {
      var fontData = SDL.fonts[font];
      return (fontData.size*0.02)|0; // XXX
    };
  _TTF_FontDescent.sig = 'ip';

  var _TTF_FontHeight = (font) => {
      var fontData = SDL.fonts[font];
      return fontData.size;
    };
  _TTF_FontHeight.sig = 'ip';

  
  var _TTF_FontLineSkip = _TTF_FontHeight;
  _TTF_FontLineSkip.sig = 'ip';

  var _TTF_Quit = () => out('TTF_Quit called (and ignored)');
  _TTF_Quit.sig = 'v';

  var SDL_gfx = {
  drawRectangle:(surf, x1, y1, x2, y2, action, cssColor) => {
        x1 = x1 << 16 >> 16;
        y1 = y1 << 16 >> 16;
        x2 = x2 << 16 >> 16;
        y2 = y2 << 16 >> 16;
        var surfData = SDL.surfaces[surf];
        assert(!surfData.locked); // but we could unlock and re-lock if we must..
        // TODO: if ctx does not change, leave as is, and also do not re-set xStyle etc.
        var x = x1 < x2 ? x1 : x2;
        var y = y1 < y2 ? y1 : y2;
        var w = Math.abs(x2 - x1);
        var h = Math.abs(y2 - y1);
        surfData.ctx.save();
        surfData.ctx[action + 'Style'] = cssColor;
        surfData.ctx[action + 'Rect'](x, y, w, h);
        surfData.ctx.restore();
      },
  drawLine:(surf, x1, y1, x2, y2, cssColor) => {
        x1 = x1 << 16 >> 16;
        y1 = y1 << 16 >> 16;
        x2 = x2 << 16 >> 16;
        y2 = y2 << 16 >> 16;
        var surfData = SDL.surfaces[surf];
        assert(!surfData.locked); // but we could unlock and re-lock if we must..
        surfData.ctx.save();
        surfData.ctx.strokeStyle = cssColor;
        surfData.ctx.beginPath();
        surfData.ctx.moveTo(x1, y1);
        surfData.ctx.lineTo(x2, y2);
        surfData.ctx.stroke();
        surfData.ctx.restore();
      },
  drawEllipse:(surf, x, y, rx, ry, action, cssColor) => {
        x = x << 16 >> 16;
        y = y << 16 >> 16;
        rx = rx << 16 >> 16;
        ry = ry << 16 >> 16;
        var surfData = SDL.surfaces[surf];
        assert(!surfData.locked); // but we could unlock and re-lock if we must..
  
        surfData.ctx.save();
        surfData.ctx.beginPath();
        surfData.ctx.translate(x, y);
        surfData.ctx.scale(rx, ry);
        surfData.ctx.arc(0, 0, 1, 0, 2 * Math.PI);
        surfData.ctx.restore();
  
        surfData.ctx.save();
        surfData.ctx[action + 'Style'] = cssColor;
        surfData.ctx[action]();
        surfData.ctx.restore();
      },
  translateColorToCSSRGBA:(rgba) => `rgba(${rgba>>>24},${rgba>>16 & 0xff},${rgba>>8 & 0xff},${rgba&0xff})`,
  };

  
  var _boxColor = (surf, x1, y1, x2, y2, color) =>
      SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, 'fill', SDL_gfx.translateColorToCSSRGBA(color));
  _boxColor.sig = 'ipiiiii';

  
  var _boxRGBA = (surf, x1, y1, x2, y2, r, g, b, a) =>
      SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, 'fill', SDL.translateRGBAToCSSRGBA(r, g, b, a));
  _boxRGBA.sig = 'ipiiiiiiii';

  
  var _rectangleColor = (surf, x1, y1, x2, y2, color) =>
      SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, 'stroke', SDL_gfx.translateColorToCSSRGBA(color));
  _rectangleColor.sig = 'ipiiiii';

  
  var _rectangleRGBA = (surf, x1, y1, x2, y2, r, g, b, a) =>
      SDL_gfx.drawRectangle(surf, x1, y1, x2, y2, 'stroke', SDL.translateRGBAToCSSRGBA(r, g, b, a));
  _rectangleRGBA.sig = 'ipiiiiiiii';

  
  var _ellipseColor = (surf, x, y, rx, ry, color) =>
      SDL_gfx.drawEllipse(surf, x, y, rx, ry, 'stroke', SDL_gfx.translateColorToCSSRGBA(color));
  _ellipseColor.sig = 'ipiiiii';

  
  var _ellipseRGBA = (surf, x, y, rx, ry, r, g, b, a) =>
      SDL_gfx.drawEllipse(surf, x, y, rx, ry, 'stroke', SDL.translateRGBAToCSSRGBA(r, g, b, a));
  _ellipseRGBA.sig = 'ipiiiiiiii';

  
  var _filledEllipseColor = (surf, x, y, rx, ry, color) =>
      SDL_gfx.drawEllipse(surf, x, y, rx, ry, 'fill', SDL_gfx.translateColorToCSSRGBA(color));
  _filledEllipseColor.sig = 'ipiiiii';

  
  var _filledEllipseRGBA = (surf, x, y, rx, ry, r, g, b, a) =>
      SDL_gfx.drawEllipse(surf, x, y, rx, ry, 'fill', SDL.translateRGBAToCSSRGBA(r, g, b, a));
  _filledEllipseRGBA.sig = 'ipiiiiiiii';

  
  var _lineColor = (surf, x1, y1, x2, y2, color) =>
      SDL_gfx.drawLine(surf, x1, y1, x2, y2, SDL_gfx.translateColorToCSSRGBA(color));
  _lineColor.sig = 'ipiiiii';

  
  var _lineRGBA = (surf, x1, y1, x2, y2, r, g, b, a) =>
      SDL_gfx.drawLine(surf, x1, y1, x2, y2, SDL.translateRGBAToCSSRGBA(r, g, b, a));
  _lineRGBA.sig = 'ipiiiiiiii';

  
  var _pixelRGBA = (surf, x1, y1, r, g, b, a) => _boxRGBA(surf, x1, y1, x1, y1, r, g, b, a);
  _pixelRGBA.sig = 'ipiiiiii';

  var _SDL_GL_SetAttribute = (attr, value) => {
      if (!(attr in SDL.glAttributes)) {
        abort('Unknown SDL GL attribute (' + attr + '). Please check if your SDL version is supported.');
      }
  
      SDL.glAttributes[attr] = value;
    };
  _SDL_GL_SetAttribute.sig = 'iii';

  var _SDL_GL_GetAttribute = (attr, value) => {
      if (!(attr in SDL.glAttributes)) {
        abort('Unknown SDL GL attribute (' + attr + '). Please check if your SDL version is supported.');
      }
  
      if (value) HEAP32[((value)>>2)] = SDL.glAttributes[attr];
  
      return 0;
    };
  _SDL_GL_GetAttribute.sig = 'iip';

  var _SDL_GL_SwapBuffers = () => Browser.doSwapBuffers?.();
  _SDL_GL_SwapBuffers.sig = 'v';

  
  
  
  var _SDL_GL_ExtensionSupported = (extension) => GLctx?.getExtension(UTF8ToString(extension)) ? 1 : 0;
  _SDL_GL_ExtensionSupported.sig = 'ip';

  var _SDL_DestroyWindow = (window) => {};
  _SDL_DestroyWindow.sig = 'vp';

  var _SDL_DestroyRenderer = (renderer) => {};
  _SDL_DestroyRenderer.sig = 'vp';

  var _SDL_GetWindowFlags = (window) => {
      if (Browser.isFullscreen) {
         return 1;
      }
  
      return 0;
    };
  _SDL_GetWindowFlags.sig = 'ip';

  var _SDL_GL_SwapWindow = (window) => {};
  _SDL_GL_SwapWindow.sig = 'vp';

  var _SDL_GL_MakeCurrent = (window, context) => {};
  _SDL_GL_MakeCurrent.sig = 'ipp';

  var _SDL_GL_DeleteContext = (context) => {};
  _SDL_GL_DeleteContext.sig = 'vp';

  var _SDL_GL_GetSwapInterval = () => {
      if (MainLoop.timingMode == 1) {
        return MainLoop.timingValue;
      } else {
        return 0;
      }
    };
  _SDL_GL_GetSwapInterval.sig = 'i';

  
  var _SDL_GL_SetSwapInterval = (state) => _emscripten_set_main_loop_timing(1, state);
  _SDL_GL_SetSwapInterval.sig = 'ii';

  
  var _SDL_SetWindowTitle = (window, title) => {
      if (title) document.title = UTF8ToString(title);
    };
  _SDL_SetWindowTitle.sig = 'vpp';

  var _SDL_GetWindowSize = (window, width, height) => {
      var w = Module['canvas'].width;
      var h = Module['canvas'].height;
      if (width) HEAP32[((width)>>2)] = w;
      if (height) HEAP32[((height)>>2)] = h;
    };
  _SDL_GetWindowSize.sig = 'vppp';

  var _SDL_LogSetOutputFunction = (callback, userdata) => {};
  _SDL_LogSetOutputFunction.sig = 'vpp';

  var _SDL_SetWindowFullscreen = (window, fullscreen) => {
      if (Browser.isFullscreen) {
        Module['canvas'].exitFullscreen();
        return 1;
      }
      return 0;
    };
  _SDL_SetWindowFullscreen.sig = 'ipi';

  var _SDL_ClearError = () => {};
  _SDL_ClearError.sig = 'v';

  var _SDL_SetGamma = (r, g, b) => -1;
  _SDL_SetGamma.sig = 'ifff';

  var _SDL_SetGammaRamp = (redTable, greenTable, blueTable) => -1;
  _SDL_SetGammaRamp.sig = 'ippp';

  var _SDL_NumJoysticks = () => {
      var count = 0;
      var gamepads = SDL.getGamepads();
      // The length is not the number of gamepads; check which ones are defined.
      for (var i = 0; i < gamepads.length; i++) {
        if (gamepads[i] !== undefined) count++;
      }
      return count;
    };
  _SDL_NumJoysticks.sig = 'i';

  
  var _SDL_JoystickName = (deviceIndex) => {
      var gamepad = SDL.getGamepad(deviceIndex);
      if (gamepad) {
        var name = gamepad.id;
        if (SDL.joystickNamePool.hasOwnProperty(name)) {
          return SDL.joystickNamePool[name];
        }
        return SDL.joystickNamePool[name] = stringToNewUTF8(name);
      }
      return 0;
    };
  _SDL_JoystickName.sig = 'pi';

  var _SDL_JoystickOpen = (deviceIndex) => {
      var gamepad = SDL.getGamepad(deviceIndex);
      if (gamepad) {
        // Use this as a unique 'pointer' for this joystick.
        var joystick = deviceIndex+1;
        SDL.recordJoystickState(joystick, gamepad);
        return joystick;
      }
      return 0;
    };
  _SDL_JoystickOpen.sig = 'pi';

  var _SDL_JoystickOpened = (deviceIndex) => SDL.lastJoystickState.hasOwnProperty(deviceIndex+1) ? 1 : 0;
  _SDL_JoystickOpened.sig = 'ii';

  var _SDL_JoystickIndex = (joystick) => joystick - 1;
  _SDL_JoystickIndex.sig = 'ip';

  var _SDL_JoystickNumAxes = (joystick) => {
      var gamepad = SDL.getGamepad(joystick - 1);
      if (gamepad) {
        return gamepad.axes.length;
      }
      return 0;
    };
  _SDL_JoystickNumAxes.sig = 'ip';

  var _SDL_JoystickNumBalls = (joystick) => 0;
  _SDL_JoystickNumBalls.sig = 'ip';

  var _SDL_JoystickNumHats = (joystick) => 0;
  _SDL_JoystickNumHats.sig = 'ip';

  var _SDL_JoystickNumButtons = (joystick) => {
      var gamepad = SDL.getGamepad(joystick - 1);
      if (gamepad) {
        return gamepad.buttons.length;
      }
      return 0;
    };
  _SDL_JoystickNumButtons.sig = 'ip';

  var _SDL_JoystickUpdate = () => SDL.queryJoysticks();
  _SDL_JoystickUpdate.sig = 'v';

  var _SDL_JoystickEventState = (state) => {
      if (state < 0) {
        // SDL_QUERY: Return current state.
        return SDL.joystickEventState;
      }
      return SDL.joystickEventState = state;
    };
  _SDL_JoystickEventState.sig = 'ii';

  var _SDL_JoystickGetAxis = (joystick, axis) => {
      var gamepad = SDL.getGamepad(joystick - 1);
      if (gamepad && gamepad.axes.length > axis) {
        return SDL.joystickAxisValueConversion(gamepad.axes[axis]);
      }
      return 0;
    };
  _SDL_JoystickGetAxis.sig = 'ipi';

  var _SDL_JoystickGetHat = (joystick, hat) => 0;
  _SDL_JoystickGetHat.sig = 'ipi';

  var _SDL_JoystickGetBall = (joystick, ball, dxptr, dyptr) => -1;
  _SDL_JoystickGetBall.sig = 'ipipp';

  var _SDL_JoystickGetButton = (joystick, button) => {
      var gamepad = SDL.getGamepad(joystick - 1);
      if (gamepad && gamepad.buttons.length > button) {
        return SDL.getJoystickButtonState(gamepad.buttons[button]) ? 1 : 0;
      }
      return 0;
    };
  _SDL_JoystickGetButton.sig = 'ipi';

  var _SDL_JoystickClose = (joystick) => {
      delete SDL.lastJoystickState[joystick];
    };
  _SDL_JoystickClose.sig = 'vp';

  var _SDL_InitSubSystem = (flags) => 0;
  _SDL_InitSubSystem.sig = 'ii';

  var _SDL_RWFromConstMem = (mem, size) => {
      var id = SDL.rwops.length; // TODO: recycle ids when they are null
      SDL.rwops.push({ bytes: mem, count: size });
      return id;
    };
  _SDL_RWFromConstMem.sig = 'ppi';

  
  var _SDL_RWFromMem = _SDL_RWFromConstMem;
  _SDL_RWFromMem.sig = 'ppi';



  var _SDL_GetNumAudioDrivers = () => 1;
  _SDL_GetNumAudioDrivers.sig = 'i';

  
  var _SDL_GetCurrentAudioDriver = () => stringToNewUTF8('Emscripten Audio');
  _SDL_GetCurrentAudioDriver.sig = 'p';

  var _SDL_GetScancodeFromKey = (key) => SDL.scanCodes[key];
  _SDL_GetScancodeFromKey.sig = 'ii';

  
  var _SDL_GetAudioDriver = (index) => _SDL_GetCurrentAudioDriver();
  _SDL_GetAudioDriver.sig = 'pi';

  var _SDL_EnableUNICODE = (on) => {
      var ret = SDL.unicode || 0;
      SDL.unicode = on;
      return ret;
    };
  _SDL_EnableUNICODE.sig = 'ii';

  
  
  var _SDL_AddTimer = (interval, callback, param) =>
      safeSetTimeout(
        () => getWasmTableEntry(callback)(interval, param),
        interval);
  _SDL_AddTimer.sig = 'iipp';

  var _SDL_RemoveTimer = (id) => {
      clearTimeout(id);
      return true;
    };
  _SDL_RemoveTimer.sig = 'ii';

  var _SDL_CreateThread = (fs, data, pfnBeginThread, pfnEndThread) => {
      throw 'SDL threads cannot be supported in the web platform because they assume shared state. See emscripten_create_worker etc. for a message-passing concurrency model that does let you run code in another thread.'
    };
  _SDL_CreateThread.sig = 'ppp';

  var _SDL_WaitThread = (thread, status) => { throw 'SDL_WaitThread' };
  _SDL_WaitThread.sig = 'vpp';

  var _SDL_GetThreadID = (thread) => { throw 'SDL_GetThreadID' };
  _SDL_GetThreadID.sig = 'pp';

  var _SDL_ThreadID = () => 0;
  _SDL_ThreadID.sig = 'p';

  var _SDL_AllocRW = () => { throw 'SDL_AllocRW: TODO' };
  _SDL_AllocRW.sig = 'p';

  var _SDL_CondBroadcast = (cond) => { throw 'SDL_CondBroadcast: TODO' };
  _SDL_CondBroadcast.sig = 'ip';

  var _SDL_CondWaitTimeout = (cond, mutex, ms) => { throw 'SDL_CondWaitTimeout: TODO' };
  _SDL_CondWaitTimeout.sig = 'ippi';

  var _SDL_WM_IconifyWindow = () => { throw 'SDL_WM_IconifyWindow TODO' };
  _SDL_WM_IconifyWindow.sig = 'i';

  var _Mix_SetPostMix = (func, arg) => warnOnce('Mix_SetPostMix: TODO');
  _Mix_SetPostMix.sig = 'vpp';

  var _Mix_VolumeChunk = (chunk, volume) => { throw 'Mix_VolumeChunk: TODO' };
  _Mix_VolumeChunk.sig = 'ipi';

  var _Mix_SetPosition = (channel, angle, distance) => { throw 'Mix_SetPosition: TODO' };
  _Mix_SetPosition.sig = 'iiii';

  var _Mix_QuerySpec = (frequency, format, channels) => { throw 'Mix_QuerySpec: TODO' };
  _Mix_QuerySpec.sig = 'ippp';

  var _Mix_FadeInChannelTimed = (channel, chunk, loop, ms, ticks) => { throw 'Mix_FadeInChannelTimed' };
  _Mix_FadeInChannelTimed.sig = 'iipiii';

  var _Mix_FadeOutChannel = () => { throw 'Mix_FadeOutChannel' };
  _Mix_FadeOutChannel.sig = 'iii';

  var _Mix_Linked_Version = () => { throw 'Mix_Linked_Version: TODO' };
  _Mix_Linked_Version.sig = 'p';

  var _SDL_SaveBMP_RW = (surface, dst, freedst) => { throw 'SDL_SaveBMP_RW: TODO' };
  _SDL_SaveBMP_RW.sig = 'ippi';

  var _SDL_WM_SetIcon = (icon, mask) => {};
  _SDL_WM_SetIcon.sig = 'vpp';

  var _SDL_HasRDTSC = () => 0;
  _SDL_HasRDTSC.sig = 'i';

  var _SDL_HasMMX = () => 0;
  _SDL_HasMMX.sig = 'i';

  var _SDL_HasMMXExt = () => 0;
  _SDL_HasMMXExt.sig = 'i';

  var _SDL_Has3DNow = () => 0;
  _SDL_Has3DNow.sig = 'i';

  var _SDL_Has3DNowExt = () => 0;
  _SDL_Has3DNowExt.sig = 'i';

  var _SDL_HasSSE = () => 0;
  _SDL_HasSSE.sig = 'i';

  var _SDL_HasSSE2 = () => 0;
  _SDL_HasSSE2.sig = 'i';

  var _SDL_HasAltiVec = () => 0;
  _SDL_HasAltiVec.sig = 'i';

  
  
  
  
  
  
  
  
  
  var GLFW = {
  WindowFromId:(id) => {
        if (id <= 0 || !GLFW.windows) return null;
        return GLFW.windows[id - 1];
      },
  joystickFunc:0,
  errorFunc:0,
  monitorFunc:0,
  active:null,
  scale:null,
  windows:null,
  monitors:null,
  monitorString:null,
  versionString:null,
  initialTime:null,
  extensions:null,
  devicePixelRatioMQL:null,
  hints:null,
  primaryTouchId:null,
  defaultHints:{
  131073:0,
  131074:0,
  131075:1,
  131076:1,
  131077:1,
  131082:0,
  135169:8,
  135170:8,
  135171:8,
  135172:8,
  135173:24,
  135174:8,
  135175:0,
  135176:0,
  135177:0,
  135178:0,
  135179:0,
  135180:0,
  135181:0,
  135182:0,
  135183:0,
  139265:196609,
  139266:1,
  139267:0,
  139268:0,
  139269:0,
  139270:0,
  139271:0,
  139272:0,
  139276:0,
  },
  DOMToGLFWKeyCode:(keycode) => {
        switch (keycode) {
          // these keycodes are only defined for GLFW3, assume they are the same for GLFW2
          case 0x20:return 32; // DOM_VK_SPACE -> GLFW_KEY_SPACE
          case 0xDE:return 39; // DOM_VK_QUOTE -> GLFW_KEY_APOSTROPHE
          case 0xBC:return 44; // DOM_VK_COMMA -> GLFW_KEY_COMMA
          case 0xAD:return 45; // DOM_VK_HYPHEN_MINUS -> GLFW_KEY_MINUS
          case 0xBD:return 45; // DOM_VK_MINUS -> GLFW_KEY_MINUS
          case 0xBE:return 46; // DOM_VK_PERIOD -> GLFW_KEY_PERIOD
          case 0xBF:return 47; // DOM_VK_SLASH -> GLFW_KEY_SLASH
          case 0x30:return 48; // DOM_VK_0 -> GLFW_KEY_0
          case 0x31:return 49; // DOM_VK_1 -> GLFW_KEY_1
          case 0x32:return 50; // DOM_VK_2 -> GLFW_KEY_2
          case 0x33:return 51; // DOM_VK_3 -> GLFW_KEY_3
          case 0x34:return 52; // DOM_VK_4 -> GLFW_KEY_4
          case 0x35:return 53; // DOM_VK_5 -> GLFW_KEY_5
          case 0x36:return 54; // DOM_VK_6 -> GLFW_KEY_6
          case 0x37:return 55; // DOM_VK_7 -> GLFW_KEY_7
          case 0x38:return 56; // DOM_VK_8 -> GLFW_KEY_8
          case 0x39:return 57; // DOM_VK_9 -> GLFW_KEY_9
          case 0x3B:return 59; // DOM_VK_SEMICOLON -> GLFW_KEY_SEMICOLON
          case 0x3D:return 61; // DOM_VK_EQUALS -> GLFW_KEY_EQUAL
          case 0xBB:return 61; // DOM_VK_EQUALS -> GLFW_KEY_EQUAL
          case 0x41:return 65; // DOM_VK_A -> GLFW_KEY_A
          case 0x42:return 66; // DOM_VK_B -> GLFW_KEY_B
          case 0x43:return 67; // DOM_VK_C -> GLFW_KEY_C
          case 0x44:return 68; // DOM_VK_D -> GLFW_KEY_D
          case 0x45:return 69; // DOM_VK_E -> GLFW_KEY_E
          case 0x46:return 70; // DOM_VK_F -> GLFW_KEY_F
          case 0x47:return 71; // DOM_VK_G -> GLFW_KEY_G
          case 0x48:return 72; // DOM_VK_H -> GLFW_KEY_H
          case 0x49:return 73; // DOM_VK_I -> GLFW_KEY_I
          case 0x4A:return 74; // DOM_VK_J -> GLFW_KEY_J
          case 0x4B:return 75; // DOM_VK_K -> GLFW_KEY_K
          case 0x4C:return 76; // DOM_VK_L -> GLFW_KEY_L
          case 0x4D:return 77; // DOM_VK_M -> GLFW_KEY_M
          case 0x4E:return 78; // DOM_VK_N -> GLFW_KEY_N
          case 0x4F:return 79; // DOM_VK_O -> GLFW_KEY_O
          case 0x50:return 80; // DOM_VK_P -> GLFW_KEY_P
          case 0x51:return 81; // DOM_VK_Q -> GLFW_KEY_Q
          case 0x52:return 82; // DOM_VK_R -> GLFW_KEY_R
          case 0x53:return 83; // DOM_VK_S -> GLFW_KEY_S
          case 0x54:return 84; // DOM_VK_T -> GLFW_KEY_T
          case 0x55:return 85; // DOM_VK_U -> GLFW_KEY_U
          case 0x56:return 86; // DOM_VK_V -> GLFW_KEY_V
          case 0x57:return 87; // DOM_VK_W -> GLFW_KEY_W
          case 0x58:return 88; // DOM_VK_X -> GLFW_KEY_X
          case 0x59:return 89; // DOM_VK_Y -> GLFW_KEY_Y
          case 0x5a:return 90; // DOM_VK_Z -> GLFW_KEY_Z
          case 0xDB:return 91; // DOM_VK_OPEN_BRACKET -> GLFW_KEY_LEFT_BRACKET
          case 0xDC:return 92; // DOM_VK_BACKSLASH -> GLFW_KEY_BACKSLASH
          case 0xDD:return 93; // DOM_VK_CLOSE_BRACKET -> GLFW_KEY_RIGHT_BRACKET
          case 0xC0:return 96; // DOM_VK_BACK_QUOTE -> GLFW_KEY_GRAVE_ACCENT
  
          case 0x1B:return 256; // DOM_VK_ESCAPE -> GLFW_KEY_ESCAPE
          case 0x0D:return 257; // DOM_VK_RETURN -> GLFW_KEY_ENTER
          case 0x09:return 258; // DOM_VK_TAB -> GLFW_KEY_TAB
          case 0x08:return 259; // DOM_VK_BACK -> GLFW_KEY_BACKSPACE
          case 0x2D:return 260; // DOM_VK_INSERT -> GLFW_KEY_INSERT
          case 0x2E:return 261; // DOM_VK_DELETE -> GLFW_KEY_DELETE
          case 0x27:return 262; // DOM_VK_RIGHT -> GLFW_KEY_RIGHT
          case 0x25:return 263; // DOM_VK_LEFT -> GLFW_KEY_LEFT
          case 0x28:return 264; // DOM_VK_DOWN -> GLFW_KEY_DOWN
          case 0x26:return 265; // DOM_VK_UP -> GLFW_KEY_UP
          case 0x21:return 266; // DOM_VK_PAGE_UP -> GLFW_KEY_PAGE_UP
          case 0x22:return 267; // DOM_VK_PAGE_DOWN -> GLFW_KEY_PAGE_DOWN
          case 0x24:return 268; // DOM_VK_HOME -> GLFW_KEY_HOME
          case 0x23:return 269; // DOM_VK_END -> GLFW_KEY_END
          case 0x14:return 280; // DOM_VK_CAPS_LOCK -> GLFW_KEY_CAPS_LOCK
          case 0x91:return 281; // DOM_VK_SCROLL_LOCK -> GLFW_KEY_SCROLL_LOCK
          case 0x90:return 282; // DOM_VK_NUM_LOCK -> GLFW_KEY_NUM_LOCK
          case 0x2C:return 283; // DOM_VK_SNAPSHOT -> GLFW_KEY_PRINT_SCREEN
          case 0x13:return 284; // DOM_VK_PAUSE -> GLFW_KEY_PAUSE
          case 0x70:return 290; // DOM_VK_F1 -> GLFW_KEY_F1
          case 0x71:return 291; // DOM_VK_F2 -> GLFW_KEY_F2
          case 0x72:return 292; // DOM_VK_F3 -> GLFW_KEY_F3
          case 0x73:return 293; // DOM_VK_F4 -> GLFW_KEY_F4
          case 0x74:return 294; // DOM_VK_F5 -> GLFW_KEY_F5
          case 0x75:return 295; // DOM_VK_F6 -> GLFW_KEY_F6
          case 0x76:return 296; // DOM_VK_F7 -> GLFW_KEY_F7
          case 0x77:return 297; // DOM_VK_F8 -> GLFW_KEY_F8
          case 0x78:return 298; // DOM_VK_F9 -> GLFW_KEY_F9
          case 0x79:return 299; // DOM_VK_F10 -> GLFW_KEY_F10
          case 0x7A:return 300; // DOM_VK_F11 -> GLFW_KEY_F11
          case 0x7B:return 301; // DOM_VK_F12 -> GLFW_KEY_F12
          case 0x7C:return 302; // DOM_VK_F13 -> GLFW_KEY_F13
          case 0x7D:return 303; // DOM_VK_F14 -> GLFW_KEY_F14
          case 0x7E:return 304; // DOM_VK_F15 -> GLFW_KEY_F15
          case 0x7F:return 305; // DOM_VK_F16 -> GLFW_KEY_F16
          case 0x80:return 306; // DOM_VK_F17 -> GLFW_KEY_F17
          case 0x81:return 307; // DOM_VK_F18 -> GLFW_KEY_F18
          case 0x82:return 308; // DOM_VK_F19 -> GLFW_KEY_F19
          case 0x83:return 309; // DOM_VK_F20 -> GLFW_KEY_F20
          case 0x84:return 310; // DOM_VK_F21 -> GLFW_KEY_F21
          case 0x85:return 311; // DOM_VK_F22 -> GLFW_KEY_F22
          case 0x86:return 312; // DOM_VK_F23 -> GLFW_KEY_F23
          case 0x87:return 313; // DOM_VK_F24 -> GLFW_KEY_F24
          case 0x88:return 314; // 0x88 (not used?) -> GLFW_KEY_F25
          case 0x60:return 320; // DOM_VK_NUMPAD0 -> GLFW_KEY_KP_0
          case 0x61:return 321; // DOM_VK_NUMPAD1 -> GLFW_KEY_KP_1
          case 0x62:return 322; // DOM_VK_NUMPAD2 -> GLFW_KEY_KP_2
          case 0x63:return 323; // DOM_VK_NUMPAD3 -> GLFW_KEY_KP_3
          case 0x64:return 324; // DOM_VK_NUMPAD4 -> GLFW_KEY_KP_4
          case 0x65:return 325; // DOM_VK_NUMPAD5 -> GLFW_KEY_KP_5
          case 0x66:return 326; // DOM_VK_NUMPAD6 -> GLFW_KEY_KP_6
          case 0x67:return 327; // DOM_VK_NUMPAD7 -> GLFW_KEY_KP_7
          case 0x68:return 328; // DOM_VK_NUMPAD8 -> GLFW_KEY_KP_8
          case 0x69:return 329; // DOM_VK_NUMPAD9 -> GLFW_KEY_KP_9
          case 0x6E:return 330; // DOM_VK_DECIMAL -> GLFW_KEY_KP_DECIMAL
          case 0x6F:return 331; // DOM_VK_DIVIDE -> GLFW_KEY_KP_DIVIDE
          case 0x6A:return 332; // DOM_VK_MULTIPLY -> GLFW_KEY_KP_MULTIPLY
          case 0x6D:return 333; // DOM_VK_SUBTRACT -> GLFW_KEY_KP_SUBTRACT
          case 0x6B:return 334; // DOM_VK_ADD -> GLFW_KEY_KP_ADD
          // case 0x0D:return 335; // DOM_VK_RETURN -> GLFW_KEY_KP_ENTER (DOM_KEY_LOCATION_RIGHT)
          // case 0x61:return 336; // DOM_VK_EQUALS -> GLFW_KEY_KP_EQUAL (DOM_KEY_LOCATION_RIGHT)
          case 0x10:return 340; // DOM_VK_SHIFT -> GLFW_KEY_LEFT_SHIFT
          case 0x11:return 341; // DOM_VK_CONTROL -> GLFW_KEY_LEFT_CONTROL
          case 0x12:return 342; // DOM_VK_ALT -> GLFW_KEY_LEFT_ALT
          case 0x5B:return 343; // DOM_VK_WIN -> GLFW_KEY_LEFT_SUPER
          case 0xE0:return 343; // DOM_VK_META -> GLFW_KEY_LEFT_SUPER
          // case 0x10:return 344; // DOM_VK_SHIFT -> GLFW_KEY_RIGHT_SHIFT (DOM_KEY_LOCATION_RIGHT)
          // case 0x11:return 345; // DOM_VK_CONTROL -> GLFW_KEY_RIGHT_CONTROL (DOM_KEY_LOCATION_RIGHT)
          // case 0x12:return 346; // DOM_VK_ALT -> GLFW_KEY_RIGHT_ALT (DOM_KEY_LOCATION_RIGHT)
          // case 0x5B:return 347; // DOM_VK_WIN -> GLFW_KEY_RIGHT_SUPER (DOM_KEY_LOCATION_RIGHT)
          case 0x5D:return 348; // DOM_VK_CONTEXT_MENU -> GLFW_KEY_MENU
          // XXX: GLFW_KEY_WORLD_1, GLFW_KEY_WORLD_2 what are these?
          default:return -1; // GLFW_KEY_UNKNOWN
        };
      },
  getModBits:(win) => {
        var mod = 0;
        if (win.keys[340]) mod |= 0x0001; // GLFW_MOD_SHIFT
        if (win.keys[341]) mod |= 0x0002; // GLFW_MOD_CONTROL
        if (win.keys[342]) mod |= 0x0004; // GLFW_MOD_ALT
        if (win.keys[343] || win.keys[348]) mod |= 0x0008; // GLFW_MOD_SUPER
        // add caps and num lock keys? only if lock_key_mod is set
        return mod;
      },
  onKeyPress:(event) => {
        if (!GLFW.active || !GLFW.active.charFunc) return;
        if (event.ctrlKey || event.metaKey) return;
  
        // correct unicode charCode is only available with onKeyPress event
        var charCode = event.charCode;
        if (charCode == 0 || (charCode >= 0x00 && charCode <= 0x1F)) return;
  
        getWasmTableEntry(GLFW.active.charFunc)(GLFW.active.id, charCode);
      },
  onKeyChanged:(keyCode, status) => {
        if (!GLFW.active) return;
  
        var key = GLFW.DOMToGLFWKeyCode(keyCode);
        if (key == -1) return;
  
        var repeat = status && GLFW.active.keys[key];
        GLFW.active.keys[key] = status;
        GLFW.active.domKeys[keyCode] = status;
  
        if (GLFW.active.keyFunc) {
          if (repeat) status = 2; // GLFW_REPEAT
          getWasmTableEntry(GLFW.active.keyFunc)(GLFW.active.id, key, keyCode, status, GLFW.getModBits(GLFW.active));
        }
      },
  onGamepadConnected:(event) => {
        GLFW.refreshJoysticks();
      },
  onGamepadDisconnected:(event) => {
        GLFW.refreshJoysticks();
      },
  onKeydown:(event) => {
        GLFW.onKeyChanged(event.keyCode, 1); // GLFW_PRESS or GLFW_REPEAT
  
        // This logic comes directly from the sdl implementation. We cannot
        // call preventDefault on all keydown events otherwise onKeyPress will
        // not get called
        if (event.key == 'Backspace' || event.key == 'Tab') {
          event.preventDefault();
        }
      },
  onKeyup:(event) => {
        GLFW.onKeyChanged(event.keyCode, 0); // GLFW_RELEASE
      },
  onBlur:(event) => {
        if (!GLFW.active) return;
  
        for (var i = 0; i < GLFW.active.domKeys.length; ++i) {
          if (GLFW.active.domKeys[i]) {
            GLFW.onKeyChanged(i, 0); // GLFW_RELEASE
          }
        }
      },
  onMousemove:(event) => {
        if (!GLFW.active) return;
  
        if (event.type === 'touchmove') {
          // Handling for touch events that are being converted to mouse input.
  
          // Don't let the browser fire a duplicate mouse event.
          event.preventDefault();
  
          let primaryChanged = false;
          for (let i of event.changedTouches) {
            // If our chosen primary touch moved, update Browser mouse coords
            if (GLFW.primaryTouchId === i.identifier) {
              Browser.setMouseCoords(i.pageX, i.pageY);
              primaryChanged = true;
              break;
            }
          }
  
          if (!primaryChanged) {
            // Do not send mouse events if some touch other than the primary triggered this.
            return;
          }
  
        } else {
          // Handling for non-touch mouse input events.
          Browser.calculateMouseEvent(event);
        }
  
        if (event.target != Module["canvas"] || !GLFW.active.cursorPosFunc) return;
  
        if (GLFW.active.cursorPosFunc) {
          getWasmTableEntry(GLFW.active.cursorPosFunc)(GLFW.active.id, Browser.mouseX, Browser.mouseY);
        }
      },
  DOMToGLFWMouseButton:(event) => {
        // DOM and glfw have different button codes.
        // See http://www.w3schools.com/jsref/event_button.asp.
        var eventButton = event['button'];
        if (eventButton > 0) {
          if (eventButton == 1) {
            eventButton = 2;
          } else {
            eventButton = 1;
          }
        }
        return eventButton;
      },
  onMouseenter:(event) => {
        if (!GLFW.active) return;
  
        if (event.target != Module["canvas"]) return;
  
        if (GLFW.active.cursorEnterFunc) {
          getWasmTableEntry(GLFW.active.cursorEnterFunc)(GLFW.active.id, 1);
        }
      },
  onMouseleave:(event) => {
        if (!GLFW.active) return;
  
        if (event.target != Module["canvas"]) return;
  
        if (GLFW.active.cursorEnterFunc) {
          getWasmTableEntry(GLFW.active.cursorEnterFunc)(GLFW.active.id, 0);
        }
      },
  onMouseButtonChanged:(event, status) => {
        if (!GLFW.active) return;
  
        if (event.target != Module["canvas"]) return;
  
        // Is this from a touch event?
        const isTouchType = event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchcancel';
  
        // Only emulating mouse left-click behavior for touches.
        let eventButton = 0;
        if (isTouchType) {
          // Handling for touch events that are being converted to mouse input.
  
          // Don't let the browser fire a duplicate mouse event.
          event.preventDefault();
  
          let primaryChanged = false;
  
          // Set a primary touch if we have none.
          if (GLFW.primaryTouchId === null && event.type === 'touchstart' && event.targetTouches.length > 0) {
            // Pick the first touch that started in the canvas and treat it as primary.
            const chosenTouch = event.targetTouches[0];
            GLFW.primaryTouchId = chosenTouch.identifier;
  
            Browser.setMouseCoords(chosenTouch.pageX, chosenTouch.pageY);
            primaryChanged = true;
          } else if (event.type === 'touchend' || event.type === 'touchcancel') {
            // Clear the primary touch if it ended.
            for (let i of event.changedTouches) {
              // If our chosen primary touch ended, remove it.
              if (GLFW.primaryTouchId === i.identifier) {
                GLFW.primaryTouchId = null;
                primaryChanged = true;
                break;
              }
            }
          }
  
          if (!primaryChanged) {
            // Do not send mouse events if some touch other than the primary triggered this.
            return;
          }
  
        } else {
          // Handling for non-touch mouse input events.
          Browser.calculateMouseEvent(event);
          eventButton = GLFW.DOMToGLFWMouseButton(event);
        }
  
        if (status == 1) { // GLFW_PRESS
          GLFW.active.buttons |= (1 << eventButton);
          try {
            event.target.setCapture();
          } catch (e) {}
        } else {  // GLFW_RELEASE
          GLFW.active.buttons &= ~(1 << eventButton);
        }
  
        // Send mouse event to GLFW.
        if (GLFW.active.mouseButtonFunc) {
          getWasmTableEntry(GLFW.active.mouseButtonFunc)(GLFW.active.id, eventButton, status, GLFW.getModBits(GLFW.active));
        }
      },
  onMouseButtonDown:(event) => {
        if (!GLFW.active) return;
        GLFW.onMouseButtonChanged(event, 1); // GLFW_PRESS
      },
  onMouseButtonUp:(event) => {
        if (!GLFW.active) return;
        GLFW.onMouseButtonChanged(event, 0); // GLFW_RELEASE
      },
  onMouseWheel:(event) => {
        // Note the minus sign that flips browser wheel direction (positive direction scrolls page down) to native wheel direction (positive direction is mouse wheel up)
        var delta = -Browser.getMouseWheelDelta(event);
        delta = (delta == 0) ? 0 : (delta > 0 ? Math.max(delta, 1) : Math.min(delta, -1)); // Quantize to integer so that minimum scroll is at least +/- 1.
        GLFW.wheelPos += delta;
  
        if (!GLFW.active || !GLFW.active.scrollFunc || event.target != Module['canvas']) return;
        var sx = 0;
        var sy = delta;
        if (event.type == 'mousewheel') {
          sx = event.wheelDeltaX;
        } else {
          sx = event.deltaX;
        }
  
        getWasmTableEntry(GLFW.active.scrollFunc)(GLFW.active.id, sx, sy);
  
        event.preventDefault();
      },
  onCanvasResize:(width, height, framebufferWidth, framebufferHeight) => {
        if (!GLFW.active) return;
  
        var resizeNeeded = false;
  
        // If the client is requesting fullscreen mode
        if (document["fullscreen"] || document["fullScreen"] || document["mozFullScreen"] || document["webkitIsFullScreen"]) {
          if (!GLFW.active.fullscreen) {
            resizeNeeded = width != screen.width || height != screen.height;
            GLFW.active.storedX = GLFW.active.x;
            GLFW.active.storedY = GLFW.active.y;
            GLFW.active.storedWidth = GLFW.active.width;
            GLFW.active.storedHeight = GLFW.active.height;
            GLFW.active.x = GLFW.active.y = 0;
            GLFW.active.width = screen.width;
            GLFW.active.height = screen.height;
            GLFW.active.fullscreen = true;
          }
        // If the client is reverting from fullscreen mode
        } else if (GLFW.active.fullscreen == true) {
          resizeNeeded = width != GLFW.active.storedWidth || height != GLFW.active.storedHeight;
          GLFW.active.x = GLFW.active.storedX;
          GLFW.active.y = GLFW.active.storedY;
          GLFW.active.width = GLFW.active.storedWidth;
          GLFW.active.height = GLFW.active.storedHeight;
          GLFW.active.fullscreen = false;
        }
  
        if (resizeNeeded) {
          // width or height is changed (fullscreen / exit fullscreen) which will call this listener back
          // with proper framebufferWidth/framebufferHeight
          Browser.setCanvasSize(GLFW.active.width, GLFW.active.height);
        } else if (GLFW.active.width != width ||
                   GLFW.active.height != height ||
                   GLFW.active.framebufferWidth != framebufferWidth ||
                   GLFW.active.framebufferHeight != framebufferHeight) {
          GLFW.active.width = width;
          GLFW.active.height = height;
          GLFW.active.framebufferWidth = framebufferWidth;
          GLFW.active.framebufferHeight = framebufferHeight;
          GLFW.onWindowSizeChanged();
          GLFW.onFramebufferSizeChanged();
        }
      },
  onWindowSizeChanged:() => {
        if (!GLFW.active) return;
  
        if (GLFW.active.windowSizeFunc) {
          getWasmTableEntry(GLFW.active.windowSizeFunc)(GLFW.active.id, GLFW.active.width, GLFW.active.height);
        }
      },
  onFramebufferSizeChanged:() => {
        if (!GLFW.active) return;
  
        if (GLFW.active.framebufferSizeFunc) {
          getWasmTableEntry(GLFW.active.framebufferSizeFunc)(GLFW.active.id, GLFW.active.framebufferWidth, GLFW.active.framebufferHeight);
        }
      },
  onWindowContentScaleChanged:(scale) => {
        GLFW.scale = scale;
        if (!GLFW.active) return;
  
        if (GLFW.active.windowContentScaleFunc) {
          getWasmTableEntry(GLFW.active.windowContentScaleFunc)(GLFW.active.id, GLFW.scale, GLFW.scale);
        }
      },
  getTime:() => _emscripten_get_now() / 1000,
  setWindowTitle:(winid, title) => {
        var win = GLFW.WindowFromId(winid);
        if (!win) return;
  
        win.title = title;
        if (GLFW.active.id == win.id) {
          _emscripten_set_window_title(title);
        }
      },
  setJoystickCallback:(cbfun) => {
        var prevcbfun = GLFW.joystickFunc;
        GLFW.joystickFunc = cbfun;
        GLFW.refreshJoysticks();
        return prevcbfun;
      },
  joys:{
  },
  lastGamepadState:[],
  lastGamepadStateFrame:null,
  refreshJoysticks:() => {
        // Produce a new Gamepad API sample if we are ticking a new game frame, or if not using emscripten_set_main_loop() at all to drive animation.
        if (MainLoop.currentFrameNumber !== GLFW.lastGamepadStateFrame || !MainLoop.currentFrameNumber) {
          GLFW.lastGamepadState = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads || []);
          GLFW.lastGamepadStateFrame = MainLoop.currentFrameNumber;
  
          for (var joy = 0; joy < GLFW.lastGamepadState.length; ++joy) {
            var gamepad = GLFW.lastGamepadState[joy];
  
            if (gamepad) {
              if (!GLFW.joys[joy]) {
                out('glfw joystick connected:',joy);
                GLFW.joys[joy] = {
                  id: stringToNewUTF8(gamepad.id),
                  buttonsCount: gamepad.buttons.length,
                  axesCount: gamepad.axes.length,
                  buttons: _malloc(gamepad.buttons.length),
                  axes: _malloc(gamepad.axes.length*4),
                };
  
                if (GLFW.joystickFunc) {
                  getWasmTableEntry(GLFW.joystickFunc)(joy, 0x00040001); // GLFW_CONNECTED
                }
              }
  
              var data = GLFW.joys[joy];
  
              for (var i = 0; i < gamepad.buttons.length;  ++i) {
                HEAP8[data.buttons + i] = gamepad.buttons[i].pressed;
              }
  
              for (var i = 0; i < gamepad.axes.length; ++i) {
                HEAPF32[((data.axes + i*4)>>2)] = gamepad.axes[i];
              }
            } else {
              if (GLFW.joys[joy]) {
                out('glfw joystick disconnected',joy);
  
                if (GLFW.joystickFunc) {
                  getWasmTableEntry(GLFW.joystickFunc)(joy, 0x00040002); // GLFW_DISCONNECTED
                }
  
                _free(GLFW.joys[joy].id);
                _free(GLFW.joys[joy].buttons);
                _free(GLFW.joys[joy].axes);
  
                delete GLFW.joys[joy];
              }
            }
          }
        }
      },
  setKeyCallback:(winid, cbfun) => {
        var win = GLFW.WindowFromId(winid);
        if (!win) return null;
        var prevcbfun = win.keyFunc;
        win.keyFunc = cbfun;
        return prevcbfun;
      },
  setCharCallback:(winid, cbfun) => {
        var win = GLFW.WindowFromId(winid);
        if (!win) return null;
        var prevcbfun = win.charFunc;
        win.charFunc = cbfun;
        return prevcbfun;
      },
  setMouseButtonCallback:(winid, cbfun) => {
        var win = GLFW.WindowFromId(winid);
        if (!win) return null;
        var prevcbfun = win.mouseButtonFunc;
        win.mouseButtonFunc = cbfun;
        return prevcbfun;
      },
  setCursorPosCallback:(winid, cbfun) => {
        var win = GLFW.WindowFromId(winid);
        if (!win) return null;
        var prevcbfun = win.cursorPosFunc;
        win.cursorPosFunc = cbfun;
        return prevcbfun;
      },
  setScrollCallback:(winid, cbfun) => {
        var win = GLFW.WindowFromId(winid);
        if (!win) return null;
        var prevcbfun = win.scrollFunc;
        win.scrollFunc = cbfun;
        return prevcbfun;
      },
  setDropCallback:(winid, cbfun) => {
        var win = GLFW.WindowFromId(winid);
        if (!win) return null;
        var prevcbfun = win.dropFunc;
        win.dropFunc = cbfun;
        return prevcbfun;
      },
  onDrop:(event) => {
        if (!GLFW.active || !GLFW.active.dropFunc) return;
        if (!event.dataTransfer || !event.dataTransfer.files || event.dataTransfer.files.length == 0) return;
  
        event.preventDefault();
  
        var filenames = _malloc(event.dataTransfer.files.length*4);
        var filenamesArray = [];
        var count = event.dataTransfer.files.length;
  
        // Read and save the files to emscripten's FS
        var written = 0;
        var drop_dir = '.glfw_dropped_files';
        FS.createPath('/', drop_dir);
  
        function save(file) {
          var path = '/' + drop_dir + '/' + file.name.replace(/\//g, '_');
          var reader = new FileReader();
          reader.onloadend = (e) => {
            if (reader.readyState != 2) { // not DONE
              ++written;
              out('failed to read dropped file: '+file.name+': '+reader.error);
              return;
            }
  
            var data = e.target.result;
            FS.writeFile(path, new Uint8Array(data));
            if (++written === count) {
              getWasmTableEntry(GLFW.active.dropFunc)(GLFW.active.id, count, filenames);
  
              for (var i = 0; i < filenamesArray.length; ++i) {
                _free(filenamesArray[i]);
              }
              _free(filenames);
            }
          };
          reader.readAsArrayBuffer(file);
  
          var filename = stringToNewUTF8(path);
          filenamesArray.push(filename);
          HEAPU32[((filenames + i*4)>>2)] = filename;
        }
  
        for (var i = 0; i < count; ++i) {
          save(event.dataTransfer.files[i]);
        }
  
        return false;
      },
  onDragover:(event) => {
        if (!GLFW.active || !GLFW.active.dropFunc) return;
  
        event.preventDefault();
        return false;
      },
  setWindowSizeCallback:(winid, cbfun) => {
        var win = GLFW.WindowFromId(winid);
        if (!win) return null;
        var prevcbfun = win.windowSizeFunc;
        win.windowSizeFunc = cbfun;
  
        return prevcbfun;
      },
  setWindowCloseCallback:(winid, cbfun) => {
        var win = GLFW.WindowFromId(winid);
        if (!win) return null;
        var prevcbfun = win.windowCloseFunc;
        win.windowCloseFunc = cbfun;
        return prevcbfun;
      },
  setWindowRefreshCallback:(winid, cbfun) => {
        var win = GLFW.WindowFromId(winid);
        if (!win) return null;
        var prevcbfun = win.windowRefreshFunc;
        win.windowRefreshFunc = cbfun;
        return prevcbfun;
      },
  onClickRequestPointerLock:(e) => {
        if (!Browser.pointerLock && Module['canvas'].requestPointerLock) {
          Module['canvas'].requestPointerLock();
          e.preventDefault();
        }
      },
  setInputMode:(winid, mode, value) => {
        var win = GLFW.WindowFromId(winid);
        if (!win) return;
  
        switch (mode) {
          case 0x00033001: { // GLFW_CURSOR
            switch (value) {
              case 0x00034001: { // GLFW_CURSOR_NORMAL
                win.inputModes[mode] = value;
                Module['canvas'].removeEventListener('click', GLFW.onClickRequestPointerLock, true);
                Module['canvas'].exitPointerLock();
                break;
              }
              case 0x00034002: { // GLFW_CURSOR_HIDDEN
                err('glfwSetInputMode called with GLFW_CURSOR_HIDDEN value not implemented');
                break;
              }
              case 0x00034003: { // GLFW_CURSOR_DISABLED
                win.inputModes[mode] = value;
                Module['canvas'].addEventListener('click', GLFW.onClickRequestPointerLock, true);
                Module['canvas'].requestPointerLock();
                break;
              }
              default: {
                err(`glfwSetInputMode called with unknown value parameter value: ${value}`);
                break;
              }
            }
            break;
          }
          case 0x00033002: { // GLFW_STICKY_KEYS
            err('glfwSetInputMode called with GLFW_STICKY_KEYS mode not implemented');
            break;
          }
          case 0x00033003: { // GLFW_STICKY_MOUSE_BUTTONS
            err('glfwSetInputMode called with GLFW_STICKY_MOUSE_BUTTONS mode not implemented');
            break;
          }
          case 0x00033004: { // GLFW_LOCK_KEY_MODS
            err('glfwSetInputMode called with GLFW_LOCK_KEY_MODS mode not implemented');
            break;
          }
          case 0x000330005: { // GLFW_RAW_MOUSE_MOTION
            err('glfwSetInputMode called with GLFW_RAW_MOUSE_MOTION mode not implemented');
            break;
          }
          default: {
            err(`glfwSetInputMode called with unknown mode parameter value: ${mode}`);
            break;
          }
        }
      },
  getKey:(winid, key) => {
        var win = GLFW.WindowFromId(winid);
        if (!win) return 0;
        return win.keys[key];
      },
  getMouseButton:(winid, button) => {
        var win = GLFW.WindowFromId(winid);
        if (!win) return 0;
        return (win.buttons & (1 << button)) > 0;
      },
  getCursorPos:(winid, x, y) => {
        HEAPF64[((x)>>3)] = Browser.mouseX;
        HEAPF64[((y)>>3)] = Browser.mouseY;
      },
  getMousePos:(winid, x, y) => {
        HEAP32[((x)>>2)] = Browser.mouseX;
        HEAP32[((y)>>2)] = Browser.mouseY;
      },
  setCursorPos:(winid, x, y) => {
      },
  getWindowPos:(winid, x, y) => {
        var wx = 0;
        var wy = 0;
  
        var win = GLFW.WindowFromId(winid);
        if (win) {
          wx = win.x;
          wy = win.y;
        }
  
        if (x) {
          HEAP32[((x)>>2)] = wx;
        }
  
        if (y) {
          HEAP32[((y)>>2)] = wy;
        }
      },
  setWindowPos:(winid, x, y) => {
        var win = GLFW.WindowFromId(winid);
        if (!win) return;
        win.x = x;
        win.y = y;
      },
  getWindowSize:(winid, width, height) => {
        var ww = 0;
        var wh = 0;
  
        var win = GLFW.WindowFromId(winid);
        if (win) {
          ww = win.width;
          wh = win.height;
        }
  
        if (width) {
          HEAP32[((width)>>2)] = ww;
        }
  
        if (height) {
          HEAP32[((height)>>2)] = wh;
        }
      },
  setWindowSize:(winid, width, height) => {
        var win = GLFW.WindowFromId(winid);
        if (!win) return;
  
        if (GLFW.active.id == win.id) {
          Browser.setCanvasSize(width, height); // triggers the listener (onCanvasResize) + windowSizeFunc
        }
      },
  defaultWindowHints:() => {
        GLFW.hints = Object.assign({}, GLFW.defaultHints);
      },
  createWindow:(width, height, title, monitor, share) => {
        var i, id;
        for (i = 0; i < GLFW.windows.length && GLFW.windows[i] !== null; i++) {
          // no-op
        }
        if (i > 0) throw "glfwCreateWindow only supports one window at time currently";
  
        // id for window
        id = i + 1;
  
        // not valid
        if (width <= 0 || height <= 0) return 0;
  
        if (monitor) {
          Browser.requestFullscreen();
        } else {
          Browser.setCanvasSize(width, height);
        }
  
        // Create context when there are no existing alive windows
        for (i = 0; i < GLFW.windows.length && GLFW.windows[i] == null; i++) {
          // no-op
        }
        var useWebGL = GLFW.hints[0x00022001] > 0; // Use WebGL when we are told to based on GLFW_CLIENT_API
        if (i == GLFW.windows.length) {
          if (useWebGL) {
            var contextAttributes = {
              majorVersion: GLFW.hints[0x00022002],    // GLFW_CONTEXT_VERSION_MAJOR
              minorVersion: GLFW.hints[0x00022003],    // GLFW_CONTEXT_VERSION_MINOR
              antialias: (GLFW.hints[0x0002100D] > 1), // GLFW_SAMPLES
              depth: (GLFW.hints[0x00021005] > 0),     // GLFW_DEPTH_BITS
              stencil: (GLFW.hints[0x00021006] > 0),   // GLFW_STENCIL_BITS
              alpha: (GLFW.hints[0x00021004] > 0)      // GLFW_ALPHA_BITS
            }
            Browser.createContext(Module['canvas'], /*useWebGL=*/true, /*setInModule=*/true, contextAttributes);
          } else {
            Browser.init();
          }
        }
  
        // If context creation failed, do not return a valid window
        if (!Module['ctx'] && useWebGL) return 0;
  
        // Initializes the framebuffer size from the canvas
        const canvas = Module['canvas'];
        var win = new GLFW_Window(id, width, height, canvas.width, canvas.height, title, monitor, share);
  
        // Set window to array
        if (id - 1 == GLFW.windows.length) {
          GLFW.windows.push(win);
        } else {
          GLFW.windows[id - 1] = win;
        }
  
        GLFW.active = win;
        GLFW.adjustCanvasDimensions();
        return win.id;
      },
  destroyWindow:(winid) => {
        var win = GLFW.WindowFromId(winid);
        if (!win) return;
  
        if (win.windowCloseFunc) {
          getWasmTableEntry(win.windowCloseFunc)(win.id);
        }
  
        GLFW.windows[win.id - 1] = null;
        if (GLFW.active.id == win.id)
          GLFW.active = null;
  
        // Destroy context when no alive windows
        for (var i = 0; i < GLFW.windows.length; i++)
          if (GLFW.windows[i] !== null) return;
  
        delete Module['ctx'];
      },
  swapBuffers:(winid) => {
      },
  requestFullscreen(lockPointer, resizeCanvas) {
        Browser.lockPointer = lockPointer;
        Browser.resizeCanvas = resizeCanvas;
        if (typeof Browser.lockPointer == 'undefined') Browser.lockPointer = true;
        if (typeof Browser.resizeCanvas == 'undefined') Browser.resizeCanvas = false;
  
        var canvas = Module['canvas'];
        function fullscreenChange() {
          Browser.isFullscreen = false;
          var canvasContainer = canvas.parentNode;
          if ((document['fullscreenElement'] || document['mozFullScreenElement'] ||
            document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
            document['webkitCurrentFullScreenElement']) === canvasContainer) {
            canvas.exitFullscreen = Browser.exitFullscreen;
            if (Browser.lockPointer) canvas.requestPointerLock();
            Browser.isFullscreen = true;
            if (Browser.resizeCanvas) {
              Browser.setFullscreenCanvasSize();
            } else {
              Browser.updateCanvasDimensions(canvas);
              Browser.updateResizeListeners();
            }
          } else {
            // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen
            canvasContainer.parentNode.insertBefore(canvas, canvasContainer);
            canvasContainer.parentNode.removeChild(canvasContainer);
  
            if (Browser.resizeCanvas) {
              Browser.setWindowedCanvasSize();
            } else {
              Browser.updateCanvasDimensions(canvas);
              Browser.updateResizeListeners();
            }
          }
          Module['onFullScreen']?.(Browser.isFullscreen);
          Module['onFullscreen']?.(Browser.isFullscreen);
        }
  
        if (!Browser.fullscreenHandlersInstalled) {
          Browser.fullscreenHandlersInstalled = true;
          document.addEventListener('fullscreenchange', fullscreenChange, false);
          document.addEventListener('mozfullscreenchange', fullscreenChange, false);
          document.addEventListener('webkitfullscreenchange', fullscreenChange, false);
          document.addEventListener('MSFullscreenChange', fullscreenChange, false);
        }
  
        // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
        var canvasContainer = document.createElement("div");
        canvas.parentNode.insertBefore(canvasContainer, canvas);
        canvasContainer.appendChild(canvas);
  
        // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)
        canvasContainer.requestFullscreen = canvasContainer['requestFullscreen'] ||
          canvasContainer['mozRequestFullScreen'] ||
          canvasContainer['msRequestFullscreen'] ||
          (canvasContainer['webkitRequestFullscreen'] ? () => canvasContainer['webkitRequestFullscreen'](Element['ALLOW_KEYBOARD_INPUT']) : null) ||
          (canvasContainer['webkitRequestFullScreen'] ? () => canvasContainer['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) : null);
  
        canvasContainer.requestFullscreen();
      },
  updateCanvasDimensions(canvas, wNative, hNative) {
        const scale = GLFW.getHiDPIScale();
  
        if (wNative && hNative) {
          canvas.widthNative = wNative;
          canvas.heightNative = hNative;
        } else {
          wNative = canvas.widthNative;
          hNative = canvas.heightNative;
        }
        var w = wNative;
        var h = hNative;
        if (Module['forcedAspectRatio'] && Module['forcedAspectRatio'] > 0) {
          if (w/h < Module['forcedAspectRatio']) {
            w = Math.round(h * Module['forcedAspectRatio']);
          } else {
            h = Math.round(w / Module['forcedAspectRatio']);
          }
        }
        if (((document['fullscreenElement'] || document['mozFullScreenElement'] ||
          document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
          document['webkitCurrentFullScreenElement']) === canvas.parentNode) && (typeof screen != 'undefined')) {
          var factor = Math.min(screen.width / w, screen.height / h);
          w = Math.round(w * factor);
          h = Math.round(h * factor);
        }
        if (Browser.resizeCanvas) {
          wNative = w;
          hNative = h;
        }
        const wNativeScaled = Math.floor(wNative * scale);
        const hNativeScaled = Math.floor(hNative * scale);
        if (canvas.width  != wNativeScaled) canvas.width  = wNativeScaled;
        if (canvas.height != hNativeScaled) canvas.height = hNativeScaled;
        if (typeof canvas.style != 'undefined') {
          if (!GLFW.isCSSScalingEnabled()) {
            canvas.style.setProperty( "width", wNative + "px", "important");
            canvas.style.setProperty("height", hNative + "px", "important");
          } else {
            canvas.style.removeProperty( "width");
            canvas.style.removeProperty("height");
          }
        }
      },
  calculateMouseCoords(pageX, pageY) {
        // Calculate the movement based on the changes
        // in the coordinates.
        const rect = Module["canvas"].getBoundingClientRect();
  
        // Neither .scrollX or .pageXOffset are defined in a spec, but
        // we prefer .scrollX because it is currently in a spec draft.
        // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
        var scrollX = ((typeof window.scrollX != 'undefined') ? window.scrollX : window.pageXOffset);
        var scrollY = ((typeof window.scrollY != 'undefined') ? window.scrollY : window.pageYOffset);
        var adjustedX = pageX - (scrollX + rect.left);
        var adjustedY = pageY - (scrollY + rect.top);
  
        // getBoundingClientRect() returns dimension affected by CSS, so as a result:
        // - when CSS scaling is enabled, this will fix the mouse coordinates to match the width/height of the window
        // - otherwise the CSS width/height are forced to the width/height of the GLFW window (see updateCanvasDimensions),
        //   so there is no need to adjust the position
        if (GLFW.isCSSScalingEnabled() && GLFW.active) {
          adjustedX = adjustedX * (GLFW.active.width / rect.width);
          adjustedY = adjustedY * (GLFW.active.height / rect.height);
        }
  
        return { x: adjustedX, y: adjustedY };
      },
  setWindowAttrib:(winid, attrib, value) => {
        var win = GLFW.WindowFromId(winid);
        if (!win) return;
        const isHiDPIAware = GLFW.isHiDPIAware();
        win.attributes[attrib] = value;
        if (isHiDPIAware !== GLFW.isHiDPIAware())
          GLFW.adjustCanvasDimensions();
      },
  getDevicePixelRatio() {
        return (typeof devicePixelRatio == 'number' && devicePixelRatio) || 1.0;
      },
  isHiDPIAware() {
        if (GLFW.active)
          return GLFW.active.attributes[0x0002200C] > 0; // GLFW_SCALE_TO_MONITOR
        else
          return false;
      },
  isCSSScalingEnabled() {
        return !GLFW.isHiDPIAware();
      },
  adjustCanvasDimensions() {
        if (GLFW.active) {
          Browser.updateCanvasDimensions(Module['canvas'], GLFW.active.width, GLFW.active.height);
          Browser.updateResizeListeners();
        }
      },
  getHiDPIScale() {
        return GLFW.isHiDPIAware() ? GLFW.scale : 1.0;
      },
  onDevicePixelRatioChange() {
        GLFW.onWindowContentScaleChanged(GLFW.getDevicePixelRatio());
        GLFW.adjustCanvasDimensions();
      },
  GLFW2ParamToGLFW3Param:(param) => {
        var table = {
          0x00030001:0, // GLFW_MOUSE_CURSOR
          0x00030002:0, // GLFW_STICKY_KEYS
          0x00030003:0, // GLFW_STICKY_MOUSE_BUTTONS
          0x00030004:0, // GLFW_SYSTEM_KEYS
          0x00030005:0, // GLFW_KEY_REPEAT
          0x00030006:0, // GLFW_AUTO_POLL_EVENTS
          0x00020001:0, // GLFW_OPENED
          0x00020002:0, // GLFW_ACTIVE
          0x00020003:0, // GLFW_ICONIFIED
          0x00020004:0, // GLFW_ACCELERATED
          0x00020005:0x00021001, // GLFW_RED_BITS
          0x00020006:0x00021002, // GLFW_GREEN_BITS
          0x00020007:0x00021003, // GLFW_BLUE_BITS
          0x00020008:0x00021004, // GLFW_ALPHA_BITS
          0x00020009:0x00021005, // GLFW_DEPTH_BITS
          0x0002000A:0x00021006, // GLFW_STENCIL_BITS
          0x0002000B:0x0002100F, // GLFW_REFRESH_RATE
          0x0002000C:0x00021007, // GLFW_ACCUM_RED_BITS
          0x0002000D:0x00021008, // GLFW_ACCUM_GREEN_BITS
          0x0002000E:0x00021009, // GLFW_ACCUM_BLUE_BITS
          0x0002000F:0x0002100A, // GLFW_ACCUM_ALPHA_BITS
          0x00020010:0x0002100B, // GLFW_AUX_BUFFERS
          0x00020011:0x0002100C, // GLFW_STEREO
          0x00020012:0, // GLFW_WINDOW_NO_RESIZE
          0x00020013:0x0002100D, // GLFW_FSAA_SAMPLES
          0x00020014:0x00022002, // GLFW_OPENGL_VERSION_MAJOR
          0x00020015:0x00022003, // GLFW_OPENGL_VERSION_MINOR
          0x00020016:0x00022006, // GLFW_OPENGL_FORWARD_COMPAT
          0x00020017:0x00022007, // GLFW_OPENGL_DEBUG_CONTEXT
          0x00020018:0x00022008, // GLFW_OPENGL_PROFILE
        };
        return table[param];
      },
  };
  /** @constructor */
  function GLFW_Window(id, width, height, framebufferWidth, framebufferHeight, title, monitor, share) {
        this.id = id;
        this.x = 0;
        this.y = 0;
        this.fullscreen = false; // Used to determine if app in fullscreen mode
        this.storedX = 0; // Used to store X before fullscreen
        this.storedY = 0; // Used to store Y before fullscreen
        this.width = width;
        this.height = height;
        this.framebufferWidth = framebufferWidth;
        this.framebufferHeight = framebufferHeight;
        this.storedWidth = width; // Used to store width before fullscreen
        this.storedHeight = height; // Used to store height before fullscreen
        this.title = title;
        this.monitor = monitor;
        this.share = share;
        this.attributes = Object.assign({}, GLFW.hints);
        this.inputModes = {
          0x00033001:0x00034001, // GLFW_CURSOR (GLFW_CURSOR_NORMAL)
          0x00033002:0, // GLFW_STICKY_KEYS
          0x00033003:0, // GLFW_STICKY_MOUSE_BUTTONS
        };
        this.buttons = 0;
        this.keys = new Array();
        this.domKeys = new Array();
        this.shouldClose = 0;
        this.title = null;
        this.windowPosFunc = 0; // GLFWwindowposfun
        this.windowSizeFunc = 0; // GLFWwindowsizefun
        this.windowCloseFunc = 0; // GLFWwindowclosefun
        this.windowRefreshFunc = 0; // GLFWwindowrefreshfun
        this.windowFocusFunc = 0; // GLFWwindowfocusfun
        this.windowIconifyFunc = 0; // GLFWwindowiconifyfun
        this.windowMaximizeFunc = 0; // GLFWwindowmaximizefun
        this.framebufferSizeFunc = 0; // GLFWframebuffersizefun
        this.windowContentScaleFunc = 0; // GLFWwindowcontentscalefun
        this.mouseButtonFunc = 0; // GLFWmousebuttonfun
        this.cursorPosFunc = 0; // GLFWcursorposfun
        this.cursorEnterFunc = 0; // GLFWcursorenterfun
        this.scrollFunc = 0; // GLFWscrollfun
        this.dropFunc = 0; // GLFWdropfun
        this.keyFunc = 0; // GLFWkeyfun
        this.charFunc = 0; // GLFWcharfun
        this.userptr = 0;
      }


  
  
  var _glfwInit = () => {
      if (GLFW.windows) return 1; // GL_TRUE
  
      GLFW.initialTime = GLFW.getTime();
      GLFW.defaultWindowHints();
      GLFW.windows = new Array()
      GLFW.active = null;
      GLFW.scale  = GLFW.getDevicePixelRatio();
  
      window.addEventListener("gamepadconnected", GLFW.onGamepadConnected, true);
      window.addEventListener("gamepaddisconnected", GLFW.onGamepadDisconnected, true);
      window.addEventListener("keydown", GLFW.onKeydown, true);
      window.addEventListener("keypress", GLFW.onKeyPress, true);
      window.addEventListener("keyup", GLFW.onKeyup, true);
      window.addEventListener("blur", GLFW.onBlur, true);
  
      // watch for devicePixelRatio changes
      GLFW.devicePixelRatioMQL = window.matchMedia('(resolution: ' + GLFW.getDevicePixelRatio() + 'dppx)');
      GLFW.devicePixelRatioMQL.addEventListener('change', GLFW.onDevicePixelRatioChange);
  
      Module["canvas"].addEventListener("touchmove", GLFW.onMousemove, true);
      Module["canvas"].addEventListener("touchstart", GLFW.onMouseButtonDown, true);
      Module["canvas"].addEventListener("touchcancel", GLFW.onMouseButtonUp, true);
      Module["canvas"].addEventListener("touchend", GLFW.onMouseButtonUp, true);
      Module["canvas"].addEventListener("mousemove", GLFW.onMousemove, true);
      Module["canvas"].addEventListener("mousedown", GLFW.onMouseButtonDown, true);
      Module["canvas"].addEventListener("mouseup", GLFW.onMouseButtonUp, true);
      Module["canvas"].addEventListener('wheel', GLFW.onMouseWheel, true);
      Module["canvas"].addEventListener('mousewheel', GLFW.onMouseWheel, true);
      Module["canvas"].addEventListener('mouseenter', GLFW.onMouseenter, true);
      Module["canvas"].addEventListener('mouseleave', GLFW.onMouseleave, true);
      Module["canvas"].addEventListener('drop', GLFW.onDrop, true);
      Module["canvas"].addEventListener('dragover', GLFW.onDragover, true);
  
      // Overriding implementation to account for HiDPI
      Browser.requestFullscreen = GLFW.requestFullscreen;
      Browser.calculateMouseCoords = GLFW.calculateMouseCoords;
      Browser.updateCanvasDimensions = GLFW.updateCanvasDimensions;
  
      Browser.resizeListeners.push((width, height) => {
        if (GLFW.isHiDPIAware()) {
          var canvas = Module['canvas'];
          GLFW.onCanvasResize(canvas.clientWidth, canvas.clientHeight, width, height);
        } else {
          GLFW.onCanvasResize(width, height, width, height);
        }
      });
  
      return 1; // GL_TRUE
    };
  _glfwInit.sig = 'i';

  var _glfwTerminate = () => {
      window.removeEventListener("gamepadconnected", GLFW.onGamepadConnected, true);
      window.removeEventListener("gamepaddisconnected", GLFW.onGamepadDisconnected, true);
      window.removeEventListener("keydown", GLFW.onKeydown, true);
      window.removeEventListener("keypress", GLFW.onKeyPress, true);
      window.removeEventListener("keyup", GLFW.onKeyup, true);
      window.removeEventListener("blur", GLFW.onBlur, true);
      Module["canvas"].removeEventListener("touchmove", GLFW.onMousemove, true);
      Module["canvas"].removeEventListener("touchstart", GLFW.onMouseButtonDown, true);
      Module["canvas"].removeEventListener("touchcancel", GLFW.onMouseButtonUp, true);
      Module["canvas"].removeEventListener("touchend", GLFW.onMouseButtonUp, true);
      Module["canvas"].removeEventListener("mousemove", GLFW.onMousemove, true);
      Module["canvas"].removeEventListener("mousedown", GLFW.onMouseButtonDown, true);
      Module["canvas"].removeEventListener("mouseup", GLFW.onMouseButtonUp, true);
      Module["canvas"].removeEventListener('wheel', GLFW.onMouseWheel, true);
      Module["canvas"].removeEventListener('mousewheel', GLFW.onMouseWheel, true);
      Module["canvas"].removeEventListener('mouseenter', GLFW.onMouseenter, true);
      Module["canvas"].removeEventListener('mouseleave', GLFW.onMouseleave, true);
      Module["canvas"].removeEventListener('drop', GLFW.onDrop, true);
      Module["canvas"].removeEventListener('dragover', GLFW.onDragover, true);
  
      if (GLFW.devicePixelRatioMQL)
        GLFW.devicePixelRatioMQL.removeEventListener('change', GLFW.onDevicePixelRatioChange);
  
      Module["canvas"].width = Module["canvas"].height = 1;
      GLFW.windows = null;
      GLFW.active = null;
    };
  _glfwTerminate.sig = 'v';

  var _glfwGetVersion = (major, minor, rev) => {
  
      HEAP32[((major)>>2)] = 3;
      HEAP32[((minor)>>2)] = 2;
      HEAP32[((rev)>>2)] = 1;
    };
  _glfwGetVersion.sig = 'vppp';

  var _glfwPollEvents = () => {};
  _glfwPollEvents.sig = 'v';

  var _glfwWaitEvents = () => {};
  _glfwWaitEvents.sig = 'v';

  var _glfwGetTime = () => GLFW.getTime() - GLFW.initialTime;
  _glfwGetTime.sig = 'd';

  var _glfwSetTime = (time) => {
      GLFW.initialTime = GLFW.getTime() - time;
    };
  _glfwSetTime.sig = 'vd';

  
  
  var _glfwExtensionSupported = (extension) => {
      GLFW.extensions ||= webglGetExtensions();
  
      if (GLFW.extensions.includes(extension)) return 1;
  
      // extensions from GLEmulations do not come unprefixed
      // so, try with prefix
      return (GLFW.extensions.includes("GL_" + extension));
    };
  _glfwExtensionSupported.sig = 'ip';

  
  var _glfwSwapInterval = (interval) => {
      interval = Math.abs(interval); // GLFW uses negative values to enable GLX_EXT_swap_control_tear, which we don't have, so just treat negative and positive the same.
      if (interval == 0) _emscripten_set_main_loop_timing(0, 0);
      else _emscripten_set_main_loop_timing(1, interval);
    };
  _glfwSwapInterval.sig = 'vi';

  var _glfwGetVersionString = () => {
      GLFW.versionString ||= stringToNewUTF8("3.2.1 JS WebGL Emscripten");
      return GLFW.versionString;
    };
  _glfwGetVersionString.sig = 'p';

  var _glfwSetErrorCallback = (cbfun) => {
      var prevcbfun = GLFW.errorFunc;
      GLFW.errorFunc = cbfun;
      return prevcbfun;
    };
  _glfwSetErrorCallback.sig = 'pp';

  var _glfwWaitEventsTimeout = (timeout) => {};
  _glfwWaitEventsTimeout.sig = 'vd';

  var _glfwPostEmptyEvent = () => {};
  _glfwPostEmptyEvent.sig = 'v';

  
  var _glfwGetMonitors = (count) => {
      HEAP32[((count)>>2)] = 1;
      if (!GLFW.monitors) {
        GLFW.monitors = _malloc(4);
        HEAP32[((GLFW.monitors)>>2)] = 1;
      }
      return GLFW.monitors;
    };
  _glfwGetMonitors.sig = 'pp';

  var _glfwGetPrimaryMonitor = () => 1;
  _glfwGetPrimaryMonitor.sig = 'p';

  var _glfwGetMonitorPos = (monitor, x, y) => {
      HEAP32[((x)>>2)] = 0;
      HEAP32[((y)>>2)] = 0;
    };
  _glfwGetMonitorPos.sig = 'vppp';

  var _glfwGetMonitorWorkarea = (monitor, x, y, w, h) => {
      HEAP32[((x)>>2)] = 0;
      HEAP32[((y)>>2)] = 0;
  
      HEAP32[((w)>>2)] = screen.availWidth;
      HEAP32[((h)>>2)] = screen.availHeight;
    };
  _glfwGetMonitorWorkarea.sig = 'vppppp';

  var _glfwGetMonitorPhysicalSize = (monitor, width, height) => {
      // AFAIK there is no way to do this in javascript
      // Maybe with platform specific ccalls?
      //
      // Lets report 0 now which is wrong as it can get for end user.
      HEAP32[((width)>>2)] = 0;
      HEAP32[((height)>>2)] = 0;
    };
  _glfwGetMonitorPhysicalSize.sig = 'vppp';

  var _glfwGetMonitorContentScale = (monitor, x, y) => {
      HEAPF32[((x)>>2)] = GLFW.scale;
      HEAPF32[((y)>>2)] = GLFW.scale;
    };
  _glfwGetMonitorContentScale.sig = 'vppp';

  var _glfwGetMonitorName = (mon) => {
      GLFW.monitorString ||= stringToNewUTF8("HTML5 WebGL Canvas");
      return GLFW.monitorString;
    };
  _glfwGetMonitorName.sig = 'pp';

  var _glfwSetMonitorCallback = (cbfun) => {
      var prevcbfun = GLFW.monitorFunc;
      GLFW.monitorFunc = cbfun;
      return prevcbfun;
    };
  _glfwSetMonitorCallback.sig = 'pp';

  var _glfwGetVideoModes = (monitor, count) => {
      HEAP32[((count)>>2)] = 0;
      return 0;
    };
  _glfwGetVideoModes.sig = 'ppp';

  var _glfwGetVideoMode = (monitor) => 0;
  _glfwGetVideoMode.sig = 'pp';

  var _glfwSetGamma = (monitor, gamma) => {};
  _glfwSetGamma.sig = 'vpf';

  var _glfwGetGammaRamp = (monitor) => { throw "glfwGetGammaRamp not implemented."; };
  _glfwGetGammaRamp.sig = 'pp';

  var _glfwSetGammaRamp = (monitor, ramp) => { throw "glfwSetGammaRamp not implemented."; };
  _glfwSetGammaRamp.sig = 'vpp';

  var _glfwDefaultWindowHints = () => GLFW.defaultWindowHints();
  _glfwDefaultWindowHints.sig = 'v';

  var _glfwWindowHint = (target, hint) => {
      GLFW.hints[target] = hint;
    };
  _glfwWindowHint.sig = 'vii';

  var _glfwWindowHintString = (hint, value) => {
      // from glfw docs -> we just ignore this.
      // Some hints are platform specific.  These may be set on any platform but they
      // will only affect their specific platform.  Other platforms will ignore them.
    };
  _glfwWindowHintString.sig = 'vip';

  var _glfwCreateWindow = (width, height, title, monitor, share) => GLFW.createWindow(width, height, title, monitor, share);
  _glfwCreateWindow.sig = 'piippp';

  var _glfwDestroyWindow = (winid) => GLFW.destroyWindow(winid);
  _glfwDestroyWindow.sig = 'vp';

  var _glfwWindowShouldClose = (winid) => {
      var win = GLFW.WindowFromId(winid);
      if (!win) return 0;
      return win.shouldClose;
    };
  _glfwWindowShouldClose.sig = 'ip';

  var _glfwSetWindowShouldClose = (winid, value) => {
      var win = GLFW.WindowFromId(winid);
      if (!win) return;
      win.shouldClose = value;
    };
  _glfwSetWindowShouldClose.sig = 'vpi';

  var _glfwSetWindowTitle = (winid, title) => GLFW.setWindowTitle(winid, title);
  _glfwSetWindowTitle.sig = 'vpp';

  var _glfwGetWindowPos = (winid, x, y) => GLFW.getWindowPos(winid, x, y);
  _glfwGetWindowPos.sig = 'vppp';

  var _glfwSetWindowPos = (winid, x, y) => GLFW.setWindowPos(winid, x, y);
  _glfwSetWindowPos.sig = 'vpii';

  var _glfwGetWindowSize = (winid, width, height) => GLFW.getWindowSize(winid, width, height);
  _glfwGetWindowSize.sig = 'vppp';

  var _glfwSetWindowSize = (winid, width, height) => GLFW.setWindowSize(winid, width, height);
  _glfwSetWindowSize.sig = 'vpii';

  var _glfwGetFramebufferSize = (winid, width, height) => {
      var ww = 0;
      var wh = 0;
  
      var win = GLFW.WindowFromId(winid);
      if (win) {
        ww = win.framebufferWidth;
        wh = win.framebufferHeight;
      }
  
      if (width) {
        HEAP32[((width)>>2)] = ww;
      }
  
      if (height) {
        HEAP32[((height)>>2)] = wh;
      }
    };
  _glfwGetFramebufferSize.sig = 'vppp';

  var _glfwGetWindowContentScale = (winid, x, y) => {
      // winid doesn't matter. all windows will use same scale anyway.
      // hope i used this makeSetValue correctly
      HEAPF32[((x)>>2)] = GLFW.scale;
      HEAPF32[((y)>>2)] = GLFW.scale;
    };
  _glfwGetWindowContentScale.sig = 'vppp';

  var _glfwGetWindowOpacity = (winid) => 1.0;
  _glfwGetWindowOpacity.sig = 'fp';

  var _glfwSetWindowOpacity = (winid, opacity) => { /* error */ };
  _glfwSetWindowOpacity.sig = 'vpf';

  var _glfwIconifyWindow = (winid) => {
    };
  _glfwIconifyWindow.sig = 'vp';

  var _glfwRestoreWindow = (winid) => {
    };
  _glfwRestoreWindow.sig = 'vp';

  var _glfwShowWindow = (winid) => {};
  _glfwShowWindow.sig = 'vp';

  var _glfwHideWindow = (winid) => {};
  _glfwHideWindow.sig = 'vp';

  var _glfwGetWindowMonitor = (winid) => {
      var win = GLFW.WindowFromId(winid);
      if (!win) return 0;
      return win.monitor;
    };
  _glfwGetWindowMonitor.sig = 'pp';

  var _glfwGetWindowAttrib = (winid, attrib) => {
      var win = GLFW.WindowFromId(winid);
      if (!win) return 0;
      return win.attributes[attrib];
    };
  _glfwGetWindowAttrib.sig = 'ipi';

  var _glfwSetWindowAttrib = (winid, attrib, value) => GLFW.setWindowAttrib(winid, attrib, value);
  _glfwSetWindowAttrib.sig = 'vpii';

  var _glfwSetWindowUserPointer = (winid, ptr) => {
      var win = GLFW.WindowFromId(winid);
      if (!win) return;
      win.userptr = ptr;
    };
  _glfwSetWindowUserPointer.sig = 'vpp';

  var _glfwGetWindowUserPointer = (winid) => {
      var win = GLFW.WindowFromId(winid);
      if (!win) return 0;
      return win.userptr;
    };
  _glfwGetWindowUserPointer.sig = 'pp';

  var _glfwSetWindowPosCallback = (winid, cbfun) => {
      var win = GLFW.WindowFromId(winid);
      if (!win) return null;
      var prevcbfun = win.windowPosFunc;
      win.windowPosFunc = cbfun;
      return prevcbfun;
    };
  _glfwSetWindowPosCallback.sig = 'ppp';

  var _glfwSetWindowSizeCallback = (winid, cbfun) => GLFW.setWindowSizeCallback(winid, cbfun);
  _glfwSetWindowSizeCallback.sig = 'ppp';

  var _glfwSetWindowCloseCallback = (winid, cbfun) => GLFW.setWindowCloseCallback(winid, cbfun);
  _glfwSetWindowCloseCallback.sig = 'ppp';

  var _glfwSetWindowRefreshCallback = (winid, cbfun) => GLFW.setWindowRefreshCallback(winid, cbfun);
  _glfwSetWindowRefreshCallback.sig = 'ppp';

  var _glfwSetWindowFocusCallback = (winid, cbfun) => {
      var win = GLFW.WindowFromId(winid);
      if (!win) return null;
      var prevcbfun = win.windowFocusFunc;
      win.windowFocusFunc = cbfun;
      return prevcbfun;
    };
  _glfwSetWindowFocusCallback.sig = 'ppp';

  var _glfwSetWindowIconifyCallback = (winid, cbfun) => {
      var win = GLFW.WindowFromId(winid);
      if (!win) return null;
      var prevcbfun = win.windowIconifyFunc;
      win.windowIconifyFunc = cbfun;
      return prevcbfun;
    };
  _glfwSetWindowIconifyCallback.sig = 'ppp';

  var _glfwSetWindowMaximizeCallback = (winid, cbfun) => {
      var win = GLFW.WindowFromId(winid);
      if (!win) return null;
      var prevcbfun = win.windowMaximizeFunc;
      win.windowMaximizeFunc = cbfun;
      return prevcbfun;
    };
  _glfwSetWindowMaximizeCallback.sig = 'ppp';

  var _glfwSetWindowIcon = (winid, count, images) => {};
  _glfwSetWindowIcon.sig = 'vpip';

  var _glfwSetWindowSizeLimits = (winid, minwidth, minheight, maxwidth, maxheight) => {};
  _glfwSetWindowSizeLimits.sig = 'vpiiii';

  var _glfwSetWindowAspectRatio = (winid, numer, denom) => {};
  _glfwSetWindowAspectRatio.sig = 'vpii';

  var _glfwGetWindowFrameSize = (winid, left, top, right, bottom) => { throw "glfwGetWindowFrameSize not implemented."; };
  _glfwGetWindowFrameSize.sig = 'vppppp';

  var _glfwMaximizeWindow = (winid) => {};
  _glfwMaximizeWindow.sig = 'vp';

  var _glfwFocusWindow = (winid) => {};
  _glfwFocusWindow.sig = 'vp';

  var _glfwRequestWindowAttention = (winid) => {};
  _glfwRequestWindowAttention.sig = 'vp';

  var _glfwSetWindowMonitor = (winid, monitor, xpos, ypos, width, height, refreshRate) => { throw "glfwSetWindowMonitor not implemented."; };
  _glfwSetWindowMonitor.sig = 'vppiiiii';

  var _glfwCreateCursor = (image, xhot, yhot) => {};
  _glfwCreateCursor.sig = 'ppii';

  var _glfwCreateStandardCursor = (shape) => {};
  _glfwCreateStandardCursor.sig = 'pi';

  var _glfwDestroyCursor = (cursor) => {};
  _glfwDestroyCursor.sig = 'vp';

  var _glfwSetCursor = (winid, cursor) => {};
  _glfwSetCursor.sig = 'vpp';

  var _glfwSetFramebufferSizeCallback = (winid, cbfun) => {
      var win = GLFW.WindowFromId(winid);
      if (!win) return null;
      var prevcbfun = win.framebufferSizeFunc;
      win.framebufferSizeFunc = cbfun;
      return prevcbfun;
    };
  _glfwSetFramebufferSizeCallback.sig = 'ppp';

  var _glfwSetWindowContentScaleCallback = (winid, cbfun) => {
      var win = GLFW.WindowFromId(winid);
      if (!win) return null;
      var prevcbfun = win.windowContentScaleFunc;
      win.windowContentScaleFunc = cbfun;
      return prevcbfun;
    };
  _glfwSetWindowContentScaleCallback.sig = 'ppp';

  var _glfwGetInputMode = (winid, mode) => {
      var win = GLFW.WindowFromId(winid);
      if (!win) return;
  
      switch (mode) {
        case 0x00033001: { // GLFW_CURSOR
          if (Browser.pointerLock) {
            win.inputModes[mode] = 0x00034003; // GLFW_CURSOR_DISABLED
          } else {
            win.inputModes[mode] = 0x00034001; // GLFW_CURSOR_NORMAL
          }
        }
      }
  
      return win.inputModes[mode];
    };
  _glfwGetInputMode.sig = 'ipi';

  var _glfwSetInputMode = (winid, mode, value) => {
      GLFW.setInputMode(winid, mode, value);
    };
  _glfwSetInputMode.sig = 'vpii';

  var _glfwRawMouseMotionSupported = () => 0;
  _glfwRawMouseMotionSupported.sig = 'i';

  var _glfwGetKey = (winid, key) => GLFW.getKey(winid, key);
  _glfwGetKey.sig = 'ipi';

  var _glfwGetKeyName = (key, scancode) => { throw "glfwGetKeyName not implemented."; };
  _glfwGetKeyName.sig = 'pii';

  var _glfwGetKeyScancode = (key) => { throw "glfwGetKeyScancode not implemented."; };
  _glfwGetKeyScancode.sig = 'ii';

  var _glfwGetMouseButton = (winid, button) => GLFW.getMouseButton(winid, button);
  _glfwGetMouseButton.sig = 'ipi';

  var _glfwGetCursorPos = (winid, x, y) => GLFW.getCursorPos(winid, x, y);
  _glfwGetCursorPos.sig = 'vppp';

  var _glfwSetCursorPos = (winid, x, y) => GLFW.setCursorPos(winid, x, y);
  _glfwSetCursorPos.sig = 'vpdd';

  var _glfwSetKeyCallback = (winid, cbfun) => GLFW.setKeyCallback(winid, cbfun);
  _glfwSetKeyCallback.sig = 'ppp';

  var _glfwSetCharCallback = (winid, cbfun) => GLFW.setCharCallback(winid, cbfun);
  _glfwSetCharCallback.sig = 'ppp';

  var _glfwSetCharModsCallback = (winid, cbfun) => { throw "glfwSetCharModsCallback not implemented."; };
  _glfwSetCharModsCallback.sig = 'ppp';

  var _glfwSetMouseButtonCallback = (winid, cbfun) => GLFW.setMouseButtonCallback(winid, cbfun);
  _glfwSetMouseButtonCallback.sig = 'ppp';

  var _glfwSetCursorPosCallback = (winid, cbfun) => GLFW.setCursorPosCallback(winid, cbfun);
  _glfwSetCursorPosCallback.sig = 'ppp';

  var _glfwSetCursorEnterCallback = (winid, cbfun) => {
      var win = GLFW.WindowFromId(winid);
      if (!win) return null;
      var prevcbfun = win.cursorEnterFunc;
      win.cursorEnterFunc = cbfun;
      return prevcbfun;
    };
  _glfwSetCursorEnterCallback.sig = 'ppp';

  var _glfwSetScrollCallback = (winid, cbfun) => GLFW.setScrollCallback(winid, cbfun);
  _glfwSetScrollCallback.sig = 'ppp';

  var _glfwVulkanSupported = () => 0;
  _glfwVulkanSupported.sig = 'i';

  var _glfwSetDropCallback = (winid, cbfun) => GLFW.setDropCallback(winid, cbfun);
  _glfwSetDropCallback.sig = 'ppp';

  var _glfwGetTimerValue = () => { throw "glfwGetTimerValue is not implemented."; };
  _glfwGetTimerValue.sig = 'j';

  var _glfwGetTimerFrequency = () => { throw "glfwGetTimerFrequency is not implemented."; };
  _glfwGetTimerFrequency.sig = 'j';

  var _glfwGetRequiredInstanceExtensions = (count) => { throw "glfwGetRequiredInstanceExtensions is not implemented."; };
  _glfwGetRequiredInstanceExtensions.sig = 'pp';

  var _glfwJoystickPresent = (joy) => {
      GLFW.refreshJoysticks();
  
      return GLFW.joys[joy] !== undefined;
    };
  _glfwJoystickPresent.sig = 'ii';

  var _glfwGetJoystickAxes = (joy, count) => {
      GLFW.refreshJoysticks();
  
      var state = GLFW.joys[joy];
      if (!state || !state.axes) {
        HEAP32[((count)>>2)] = 0;
        return;
      }
  
      HEAP32[((count)>>2)] = state.axesCount;
      return state.axes;
    };
  _glfwGetJoystickAxes.sig = 'pip';

  var _glfwGetJoystickButtons = (joy, count) => {
      GLFW.refreshJoysticks();
  
      var state = GLFW.joys[joy];
      if (!state || !state.buttons) {
        HEAP32[((count)>>2)] = 0;
        return;
      }
  
      HEAP32[((count)>>2)] = state.buttonsCount;
      return state.buttons;
    };
  _glfwGetJoystickButtons.sig = 'pip';

  var _glfwGetJoystickHats = (joy, count) => { throw "glfwGetJoystickHats is not implemented"; };
  _glfwGetJoystickHats.sig = 'pip';

  var _glfwGetJoystickName = (joy) => {
      if (GLFW.joys[joy]) {
        return GLFW.joys[joy].id;
      }
      return 0;
    };
  _glfwGetJoystickName.sig = 'pi';

  var _glfwGetJoystickGUID = (jid) => { throw "glfwGetJoystickGUID not implemented"; };
  _glfwGetJoystickGUID.sig = 'pi';

  var _glfwSetJoystickUserPointer = (jid, ptr) => { throw "glfwSetJoystickUserPointer not implemented"; };
  _glfwSetJoystickUserPointer.sig = 'vip';

  var _glfwGetJoystickUserPointer = (jid) => { throw "glfwGetJoystickUserPointer not implemented"; };
  _glfwGetJoystickUserPointer.sig = 'pi';

  var _glfwJoystickIsGamepad = (jid) => { throw "glfwJoystickIsGamepad not implemented"; };
  _glfwJoystickIsGamepad.sig = 'ii';

  var _glfwSetJoystickCallback = (cbfun) => GLFW.setJoystickCallback(cbfun);
  _glfwSetJoystickCallback.sig = 'pp';

  var _glfwSetClipboardString = (win, string) => {};
  _glfwSetClipboardString.sig = 'vpp';

  var _glfwGetClipboardString = (win) => {};
  _glfwGetClipboardString.sig = 'pp';

  var _glfwMakeContextCurrent = (winid) => {};
  _glfwMakeContextCurrent.sig = 'vp';

  var _glfwGetCurrentContext = () => GLFW.active ? GLFW.active.id : 0;
  _glfwGetCurrentContext.sig = 'p';

  var _glfwSwapBuffers = (winid) => GLFW.swapBuffers(winid);
  _glfwSwapBuffers.sig = 'vp';








  var _glGetBufferSubData = (target, offset, size, data) => {
      if (!data) {
        // GLES2 specification does not specify how to behave if data is a null pointer. Since calling this function does not make sense
        // if data == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      size && GLctx.getBufferSubData(target, offset, HEAPU8, data, size);
    };
  _glGetBufferSubData.sig = 'vippp';









































































  var _glDrawArraysInstancedBaseInstanceWEBGL = (mode, first, count, instanceCount, baseInstance) => {
      GLctx.dibvbi['drawArraysInstancedBaseInstanceWEBGL'](mode, first, count, instanceCount, baseInstance);
    };
  _glDrawArraysInstancedBaseInstanceWEBGL.sig = 'viiiii';

  var _glDrawArraysInstancedBaseInstance = _glDrawArraysInstancedBaseInstanceWEBGL;
  _glDrawArraysInstancedBaseInstance.sig = 'viiiii';

  var _glDrawArraysInstancedBaseInstanceANGLE = _glDrawArraysInstancedBaseInstanceWEBGL;

  var _glDrawElementsInstancedBaseVertexBaseInstanceWEBGL = (mode, count, type, offset, instanceCount, baseVertex, baseinstance) => {
      GLctx.dibvbi['drawElementsInstancedBaseVertexBaseInstanceWEBGL'](mode, count, type, offset, instanceCount, baseVertex, baseinstance);
    };
  _glDrawElementsInstancedBaseVertexBaseInstanceWEBGL.sig = 'viiiiiii';

  var _glDrawElementsInstancedBaseVertexBaseInstanceANGLE = _glDrawElementsInstancedBaseVertexBaseInstanceWEBGL;


  var _emscripten_webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance = (ctx) =>
      webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance(GL.contexts[ctx].GLctx);
  _emscripten_webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance.sig = 'ip';

  var _glMultiDrawArraysInstancedBaseInstanceWEBGL = (mode, firsts, counts, instanceCounts, baseInstances, drawCount) => {
      GLctx.mdibvbi['multiDrawArraysInstancedBaseInstanceWEBGL'](
        mode,
        HEAP32,
        ((firsts)>>2),
        HEAP32,
        ((counts)>>2),
        HEAP32,
        ((instanceCounts)>>2),
        HEAPU32,
        ((baseInstances)>>2),
        drawCount);
    };
  _glMultiDrawArraysInstancedBaseInstanceWEBGL.sig = 'viiiiii';

  var _glMultiDrawArraysInstancedBaseInstanceANGLE = _glMultiDrawArraysInstancedBaseInstanceWEBGL;

  var _glMultiDrawElementsInstancedBaseVertexBaseInstanceWEBGL = (mode, counts, type, offsets, instanceCounts, baseVertices, baseInstances, drawCount) => {
      GLctx.mdibvbi['multiDrawElementsInstancedBaseVertexBaseInstanceWEBGL'](
        mode,
        HEAP32,
        ((counts)>>2),
        type,
        HEAP32,
        ((offsets)>>2),
        HEAP32,
        ((instanceCounts)>>2),
        HEAP32,
        ((baseVertices)>>2),
        HEAPU32,
        ((baseInstances)>>2),
        drawCount);
    };
  _glMultiDrawElementsInstancedBaseVertexBaseInstanceWEBGL.sig = 'viiiiiiii';

  var _glMultiDrawElementsInstancedBaseVertexBaseInstanceANGLE = _glMultiDrawElementsInstancedBaseVertexBaseInstanceWEBGL;


  var _emscripten_webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance = (ctx) =>
      webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance(GL.contexts[ctx].GLctx);
  _emscripten_webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance.sig = 'ip';






















  var _emscripten_glGetBufferSubData = _glGetBufferSubData;
  _emscripten_glGetBufferSubData.sig = 'vippp';








































































  var _emscripten_glDrawArraysInstancedBaseInstanceWEBGL = _glDrawArraysInstancedBaseInstanceWEBGL;

  var _emscripten_glDrawArraysInstancedBaseInstance = _glDrawArraysInstancedBaseInstance;
  _emscripten_glDrawArraysInstancedBaseInstance.sig = 'viiiii';

  var _emscripten_glDrawArraysInstancedBaseInstanceANGLE = _glDrawArraysInstancedBaseInstanceANGLE;

  var _emscripten_glDrawElementsInstancedBaseVertexBaseInstanceWEBGL = _glDrawElementsInstancedBaseVertexBaseInstanceWEBGL;

  var _emscripten_glDrawElementsInstancedBaseVertexBaseInstanceANGLE = _glDrawElementsInstancedBaseVertexBaseInstanceANGLE;

  var _emscripten_glMultiDrawArraysInstancedBaseInstanceWEBGL = _glMultiDrawArraysInstancedBaseInstanceWEBGL;

  var _emscripten_glMultiDrawArraysInstancedBaseInstanceANGLE = _glMultiDrawArraysInstancedBaseInstanceANGLE;

  var _emscripten_glMultiDrawElementsInstancedBaseVertexBaseInstanceWEBGL = _glMultiDrawElementsInstancedBaseVertexBaseInstanceWEBGL;

  var _emscripten_glMultiDrawElementsInstancedBaseVertexBaseInstanceANGLE = _glMultiDrawElementsInstancedBaseVertexBaseInstanceANGLE;
















  var ALLOC_NORMAL = 0;

  var ALLOC_STACK = 1;

  
  
  
  var allocate = (slab, allocator) => {
      var ret;
  
      if (allocator == ALLOC_STACK) {
        ret = stackAlloc(slab.length);
      } else {
        ret = _malloc(slab.length);
      }
  
      if (!slab.subarray && !slab.slice) {
        slab = new Uint8Array(slab);
      }
      HEAPU8.set(slab, ret);
      return ret;
    };

  
  /** @deprecated @param {boolean=} dontAddNull */
  var writeStringToMemory = (string, buffer, dontAddNull) => {
      warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');
  
      var /** @type {number} */ lastChar, /** @type {number} */ end;
      if (dontAddNull) {
        // stringToUTF8 always appends null. If we don't want to do that, remember the
        // character that existed at the location where the null will be placed, and restore
        // that after the write (below).
        end = buffer + lengthBytesUTF8(string);
        lastChar = HEAP8[end];
      }
      stringToUTF8(string, buffer, Infinity);
      if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
    };

  /** @param {boolean=} dontAddNull */
  var writeAsciiToMemory = (str, buffer, dontAddNull) => {
      for (var i = 0; i < str.length; ++i) {
        HEAP8[buffer++] = str.charCodeAt(i);
      }
      // Null-terminate the string
      if (!dontAddNull) HEAP8[buffer] = 0;
    };

  var allocateUTF8 = stringToNewUTF8;

  var allocateUTF8OnStack = stringToUTF8OnStack;

  var setErrNo = (value) => {
      HEAP32[((___errno_location())>>2)] = value;
      return value;
    };

  
  
  
  
  var demangle = (func) => {
      // If demangle has failed before, stop demangling any further function names
      // This avoids an infinite recursion with malloc()->abort()->stackTrace()->demangle()->malloc()->...
      demangle.recursionGuard = (demangle.recursionGuard|0)+1;
      if (demangle.recursionGuard > 1) return func;
      return withStackSave(() => {
        try {
          var s = func;
          if (s.startsWith('__Z'))
            s = s.substr(1);
          var buf = stringToUTF8OnStack(s);
          var status = stackAlloc(4);
          var ret = ___cxa_demangle(buf, 0, 0, status);
          if (HEAP32[((status)>>2)] === 0 && ret) {
            return UTF8ToString(ret);
          }
          // otherwise, libcxxabi failed
        } catch(e) {
        } finally {
          _free(ret);
          if (demangle.recursionGuard < 2) --demangle.recursionGuard;
        }
        // failure when using libcxxabi, don't demangle
        return func;
      });
    };

  var stackTrace = () => {
      var js = jsStackTrace();
      if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
      return js;
    };


  var printErr = err;

  var _emscripten_is_main_browser_thread = () =>
      !ENVIRONMENT_IS_WORKER;








  var tupleRegistrations = {
  };

  var structRegistrations = {
  };






  
  
  var getTypeName = (type) => {
      var ptr = ___getTypeName(type);
      var rv = readLatin1String(ptr);
      _free(ptr);
      return rv;
    };

  var getFunctionName = (signature) => {
      signature = signature.trim();
      const argsIndex = signature.indexOf("(");
      if (argsIndex !== -1) {
        return signature.substr(0, argsIndex);
      } else {
        return signature;
      }
    };

  var getFunctionArgsName = (signature) => {
      signature = signature.trim();
      const argsIndex = signature.indexOf("(") + 1;
      if (argsIndex !== 0) {
        return signature.substr(argsIndex, signature.length - argsIndex - 1).replaceAll(" ", "").split(",").filter(n => n.length);
      } else {
        return [];
      }
    };

  var heap32VectorToArray = (count, firstElement) => {
      var array = [];
      for (var i = 0; i < count; i++) {
        // TODO(https://github.com/emscripten-core/emscripten/issues/17310):
        // Find a way to hoist the `>> 2` or `>> 3` out of this loop.
        array.push(HEAPU32[(((firstElement)+(i * 4))>>2)]);
      }
      return array;
    };

  
  
  var requireRegisteredType = (rawType, humanName) => {
      var impl = registeredTypes[rawType];
      if (undefined === impl) {
        throwBindingError(`${humanName} has unknown type ${getTypeName(rawType)}`);
      }
      return impl;
    };

  function usesDestructorStack(argTypes) {
      // Skip return value at index 0 - it's not deleted here.
      for (var i = 1; i < argTypes.length; ++i) {
        // The type does not define a destructor function - must use dynamic stack
        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {
          return true;
        }
      }
      return false;
    }

  function createJsInvokerSignature(argTypes, isClassMethodFunc, returns, isAsync) {
      const signature = [
        isClassMethodFunc ? 't' : 'f',
        returns ? 't' : 'f',
        isAsync ? 't' : 'f'
      ];
      for (let i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
        const arg = argTypes[i];
        let destructorSig = '';
        if (arg.destructorFunction === undefined) {
          destructorSig = 'u';
        } else if (arg.destructorFunction === null) {
          destructorSig = 'n';
        } else {
          destructorSig = 't';
        }
        signature.push(destructorSig);
      }
      return signature.join('');
    }

  function checkArgCount(numArgs, minArgs, maxArgs, humanName, throwBindingError) {
      if (numArgs < minArgs || numArgs > maxArgs) {
        var argCountMessage = minArgs == maxArgs ? minArgs : `${minArgs} to ${maxArgs}`;
        throwBindingError(`function ${humanName} called with ${numArgs} arguments, expected ${argCountMessage}`);
      }
    }

  function getRequiredArgCount(argTypes) {
      var requiredArgCount = argTypes.length - 2;
      for (var i = argTypes.length - 1; i >= 2; --i) {
        if (!argTypes[i].optional) {
          break;
        }
        requiredArgCount--;
      }
      return requiredArgCount;
    }

  function createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync) {
      var needsDestructorStack = usesDestructorStack(argTypes);
      var argCount = argTypes.length - 2;
      var argsList = [];
      var argsListWired = ['fn'];
      if (isClassMethodFunc) {
        argsListWired.push('thisWired');
      }
      for (var i = 0; i < argCount; ++i) {
        argsList.push(`arg${i}`)
        argsListWired.push(`arg${i}Wired`)
      }
      argsList = argsList.join(',')
      argsListWired = argsListWired.join(',')
  
      var invokerFnBody = `return function (${argsList}) {\n`;
  
      if (needsDestructorStack) {
        invokerFnBody += "var destructors = [];\n";
      }
  
      var dtorStack = needsDestructorStack ? "destructors" : "null";
      var args1 = ["humanName", "throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
  
      if (isClassMethodFunc) {
        invokerFnBody += `var thisWired = classParam['toWireType'](${dtorStack}, this);\n`;
      }
  
      for (var i = 0; i < argCount; ++i) {
        invokerFnBody += `var arg${i}Wired = argType${i}['toWireType'](${dtorStack}, arg${i});\n`;
        args1.push(`argType${i}`);
      }
  
      invokerFnBody += (returns || isAsync ? "var rv = ":"") + `invoker(${argsListWired});\n`;
  
      var returnVal = returns ? "rv" : "";
  
      if (needsDestructorStack) {
        invokerFnBody += "runDestructors(destructors);\n";
      } else {
        for (var i = isClassMethodFunc?1:2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.
          var paramName = (i === 1 ? "thisWired" : ("arg"+(i - 2)+"Wired"));
          if (argTypes[i].destructorFunction !== null) {
            invokerFnBody += `${paramName}_dtor(${paramName});\n`;
            args1.push(`${paramName}_dtor`);
          }
        }
      }
  
      if (returns) {
        invokerFnBody += "var ret = retType['fromWireType'](rv);\n" +
                         "return ret;\n";
      } else {
      }
  
      invokerFnBody += "}\n";
  
      return [args1, invokerFnBody];
    }

  var createNamedFunction = (name, body) => Object.defineProperty(body, 'name', {
      value: name
    });
  var extendError = (baseErrorType, errorName) => {
      var errorClass = createNamedFunction(errorName, function(message) {
        this.name = errorName;
        this.message = message;
  
        var stack = (new Error(message)).stack;
        if (stack !== undefined) {
          this.stack = this.toString() + '\n' +
              stack.replace(/^Error(:[^\n]*)?\n/, '');
        }
      });
      errorClass.prototype = Object.create(baseErrorType.prototype);
      errorClass.prototype.constructor = errorClass;
      errorClass.prototype.toString = function() {
        if (this.message === undefined) {
          return this.name;
        } else {
          return `${this.name}: ${this.message}`;
        }
      };
  
      return errorClass;
    };
  var UnboundTypeError;

  var PureVirtualError;



  var EmValOptionalType = Object.assign({optional: true}, EmValType);;

  
  
  
  var throwUnboundTypeError = (message, types) => {
      var unboundTypes = [];
      var seen = {};
      function visit(type) {
        if (seen[type]) {
          return;
        }
        if (registeredTypes[type]) {
          return;
        }
        if (typeDependencies[type]) {
          typeDependencies[type].forEach(visit);
          return;
        }
        unboundTypes.push(type);
        seen[type] = true;
      }
      types.forEach(visit);
  
      throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([', ']));
    };

  var ensureOverloadTable = (proto, methodName, humanName) => {
      if (undefined === proto[methodName].overloadTable) {
        var prevFunc = proto[methodName];
        // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.
        proto[methodName] = function(...args) {
          // TODO This check can be removed in -O3 level "unsafe" optimizations.
          if (!proto[methodName].overloadTable.hasOwnProperty(args.length)) {
            throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`);
          }
          return proto[methodName].overloadTable[args.length].apply(this, args);
        };
        // Move the previous function into the overload table.
        proto[methodName].overloadTable = [];
        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
      }
    };

  
  /** @param {number=} numArguments */
  var exposePublicSymbol = (name, value, numArguments) => {
      if (Module.hasOwnProperty(name)) {
        if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {
          throwBindingError(`Cannot register public name '${name}' twice`);
        }
  
        // We are exposing a function with the same name as an existing function. Create an overload table and a function selector
        // that routes between the two.
        ensureOverloadTable(Module, name, name);
        if (Module[name].overloadTable.hasOwnProperty(numArguments)) {
          throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);
        }
        // Add the new function into the overload table.
        Module[name].overloadTable[numArguments] = value;
      } else {
        Module[name] = value;
        Module[name].argCount = numArguments;
      }
    };

  /** @param {number=} numArguments */
  var replacePublicSymbol = (name, value, numArguments) => {
      if (!Module.hasOwnProperty(name)) {
        throwInternalError('Replacing nonexistent public symbol');
      }
      // If there's an overload table for this symbol, replace the symbol in the overload table instead.
      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
        Module[name].overloadTable[numArguments] = value;
      } else {
        Module[name] = value;
        Module[name].argCount = numArguments;
      }
    };




  var registeredInstances = {
  };

  var getBasestPointer = (class_, ptr) => {
      if (ptr === undefined) {
          throwBindingError('ptr should not be undefined');
      }
      while (class_.baseClass) {
          ptr = class_.upcast(ptr);
          class_ = class_.baseClass;
      }
      return ptr;
    };

  
  
  var registerInheritedInstance = (class_, ptr, instance) => {
      ptr = getBasestPointer(class_, ptr);
      if (registeredInstances.hasOwnProperty(ptr)) {
          throwBindingError(`Tried to register registered instance: ${ptr}`);
      } else {
          registeredInstances[ptr] = instance;
      }
    };

  
  
  var unregisterInheritedInstance = (class_, ptr) => {
      ptr = getBasestPointer(class_, ptr);
      if (registeredInstances.hasOwnProperty(ptr)) {
          delete registeredInstances[ptr];
      } else {
          throwBindingError(`Tried to unregister unregistered instance: ${ptr}`);
      }
    };

  
  var getInheritedInstance = (class_, ptr) => {
      ptr = getBasestPointer(class_, ptr);
      return registeredInstances[ptr];
    };

  var getInheritedInstanceCount = () => Object.keys(registeredInstances).length;

  var getLiveInheritedInstances = () => {
      var rv = [];
      for (var k in registeredInstances) {
        if (registeredInstances.hasOwnProperty(k)) {
          rv.push(registeredInstances[k]);
        }
      }
      return rv;
    };

  var registeredPointers = {
  };





  var enumReadValueFromPointer = (name, width, signed) => {
      switch (width) {
          case 1: return signed ?
              function(pointer) { return this['fromWireType'](HEAP8[pointer]) } :
              function(pointer) { return this['fromWireType'](HEAPU8[pointer]) };
          case 2: return signed ?
              function(pointer) { return this['fromWireType'](HEAP16[((pointer)>>1)]) } :
              function(pointer) { return this['fromWireType'](HEAPU16[((pointer)>>1)]) };
          case 4: return signed ?
              function(pointer) { return this['fromWireType'](HEAP32[((pointer)>>2)]) } :
              function(pointer) { return this['fromWireType'](HEAPU32[((pointer)>>2)]) };
          default:
              throw new TypeError(`invalid integer width (${width}): ${name}`);
      }
    };









  var __embind_register_user_type = (rawType, name) => {
      __embind_register_emval(rawType);
    };
  __embind_register_user_type.sig = 'vpp';

  
  var __embind_register_optional = (rawOptionalType, rawType) => {
      registerType(rawOptionalType, EmValOptionalType);
    };
  __embind_register_optional.sig = 'vpp';


  var runDestructors = (destructors) => {
      while (destructors.length) {
        var ptr = destructors.pop();
        var del = destructors.pop();
        del(ptr);
      }
    };

  function newFunc(constructor, argumentList) {
      if (!(constructor instanceof Function)) {
        throw new TypeError(`new_ called with constructor type ${typeof(constructor)} which is not a function`);
      }
      /*
       * Previously, the following line was just:
       *   function dummy() {};
       * Unfortunately, Chrome was preserving 'dummy' as the object's name, even
       * though at creation, the 'dummy' has the correct constructor name.  Thus,
       * objects created with IMVU.new would show up in the debugger as 'dummy',
       * which isn't very helpful.  Using IMVU.createNamedFunction addresses the
       * issue.  Doubly-unfortunately, there's no way to write a test for this
       * behavior.  -NRD 2013.02.22
       */
      var dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function(){});
      dummy.prototype = constructor.prototype;
      var obj = new dummy;
  
      var r = constructor.apply(obj, argumentList);
      return (r instanceof Object) ? r : obj;
    }

  
  
  
  
  
  function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, /** boolean= */ isAsync) {
      // humanName: a human-readable string name for the function to be generated.
      // argTypes: An array that contains the embind type objects for all types in the function signature.
      //    argTypes[0] is the type object for the function return value.
      //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.
      //    argTypes[2...] are the actual function parameters.
      // classType: The embind type object for the class to be bound, or null if this is not a method of a class.
      // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.
      // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.
      // isAsync: Optional. If true, returns an async function. Async bindings are only supported with JSPI.
      var argCount = argTypes.length;
  
      if (argCount < 2) {
        throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
      }
  
      var isClassMethodFunc = (argTypes[1] !== null && classType !== null);
  
      // Free functions with signature "void function()" do not need an invoker that marshalls between wire types.
  // TODO: This omits argument count check - enable only at -O3 or similar.
  //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == "void" && !isClassMethodFunc) {
  //       return FUNCTION_TABLE[fn];
  //    }
  
      // Determine if we need to use a dynamic stack to store the destructors for the function parameters.
      // TODO: Remove this completely once all function invokers are being dynamically generated.
      var needsDestructorStack = usesDestructorStack(argTypes);
  
      var returns = (argTypes[0].name !== "void");
  
      var expectedArgCount = argCount - 2;
    // Builld the arguments that will be passed into the closure around the invoker
    // function.
    var closureArgs = [humanName, throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
    for (var i = 0; i < argCount - 2; ++i) {
      closureArgs.push(argTypes[i+2]);
    }
    if (!needsDestructorStack) {
      for (var i = isClassMethodFunc?1:2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.
        if (argTypes[i].destructorFunction !== null) {
          closureArgs.push(argTypes[i].destructorFunction);
        }
      }
    }
  
    let [args, invokerFnBody] = createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync);
    args.push(invokerFnBody);
    var invokerFn = newFunc(Function, args)(...closureArgs);
      return createNamedFunction(humanName, invokerFn);
    }

  
  
  var embind__requireFunction = (signature, rawFunction) => {
      signature = readLatin1String(signature);
  
      function makeDynCaller() {
        return getWasmTableEntry(rawFunction);
      }
  
      var fp = makeDynCaller();
      if (typeof fp != "function") {
          throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);
      }
      return fp;
    };

  
  
  
  
  
  
  
  
  var __embind_register_function = (name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync, isNonnullReturn) => {
      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      name = readLatin1String(name);
      name = getFunctionName(name);
  
      rawInvoker = embind__requireFunction(signature, rawInvoker);
  
      exposePublicSymbol(name, function() {
        throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes);
      }, argCount - 1);
  
      whenDependentTypesAreResolved([], argTypes, (argTypes) => {
        var invokerArgsArray = [argTypes[0] /* return value */, null /* no class 'this'*/].concat(argTypes.slice(1) /* actual params */);
        replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null /* no class 'this'*/, rawInvoker, fn, isAsync), argCount - 1);
        return [];
      });
    };
  __embind_register_function.sig = 'vpippppii';

  
  
  var __embind_register_value_array = (
      rawType,
      name,
      constructorSignature,
      rawConstructor,
      destructorSignature,
      rawDestructor
    ) => {
      tupleRegistrations[rawType] = {
        name: readLatin1String(name),
        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),
        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),
        elements: [],
      };
    };
  __embind_register_value_array.sig = 'vpppppp';

  
  var __embind_register_value_array_element = (
      rawTupleType,
      getterReturnType,
      getterSignature,
      getter,
      getterContext,
      setterArgumentType,
      setterSignature,
      setter,
      setterContext
    ) => {
      tupleRegistrations[rawTupleType].elements.push({
        getterReturnType,
        getter: embind__requireFunction(getterSignature, getter),
        getterContext,
        setterArgumentType,
        setter: embind__requireFunction(setterSignature, setter),
        setterContext,
      });
    };
  __embind_register_value_array_element.sig = 'vppppppppp';

  
  
  
  var __embind_finalize_value_array = (rawTupleType) => {
      var reg = tupleRegistrations[rawTupleType];
      delete tupleRegistrations[rawTupleType];
      var elements = reg.elements;
      var elementsLength = elements.length;
      var elementTypes = elements.map((elt) => elt.getterReturnType).
                  concat(elements.map((elt) => elt.setterArgumentType));
  
      var rawConstructor = reg.rawConstructor;
      var rawDestructor = reg.rawDestructor;
  
      whenDependentTypesAreResolved([rawTupleType], elementTypes, (elementTypes) => {
        elements.forEach((elt, i) => {
          var getterReturnType = elementTypes[i];
          var getter = elt.getter;
          var getterContext = elt.getterContext;
          var setterArgumentType = elementTypes[i + elementsLength];
          var setter = elt.setter;
          var setterContext = elt.setterContext;
          elt.read = (ptr) => getterReturnType['fromWireType'](getter(getterContext, ptr));
          elt.write = (ptr, o) => {
            var destructors = [];
            setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, o));
            runDestructors(destructors);
          };
        });
  
        return [{
          name: reg.name,
          'fromWireType': (ptr) => {
            var rv = new Array(elementsLength);
            for (var i = 0; i < elementsLength; ++i) {
              rv[i] = elements[i].read(ptr);
            }
            rawDestructor(ptr);
            return rv;
          },
          'toWireType': (destructors, o) => {
            if (elementsLength !== o.length) {
              throw new TypeError(`Incorrect number of tuple elements for ${reg.name}: expected=${elementsLength}, actual=${o.length}`);
            }
            var ptr = rawConstructor();
            for (var i = 0; i < elementsLength; ++i) {
              elements[i].write(ptr, o[i]);
            }
            if (destructors !== null) {
              destructors.push(rawDestructor, ptr);
            }
            return ptr;
          },
          argPackAdvance: GenericWireTypeSize,
          'readValueFromPointer': readPointer,
          destructorFunction: rawDestructor,
        }];
      });
    };
  __embind_finalize_value_array.sig = 'vp';

  
  
  var __embind_register_value_object = (
      rawType,
      name,
      constructorSignature,
      rawConstructor,
      destructorSignature,
      rawDestructor
    ) => {
      structRegistrations[rawType] = {
        name: readLatin1String(name),
        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),
        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),
        fields: [],
      };
    };
  __embind_register_value_object.sig = 'vpppppp';

  
  
  var __embind_register_value_object_field = (
      structType,
      fieldName,
      getterReturnType,
      getterSignature,
      getter,
      getterContext,
      setterArgumentType,
      setterSignature,
      setter,
      setterContext
    ) => {
      structRegistrations[structType].fields.push({
        fieldName: readLatin1String(fieldName),
        getterReturnType,
        getter: embind__requireFunction(getterSignature, getter),
        getterContext,
        setterArgumentType,
        setter: embind__requireFunction(setterSignature, setter),
        setterContext,
      });
    };
  __embind_register_value_object_field.sig = 'vpppppppppp';

  
  
  
  var __embind_finalize_value_object = (structType) => {
      var reg = structRegistrations[structType];
      delete structRegistrations[structType];
  
      var rawConstructor = reg.rawConstructor;
      var rawDestructor = reg.rawDestructor;
      var fieldRecords = reg.fields;
      var fieldTypes = fieldRecords.map((field) => field.getterReturnType).
                concat(fieldRecords.map((field) => field.setterArgumentType));
      whenDependentTypesAreResolved([structType], fieldTypes, (fieldTypes) => {
        var fields = {};
        fieldRecords.forEach((field, i) => {
          var fieldName = field.fieldName;
          var getterReturnType = fieldTypes[i];
          var getter = field.getter;
          var getterContext = field.getterContext;
          var setterArgumentType = fieldTypes[i + fieldRecords.length];
          var setter = field.setter;
          var setterContext = field.setterContext;
          fields[fieldName] = {
            read: (ptr) => getterReturnType['fromWireType'](getter(getterContext, ptr)),
            write: (ptr, o) => {
              var destructors = [];
              setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, o));
              runDestructors(destructors);
            }
          };
        });
  
        return [{
          name: reg.name,
          'fromWireType': (ptr) => {
            var rv = {};
            for (var i in fields) {
              rv[i] = fields[i].read(ptr);
            }
            rawDestructor(ptr);
            return rv;
          },
          'toWireType': (destructors, o) => {
            // todo: Here we have an opportunity for -O3 level "unsafe" optimizations:
            // assume all fields are present without checking.
            for (var fieldName in fields) {
              if (!(fieldName in o)) {
                throw new TypeError(`Missing field: "${fieldName}"`);
              }
            }
            var ptr = rawConstructor();
            for (fieldName in fields) {
              fields[fieldName].write(ptr, o[fieldName]);
            }
            if (destructors !== null) {
              destructors.push(rawDestructor, ptr);
            }
            return ptr;
          },
          argPackAdvance: GenericWireTypeSize,
          'readValueFromPointer': readPointer,
          destructorFunction: rawDestructor,
        }];
      });
    };
  __embind_finalize_value_object.sig = 'vp';

  
  var upcastPointer = (ptr, ptrClass, desiredClass) => {
      while (ptrClass !== desiredClass) {
        if (!ptrClass.upcast) {
          throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);
        }
        ptr = ptrClass.upcast(ptr);
        ptrClass = ptrClass.baseClass;
      }
      return ptr;
    };
  /** @suppress {globalThis} */
  function genericPointerToWireType(destructors, handle) {
      var ptr;
      if (handle === null) {
        if (this.isReference) {
          throwBindingError(`null is not a valid ${this.name}`);
        }
  
        if (this.isSmartPointer) {
          ptr = this.rawConstructor();
          if (destructors !== null) {
            destructors.push(this.rawDestructor, ptr);
          }
          return ptr;
        } else {
          return 0;
        }
      }
  
      if (!handle || !handle.$$) {
        throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
      }
      if (!handle.$$.ptr) {
        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
      }
      if (!this.isConst && handle.$$.ptrType.isConst) {
        throwBindingError(`Cannot convert argument of type ${(handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name)} to parameter type ${this.name}`);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
  
      if (this.isSmartPointer) {
        // TODO: this is not strictly true
        // We could support BY_EMVAL conversions from raw pointers to smart pointers
        // because the smart pointer can hold a reference to the handle
        if (undefined === handle.$$.smartPtr) {
          throwBindingError('Passing raw pointer to smart pointer is illegal');
        }
  
        switch (this.sharingPolicy) {
          case 0: // NONE
            // no upcasting
            if (handle.$$.smartPtrType === this) {
              ptr = handle.$$.smartPtr;
            } else {
              throwBindingError(`Cannot convert argument of type ${(handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name)} to parameter type ${this.name}`);
            }
            break;
  
          case 1: // INTRUSIVE
            ptr = handle.$$.smartPtr;
            break;
  
          case 2: // BY_EMVAL
            if (handle.$$.smartPtrType === this) {
              ptr = handle.$$.smartPtr;
            } else {
              var clonedHandle = handle['clone']();
              ptr = this.rawShare(
                ptr,
                Emval.toHandle(() => clonedHandle['delete']())
              );
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
              }
            }
            break;
  
          default:
            throwBindingError('Unsupporting sharing policy');
        }
      }
      return ptr;
    }

  
  /** @suppress {globalThis} */
  function constNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
        if (this.isReference) {
          throwBindingError(`null is not a valid ${this.name}`);
        }
        return 0;
      }
  
      if (!handle.$$) {
        throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
      }
      if (!handle.$$.ptr) {
        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }

  
  /** @suppress {globalThis} */
  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
        if (this.isReference) {
          throwBindingError(`null is not a valid ${this.name}`);
        }
        return 0;
      }
  
      if (!handle.$$) {
        throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
      }
      if (!handle.$$.ptr) {
        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
      }
      if (handle.$$.ptrType.isConst) {
          throwBindingError(`Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }

  
  
  
  /** @constructor
      @param {*=} pointeeType,
      @param {*=} sharingPolicy,
      @param {*=} rawGetPointee,
      @param {*=} rawConstructor,
      @param {*=} rawShare,
      @param {*=} rawDestructor,
       */
  function RegisteredPointer(
      name,
      registeredClass,
      isReference,
      isConst,
  
      // smart pointer properties
      isSmartPointer,
      pointeeType,
      sharingPolicy,
      rawGetPointee,
      rawConstructor,
      rawShare,
      rawDestructor
    ) {
      this.name = name;
      this.registeredClass = registeredClass;
      this.isReference = isReference;
      this.isConst = isConst;
  
      // smart pointer properties
      this.isSmartPointer = isSmartPointer;
      this.pointeeType = pointeeType;
      this.sharingPolicy = sharingPolicy;
      this.rawGetPointee = rawGetPointee;
      this.rawConstructor = rawConstructor;
      this.rawShare = rawShare;
      this.rawDestructor = rawDestructor;
  
      if (!isSmartPointer && registeredClass.baseClass === undefined) {
        if (isConst) {
          this['toWireType'] = constNoSmartPtrRawPointerToWireType;
          this.destructorFunction = null;
        } else {
          this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;
          this.destructorFunction = null;
        }
      } else {
        this['toWireType'] = genericPointerToWireType;
        // Here we must leave this.destructorFunction undefined, since whether genericPointerToWireType returns
        // a pointer that needs to be freed up is runtime-dependent, and cannot be evaluated at registration time.
        // TODO: Create an alternative mechanism that allows removing the use of var destructors = []; array in
        //       craftInvokerFunction altogether.
      }
    }
  
  
  var downcastPointer = (ptr, ptrClass, desiredClass) => {
      if (ptrClass === desiredClass) {
        return ptr;
      }
      if (undefined === desiredClass.baseClass) {
        return null; // no conversion
      }
  
      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
      if (rv === null) {
        return null;
      }
      return desiredClass.downcast(rv);
    };
  
  
  
  
  var finalizationRegistry = false;
  
  var detachFinalizer = (handle) => {};
  
  var runDestructor = ($$) => {
      if ($$.smartPtr) {
        $$.smartPtrType.rawDestructor($$.smartPtr);
      } else {
        $$.ptrType.registeredClass.rawDestructor($$.ptr);
      }
    };
  var releaseClassHandle = ($$) => {
      $$.count.value -= 1;
      var toDelete = 0 === $$.count.value;
      if (toDelete) {
        runDestructor($$);
      }
    };
  
  var attachFinalizer = (handle) => {
      if ('undefined' === typeof FinalizationRegistry) {
        attachFinalizer = (handle) => handle;
        return handle;
      }
      // If the running environment has a FinalizationRegistry (see
      // https://github.com/tc39/proposal-weakrefs), then attach finalizers
      // for class handles.  We check for the presence of FinalizationRegistry
      // at run-time, not build-time.
      finalizationRegistry = new FinalizationRegistry((info) => {
        releaseClassHandle(info.$$);
      });
      attachFinalizer = (handle) => {
        var $$ = handle.$$;
        var hasSmartPtr = !!$$.smartPtr;
        if (hasSmartPtr) {
          // We should not call the destructor on raw pointers in case other code expects the pointee to live
          var info = { $$: $$ };
          finalizationRegistry.register(handle, info, handle);
        }
        return handle;
      };
      detachFinalizer = (handle) => finalizationRegistry.unregister(handle);
      return attachFinalizer(handle);
    };
  var makeClassHandle = (prototype, record) => {
      if (!record.ptrType || !record.ptr) {
        throwInternalError('makeClassHandle requires ptr and ptrType');
      }
      var hasSmartPtrType = !!record.smartPtrType;
      var hasSmartPtr = !!record.smartPtr;
      if (hasSmartPtrType !== hasSmartPtr) {
        throwInternalError('Both smartPtrType and smartPtr must be specified');
      }
      record.count = { value: 1 };
      return attachFinalizer(Object.create(prototype, {
        $$: {
          value: record,
          writable: true,
        },
      }));
    };
  /** @suppress {globalThis} */
  function RegisteredPointer_fromWireType(ptr) {
      // ptr is a raw pointer (or a raw smartpointer)
  
      // rawPointer is a maybe-null raw pointer
      var rawPointer = this.getPointee(ptr);
      if (!rawPointer) {
        this.destructor(ptr);
        return null;
      }
  
      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
      if (undefined !== registeredInstance) {
        // JS object has been neutered, time to repopulate it
        if (0 === registeredInstance.$$.count.value) {
          registeredInstance.$$.ptr = rawPointer;
          registeredInstance.$$.smartPtr = ptr;
          return registeredInstance['clone']();
        } else {
          // else, just increment reference count on existing object
          // it already has a reference to the smart pointer
          var rv = registeredInstance['clone']();
          this.destructor(ptr);
          return rv;
        }
      }
  
      function makeDefaultHandle() {
        if (this.isSmartPointer) {
          return makeClassHandle(this.registeredClass.instancePrototype, {
            ptrType: this.pointeeType,
            ptr: rawPointer,
            smartPtrType: this,
            smartPtr: ptr,
          });
        } else {
          return makeClassHandle(this.registeredClass.instancePrototype, {
            ptrType: this,
            ptr,
          });
        }
      }
  
      var actualType = this.registeredClass.getActualType(rawPointer);
      var registeredPointerRecord = registeredPointers[actualType];
      if (!registeredPointerRecord) {
        return makeDefaultHandle.call(this);
      }
  
      var toType;
      if (this.isConst) {
        toType = registeredPointerRecord.constPointerType;
      } else {
        toType = registeredPointerRecord.pointerType;
      }
      var dp = downcastPointer(
          rawPointer,
          this.registeredClass,
          toType.registeredClass);
      if (dp === null) {
        return makeDefaultHandle.call(this);
      }
      if (this.isSmartPointer) {
        return makeClassHandle(toType.registeredClass.instancePrototype, {
          ptrType: toType,
          ptr: dp,
          smartPtrType: this,
          smartPtr: ptr,
        });
      } else {
        return makeClassHandle(toType.registeredClass.instancePrototype, {
          ptrType: toType,
          ptr: dp,
        });
      }
    }
  
  var init_RegisteredPointer = () => {
      Object.assign(RegisteredPointer.prototype, {
        getPointee(ptr) {
          if (this.rawGetPointee) {
            ptr = this.rawGetPointee(ptr);
          }
          return ptr;
        },
        destructor(ptr) {
          this.rawDestructor?.(ptr);
        },
        argPackAdvance: GenericWireTypeSize,
        'readValueFromPointer': readPointer,
        'fromWireType': RegisteredPointer_fromWireType,
      });
    };






  var detachFinalizer_deps = ["$finalizationRegistry"];




  /** @constructor */
  function ClassHandle() {
    }
  
  var shallowCopyInternalPointer = (o) => {
      return {
        count: o.count,
        deleteScheduled: o.deleteScheduled,
        preservePointerOnDelete: o.preservePointerOnDelete,
        ptr: o.ptr,
        ptrType: o.ptrType,
        smartPtr: o.smartPtr,
        smartPtrType: o.smartPtrType,
      };
    };
  
  var throwInstanceAlreadyDeleted = (obj) => {
      function getInstanceTypeName(handle) {
        return handle.$$.ptrType.registeredClass.name;
      }
      throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');
    };
  
  
  
  
  
  var deletionQueue = [];
  var flushPendingDeletes = () => {
      while (deletionQueue.length) {
        var obj = deletionQueue.pop();
        obj.$$.deleteScheduled = false;
        obj['delete']();
      }
    };
  
  var delayFunction;
  var init_ClassHandle = () => {
      Object.assign(ClassHandle.prototype, {
        "isAliasOf"(other) {
          if (!(this instanceof ClassHandle)) {
            return false;
          }
          if (!(other instanceof ClassHandle)) {
            return false;
          }
  
          var leftClass = this.$$.ptrType.registeredClass;
          var left = this.$$.ptr;
          other.$$ = /** @type {Object} */ (other.$$);
          var rightClass = other.$$.ptrType.registeredClass;
          var right = other.$$.ptr;
  
          while (leftClass.baseClass) {
            left = leftClass.upcast(left);
            leftClass = leftClass.baseClass;
          }
  
          while (rightClass.baseClass) {
            right = rightClass.upcast(right);
            rightClass = rightClass.baseClass;
          }
  
          return leftClass === rightClass && left === right;
        },
  
        "clone"() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
  
          if (this.$$.preservePointerOnDelete) {
            this.$$.count.value += 1;
            return this;
          } else {
            var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
              $$: {
                value: shallowCopyInternalPointer(this.$$),
              }
            }));
  
            clone.$$.count.value += 1;
            clone.$$.deleteScheduled = false;
            return clone;
          }
        },
  
        "delete"() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
  
          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError('Object already scheduled for deletion');
          }
  
          detachFinalizer(this);
          releaseClassHandle(this.$$);
  
          if (!this.$$.preservePointerOnDelete) {
            this.$$.smartPtr = undefined;
            this.$$.ptr = undefined;
          }
        },
  
        "isDeleted"() {
          return !this.$$.ptr;
        },
  
        "deleteLater"() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError('Object already scheduled for deletion');
          }
          deletionQueue.push(this);
          if (deletionQueue.length === 1 && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
          this.$$.deleteScheduled = true;
          return this;
        },
      });
    };






  
  
  var setDelayFunction = (fn) => {
      delayFunction = fn;
      if (deletionQueue.length && delayFunction) {
        delayFunction(flushPendingDeletes);
      }
    };

  /** @constructor */
  function RegisteredClass(name,
                               constructor,
                               instancePrototype,
                               rawDestructor,
                               baseClass,
                               getActualType,
                               upcast,
                               downcast) {
      this.name = name;
      this.constructor = constructor;
      this.instancePrototype = instancePrototype;
      this.rawDestructor = rawDestructor;
      this.baseClass = baseClass;
      this.getActualType = getActualType;
      this.upcast = upcast;
      this.downcast = downcast;
      this.pureVirtualFunctions = [];
    }


  
  
  
  
  
  var char_0 = 48;
  
  var char_9 = 57;
  var makeLegalFunctionName = (name) => {
      name = name.replace(/[^a-zA-Z0-9_]/g, '$');
      var f = name.charCodeAt(0);
      if (f >= char_0 && f <= char_9) {
        return `_${name}`;
      }
      return name;
    };
  
  
  
  
  
  
  
  var __embind_register_class = (rawType,
                             rawPointerType,
                             rawConstPointerType,
                             baseClassRawType,
                             getActualTypeSignature,
                             getActualType,
                             upcastSignature,
                             upcast,
                             downcastSignature,
                             downcast,
                             name,
                             destructorSignature,
                             rawDestructor) => {
      name = readLatin1String(name);
      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
      upcast &&= embind__requireFunction(upcastSignature, upcast);
      downcast &&= embind__requireFunction(downcastSignature, downcast);
      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
      var legalFunctionName = makeLegalFunctionName(name);
  
      exposePublicSymbol(legalFunctionName, function() {
        // this code cannot run if baseClassRawType is zero
        throwUnboundTypeError(`Cannot construct ${name} due to unbound types`, [baseClassRawType]);
      });
  
      whenDependentTypesAreResolved(
        [rawType, rawPointerType, rawConstPointerType],
        baseClassRawType ? [baseClassRawType] : [],
        (base) => {
          base = base[0];
  
          var baseClass;
          var basePrototype;
          if (baseClassRawType) {
            baseClass = base.registeredClass;
            basePrototype = baseClass.instancePrototype;
          } else {
            basePrototype = ClassHandle.prototype;
          }
  
          var constructor = createNamedFunction(name, function(...args) {
            if (Object.getPrototypeOf(this) !== instancePrototype) {
              throw new BindingError("Use 'new' to construct " + name);
            }
            if (undefined === registeredClass.constructor_body) {
              throw new BindingError(name + " has no accessible constructor");
            }
            var body = registeredClass.constructor_body[args.length];
            if (undefined === body) {
              throw new BindingError(`Tried to invoke ctor of ${name} with invalid number of parameters (${args.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);
            }
            return body.apply(this, args);
          });
  
          var instancePrototype = Object.create(basePrototype, {
            constructor: { value: constructor },
          });
  
          constructor.prototype = instancePrototype;
  
          var registeredClass = new RegisteredClass(name,
                                                    constructor,
                                                    instancePrototype,
                                                    rawDestructor,
                                                    baseClass,
                                                    getActualType,
                                                    upcast,
                                                    downcast);
  
          if (registeredClass.baseClass) {
            // Keep track of class hierarchy. Used to allow sub-classes to inherit class functions.
            registeredClass.baseClass.__derivedClasses ??= [];
  
            registeredClass.baseClass.__derivedClasses.push(registeredClass);
          }
  
          var referenceConverter = new RegisteredPointer(name,
                                                         registeredClass,
                                                         true,
                                                         false,
                                                         false);
  
          var pointerConverter = new RegisteredPointer(name + '*',
                                                       registeredClass,
                                                       false,
                                                       false,
                                                       false);
  
          var constPointerConverter = new RegisteredPointer(name + ' const*',
                                                            registeredClass,
                                                            false,
                                                            true,
                                                            false);
  
          registeredPointers[rawType] = {
            pointerType: pointerConverter,
            constPointerType: constPointerConverter
          };
  
          replacePublicSymbol(legalFunctionName, constructor);
  
          return [referenceConverter, pointerConverter, constPointerConverter];
        }
      );
    };
  __embind_register_class.sig = 'vppppppppppppp';

  
  
  
  
  
  
  var __embind_register_class_constructor = (
      rawClassType,
      argCount,
      rawArgTypesAddr,
      invokerSignature,
      invoker,
      rawConstructor
    ) => {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      invoker = embind__requireFunction(invokerSignature, invoker);
      var args = [rawConstructor];
      var destructors = [];
  
      whenDependentTypesAreResolved([], [rawClassType], (classType) => {
        classType = classType[0];
        var humanName = `constructor ${classType.name}`;
  
        if (undefined === classType.registeredClass.constructor_body) {
          classType.registeredClass.constructor_body = [];
        }
        if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {
          throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount-1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
        }
        classType.registeredClass.constructor_body[argCount - 1] = () => {
          throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);
        };
  
        whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {
          // Insert empty slot for context type (argTypes[1]).
          argTypes.splice(1, 0, null);
          classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);
          return [];
        });
        return [];
      });
    };
  __embind_register_class_constructor.sig = 'vpipppp';



  
  var validateThis = (this_, classType, humanName) => {
      if (!(this_ instanceof Object)) {
        throwBindingError(`${humanName} with invalid "this": ${this_}`);
      }
      if (!(this_ instanceof classType.registeredClass.constructor)) {
        throwBindingError(`${humanName} incompatible with "this" of type ${this_.constructor.name}`);
      }
      if (!this_.$$.ptr) {
        throwBindingError(`cannot call emscripten binding method ${humanName} on deleted object`);
      }
  
      // todo: kill this
      return upcastPointer(this_.$$.ptr,
                           this_.$$.ptrType.registeredClass,
                           classType.registeredClass);
    };

  
  
  
  
  
  
  var __embind_register_class_function = (rawClassType,
                                      methodName,
                                      argCount,
                                      rawArgTypesAddr, // [ReturnType, ThisType, Args...]
                                      invokerSignature,
                                      rawInvoker,
                                      context,
                                      isPureVirtual,
                                      isAsync,
                                      isNonnullReturn) => {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      methodName = readLatin1String(methodName);
      methodName = getFunctionName(methodName);
      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
  
      whenDependentTypesAreResolved([], [rawClassType], (classType) => {
        classType = classType[0];
        var humanName = `${classType.name}.${methodName}`;
  
        if (methodName.startsWith("@@")) {
          methodName = Symbol[methodName.substring(2)];
        }
  
        if (isPureVirtual) {
          classType.registeredClass.pureVirtualFunctions.push(methodName);
        }
  
        function unboundTypesHandler() {
          throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);
        }
  
        var proto = classType.registeredClass.instancePrototype;
        var method = proto[methodName];
        if (undefined === method || (undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2)) {
          // This is the first overload to be registered, OR we are replacing a
          // function in the base class with a function in the derived class.
          unboundTypesHandler.argCount = argCount - 2;
          unboundTypesHandler.className = classType.name;
          proto[methodName] = unboundTypesHandler;
        } else {
          // There was an existing function with the same name registered. Set up
          // a function overload routing table.
          ensureOverloadTable(proto, methodName, humanName);
          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
        }
  
        whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {
          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);
  
          // Replace the initial unbound-handler-stub function with the
          // appropriate member function, now that all types are resolved. If
          // multiple overloads are registered for this function, the function
          // goes into an overload table.
          if (undefined === proto[methodName].overloadTable) {
            // Set argCount in case an overload is registered later
            memberFunction.argCount = argCount - 2;
            proto[methodName] = memberFunction;
          } else {
            proto[methodName].overloadTable[argCount - 2] = memberFunction;
          }
  
          return [];
        });
        return [];
      });
    };
  __embind_register_class_function.sig = 'vppippppiii';

  
  
  
  
  
  
  var __embind_register_class_property = (classType,
                                      fieldName,
                                      getterReturnType,
                                      getterSignature,
                                      getter,
                                      getterContext,
                                      setterArgumentType,
                                      setterSignature,
                                      setter,
                                      setterContext) => {
      fieldName = readLatin1String(fieldName);
      getter = embind__requireFunction(getterSignature, getter);
  
      whenDependentTypesAreResolved([], [classType], (classType) => {
        classType = classType[0];
        var humanName = `${classType.name}.${fieldName}`;
        var desc = {
          get() {
            throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [getterReturnType, setterArgumentType]);
          },
          enumerable: true,
          configurable: true
        };
        if (setter) {
          desc.set = () => throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [getterReturnType, setterArgumentType]);
        } else {
          desc.set = (v) => throwBindingError(humanName + ' is a read-only property');
        }
  
        Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);
  
        whenDependentTypesAreResolved(
          [],
          (setter ? [getterReturnType, setterArgumentType] : [getterReturnType]),
        (types) => {
          var getterReturnType = types[0];
          var desc = {
            get() {
              var ptr = validateThis(this, classType, humanName + ' getter');
              return getterReturnType['fromWireType'](getter(getterContext, ptr));
            },
            enumerable: true
          };
  
          if (setter) {
            setter = embind__requireFunction(setterSignature, setter);
            var setterArgumentType = types[1];
            desc.set = function(v) {
              var ptr = validateThis(this, classType, humanName + ' setter');
              var destructors = [];
              setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, v));
              runDestructors(destructors);
            };
          }
  
          Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);
          return [];
        });
  
        return [];
      });
    };
  __embind_register_class_property.sig = 'vpppppppppp';

  
  
  
  
  
  
  
  var __embind_register_class_class_function = (rawClassType,
                                            methodName,
                                            argCount,
                                            rawArgTypesAddr,
                                            invokerSignature,
                                            rawInvoker,
                                            fn,
                                            isAsync,
                                            isNonnullReturn) => {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      methodName = readLatin1String(methodName);
      methodName = getFunctionName(methodName);
      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
      whenDependentTypesAreResolved([], [rawClassType], (classType) => {
        classType = classType[0];
        var humanName = `${classType.name}.${methodName}`;
  
        function unboundTypesHandler() {
          throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);
        }
  
        if (methodName.startsWith("@@")) {
          methodName = Symbol[methodName.substring(2)];
        }
  
        var proto = classType.registeredClass.constructor;
        if (undefined === proto[methodName]) {
          // This is the first function to be registered with this name.
          unboundTypesHandler.argCount = argCount-1;
          proto[methodName] = unboundTypesHandler;
        } else {
          // There was an existing function with the same name registered. Set up
          // a function overload routing table.
          ensureOverloadTable(proto, methodName, humanName);
          proto[methodName].overloadTable[argCount-1] = unboundTypesHandler;
        }
  
        whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {
          // Replace the initial unbound-types-handler stub with the proper
          // function. If multiple overloads are registered, the function handlers
          // go into an overload table.
          var invokerArgsArray = [argTypes[0] /* return value */, null /* no class 'this'*/].concat(argTypes.slice(1) /* actual params */);
          var func = craftInvokerFunction(humanName, invokerArgsArray, null /* no class 'this'*/, rawInvoker, fn, isAsync);
          if (undefined === proto[methodName].overloadTable) {
            func.argCount = argCount-1;
            proto[methodName] = func;
          } else {
            proto[methodName].overloadTable[argCount-1] = func;
          }
  
          if (classType.registeredClass.__derivedClasses) {
            for (const derivedClass of classType.registeredClass.__derivedClasses) {
              if (!derivedClass.constructor.hasOwnProperty(methodName)) {
                // TODO: Add support for overloads
                derivedClass.constructor[methodName] = func;
              }
            }
          }
  
          return [];
        });
        return [];
      });
    };
  __embind_register_class_class_function.sig = 'vppippppii';

  
  
  
  
  
  
  var __embind_register_class_class_property = (rawClassType,
                                            fieldName,
                                            rawFieldType,
                                            rawFieldPtr,
                                            getterSignature,
                                            getter,
                                            setterSignature,
                                            setter) => {
      fieldName = readLatin1String(fieldName);
      getter = embind__requireFunction(getterSignature, getter);
  
      whenDependentTypesAreResolved([], [rawClassType], (classType) => {
        classType = classType[0];
        var humanName = `${classType.name}.${fieldName}`;
        var desc = {
          get() {
            throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [rawFieldType]);
          },
          enumerable: true,
          configurable: true
        };
        if (setter) {
          desc.set = () => {
            throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [rawFieldType]);
          };
        } else {
          desc.set = (v) => {
            throwBindingError(`${humanName} is a read-only property`);
          };
        }
  
        Object.defineProperty(classType.registeredClass.constructor, fieldName, desc);
  
        whenDependentTypesAreResolved([], [rawFieldType], (fieldType) => {
          fieldType = fieldType[0];
          var desc = {
            get() {
              return fieldType['fromWireType'](getter(rawFieldPtr));
            },
            enumerable: true
          };
  
          if (setter) {
            setter = embind__requireFunction(setterSignature, setter);
            desc.set = (v) => {
              var destructors = [];
              setter(rawFieldPtr, fieldType['toWireType'](destructors, v));
              runDestructors(destructors);
            };
          }
  
          Object.defineProperty(classType.registeredClass.constructor, fieldName, desc);
          return [];
        });
  
        return [];
      });
    };
  __embind_register_class_class_property.sig = 'vpppppppp';

  
  
  
  
  
  
  
  
  
  var __embind_create_inheriting_constructor = (constructorName, wrapperType, properties) => {
      constructorName = readLatin1String(constructorName);
      wrapperType = requireRegisteredType(wrapperType, 'wrapper');
      properties = Emval.toValue(properties);
  
      var registeredClass = wrapperType.registeredClass;
      var wrapperPrototype = registeredClass.instancePrototype;
      var baseClass = registeredClass.baseClass;
      var baseClassPrototype = baseClass.instancePrototype;
      var baseConstructor = registeredClass.baseClass.constructor;
      var ctor = createNamedFunction(constructorName, function(...args) {
        registeredClass.baseClass.pureVirtualFunctions.forEach(function(name) {
          if (this[name] === baseClassPrototype[name]) {
            throw new PureVirtualError(`Pure virtual function ${name} must be implemented in JavaScript`);
          }
        }.bind(this));
  
        Object.defineProperty(this, '__parent', {
          value: wrapperPrototype
        });
        this["__construct"](...args);
      });
  
      // It's a little nasty that we're modifying the wrapper prototype here.
  
      wrapperPrototype["__construct"] = function __construct(...args) {
        if (this === wrapperPrototype) {
          throwBindingError("Pass correct 'this' to __construct");
        }
  
        var inner = baseConstructor["implement"](this, ...args);
        detachFinalizer(inner);
        var $$ = inner.$$;
        inner["notifyOnDestruction"]();
        $$.preservePointerOnDelete = true;
        Object.defineProperties(this, { $$: {
            value: $$
        }});
        attachFinalizer(this);
        registerInheritedInstance(registeredClass, $$.ptr, this);
      };
  
      wrapperPrototype["__destruct"] = function __destruct() {
        if (this === wrapperPrototype) {
          throwBindingError("Pass correct 'this' to __destruct");
        }
  
        detachFinalizer(this);
        unregisterInheritedInstance(registeredClass, this.$$.ptr);
      };
  
      ctor.prototype = Object.create(wrapperPrototype);
      Object.assign(ctor.prototype, properties);
      return Emval.toHandle(ctor);
    };
  __embind_create_inheriting_constructor.sig = 'pppp';




  
  
  var __embind_register_smart_ptr = (rawType,
                                 rawPointeeType,
                                 name,
                                 sharingPolicy,
                                 getPointeeSignature,
                                 rawGetPointee,
                                 constructorSignature,
                                 rawConstructor,
                                 shareSignature,
                                 rawShare,
                                 destructorSignature,
                                 rawDestructor) => {
      name = readLatin1String(name);
      rawGetPointee = embind__requireFunction(getPointeeSignature, rawGetPointee);
      rawConstructor = embind__requireFunction(constructorSignature, rawConstructor);
      rawShare = embind__requireFunction(shareSignature, rawShare);
      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
  
      whenDependentTypesAreResolved([rawType], [rawPointeeType], (pointeeType) => {
        pointeeType = pointeeType[0];
  
        var registeredPointer = new RegisteredPointer(name,
                                                      pointeeType.registeredClass,
                                                      false,
                                                      false,
                                                      // smart pointer properties
                                                      true,
                                                      pointeeType,
                                                      sharingPolicy,
                                                      rawGetPointee,
                                                      rawConstructor,
                                                      rawShare,
                                                      rawDestructor);
        return [registeredPointer];
      });
    };
  __embind_register_smart_ptr.sig = 'vpppipppppppp';

  
  
  
  /** @suppress {globalThis} */
  var __embind_register_enum = (rawType, name, size, isSigned) => {
      name = readLatin1String(name);
  
      function ctor() {}
      ctor.values = {};
  
      registerType(rawType, {
        name,
        constructor: ctor,
        'fromWireType': function(c) {
          return this.constructor.values[c];
        },
        'toWireType': (destructors, c) => c.value,
        argPackAdvance: GenericWireTypeSize,
        'readValueFromPointer': enumReadValueFromPointer(name, size, isSigned),
        destructorFunction: null,
      });
      exposePublicSymbol(name, ctor);
    };
  __embind_register_enum.sig = 'vpppi';

  
  
  var __embind_register_enum_value = (rawEnumType, name, enumValue) => {
      var enumType = requireRegisteredType(rawEnumType, 'enum');
      name = readLatin1String(name);
  
      var Enum = enumType.constructor;
  
      var Value = Object.create(enumType.constructor.prototype, {
        value: {value: enumValue},
        constructor: {value: createNamedFunction(`${enumType.name}_${name}`, function() {})},
      });
      Enum.values[enumValue] = Value;
      Enum[name] = Value;
    };
  __embind_register_enum_value.sig = 'vppi';

  
  var __embind_register_constant = (name, type, value) => {
      name = readLatin1String(name);
      whenDependentTypesAreResolved([], [type], (type) => {
        type = type[0];
        Module[name] = type['fromWireType'](value);
        return [];
      });
    };
  __embind_register_constant.sig = 'vppd';






  
  var __emval_register_symbol = (address) => {
      emval_symbols[address] = readLatin1String(address);
    };
  __emval_register_symbol.sig = 'vp';





  
  
  var __emval_run_destructors = (handle) => {
      var destructors = Emval.toValue(handle);
      runDestructors(destructors);
      __emval_decref(handle);
    };
  __emval_run_destructors.sig = 'vp';

  var __emval_new_array = () => Emval.toHandle([]);
  __emval_new_array.sig = 'p';

  var __emval_new_array_from_memory_view = (view) => {
      view = Emval.toValue(view);
      // using for..loop is faster than Array.from
      var a = new Array(view.length);
      for (var i = 0; i < view.length; i++) a[i] = view[i];
      return Emval.toHandle(a);
    };
  __emval_new_array_from_memory_view.sig = 'pp';

  var __emval_new_object = () => Emval.toHandle({});
  __emval_new_object.sig = 'p';


  
  var __emval_new_u8string = (v) => Emval.toHandle(UTF8ToString(v));
  __emval_new_u8string.sig = 'pp';

  var __emval_new_u16string = (v) => Emval.toHandle(UTF16ToString(v));
  __emval_new_u16string.sig = 'pp';

  
  var __emval_take_value = (type, arg) => {
      type = requireRegisteredType(type, '_emval_take_value');
      var v = type['readValueFromPointer'](arg);
      return Emval.toHandle(v);
    };
  __emval_take_value.sig = 'ppp';

  var emval_get_global = () => {
      if (typeof globalThis == 'object') {
        return globalThis;
      }
      return (function(){
        return Function;
      })()('return this')();
    };

  
  
  var __emval_get_global = (name) => {
      if (name===0) {
        return Emval.toHandle(emval_get_global());
      } else {
        name = getStringOrSymbol(name);
        return Emval.toHandle(emval_get_global()[name]);
      }
    };
  __emval_get_global.sig = 'pp';

  
  var __emval_get_module_property = (name) => {
      name = getStringOrSymbol(name);
      return Emval.toHandle(Module[name]);
    };
  __emval_get_module_property.sig = 'pp';

  var __emval_get_property = (handle, key) => {
      handle = Emval.toValue(handle);
      key = Emval.toValue(key);
      return Emval.toHandle(handle[key]);
    };
  __emval_get_property.sig = 'ppp';


  var emval_returnValue = (returnType, destructorsRef, handle) => {
      var destructors = [];
      var result = returnType['toWireType'](destructors, handle);
      if (destructors.length) {
        // void, primitives and any other types w/o destructors don't need to allocate a handle
        HEAPU32[((destructorsRef)>>2)] = Emval.toHandle(destructors);
      }
      return result;
    };

  
  
  var __emval_as = (handle, returnType, destructorsRef) => {
      handle = Emval.toValue(handle);
      returnType = requireRegisteredType(returnType, 'emval::as');
      return emval_returnValue(returnType, destructorsRef, handle);
    };
  __emval_as.sig = 'dppp';

  
  var __emval_as_int64 = (handle, returnType) => {
      handle = Emval.toValue(handle);
      returnType = requireRegisteredType(returnType, 'emval::as');
      return returnType['toWireType'](null, handle);
    };
  __emval_as_int64.sig = 'jpp';

  
  var __emval_as_uint64 = (handle, returnType) => {
      handle = Emval.toValue(handle);
      returnType = requireRegisteredType(returnType, 'emval::as');
      return returnType['toWireType'](null, handle);
    };
  __emval_as_uint64.sig = 'jpp';

  var __emval_equals = (first, second) => {
      first = Emval.toValue(first);
      second = Emval.toValue(second);
      return first == second;
    };
  __emval_equals.sig = 'ipp';




  var __emval_not = (object) => {
      object = Emval.toValue(object);
      return !object;
    };
  __emval_not.sig = 'ip';

  var emval_methodCallers = [];
  
  var __emval_call = (caller, handle, destructorsRef, args) => {
      caller = emval_methodCallers[caller];
      handle = Emval.toValue(handle);
      return caller(null, handle, destructorsRef, args);
    };
  __emval_call.sig = 'dpppp';

  var emval_lookupTypes = (argCount, argTypes) => {
      var a = new Array(argCount);
      for (var i = 0; i < argCount; ++i) {
        a[i] = requireRegisteredType(HEAPU32[(((argTypes)+(i * 4))>>2)],
                                     "parameter " + i);
      }
      return a;
    };


  var emval_addMethodCaller = (caller) => {
      var id = emval_methodCallers.length;
      emval_methodCallers.push(caller);
      return id;
    };

  var reflectConstruct = Reflect.construct;

  
  
  
  
  
  var __emval_get_method_caller = (argCount, argTypes, kind) => {
      var types = emval_lookupTypes(argCount, argTypes);
      var retType = types.shift();
      argCount--; // remove the shifted off return type
  
      var functionBody =
        `return function (obj, func, destructorsRef, args) {\n`;
  
      var offset = 0;
      var argsList = []; // 'obj?, arg0, arg1, arg2, ... , argN'
      if (kind === /* FUNCTION */ 0) {
        argsList.push("obj");
      }
      var params = ["retType"];
      var args = [retType];
      for (var i = 0; i < argCount; ++i) {
        argsList.push("arg" + i);
        params.push("argType" + i);
        args.push(types[i]);
        functionBody +=
          `  var arg${i} = argType${i}.readValueFromPointer(args${offset ? "+" + offset : ""});\n`;
        offset += types[i].argPackAdvance;
      }
      var invoker = kind === /* CONSTRUCTOR */ 1 ? 'new func' : 'func.call';
      functionBody +=
        `  var rv = ${invoker}(${argsList.join(", ")});\n`;
      if (!retType.isVoid) {
        params.push("emval_returnValue");
        args.push(emval_returnValue);
        functionBody +=
          "  return emval_returnValue(retType, destructorsRef, rv);\n";
      }
      functionBody +=
        "};\n";
  
      params.push(functionBody);
      var invokerFunction = newFunc(Function, params)(...args);
      var functionName = `methodCaller<(${types.map(t => t.name).join(', ')}) => ${retType.name}>`;
      return emval_addMethodCaller(createNamedFunction(functionName, invokerFunction));
    };
  __emval_get_method_caller.sig = 'pipi';

  
  
  var __emval_call_method = (caller, objHandle, methodName, destructorsRef, args) => {
      caller = emval_methodCallers[caller];
      objHandle = Emval.toValue(objHandle);
      methodName = getStringOrSymbol(methodName);
      return caller(objHandle, objHandle[methodName], destructorsRef, args);
    };
  __emval_call_method.sig = 'dppppp';

  var __emval_typeof = (handle) => {
      handle = Emval.toValue(handle);
      return Emval.toHandle(typeof handle);
    };
  __emval_typeof.sig = 'pp';

  var __emval_instanceof = (object, constructor) => {
      object = Emval.toValue(object);
      constructor = Emval.toValue(constructor);
      return object instanceof constructor;
    };
  __emval_instanceof.sig = 'ipp';

  var __emval_is_number = (handle) => {
      handle = Emval.toValue(handle);
      return typeof handle == 'number';
    };
  __emval_is_number.sig = 'ip';

  var __emval_is_string = (handle) => {
      handle = Emval.toValue(handle);
      return typeof handle == 'string';
    };
  __emval_is_string.sig = 'ip';

  var __emval_in = (item, object) => {
      item = Emval.toValue(item);
      object = Emval.toValue(object);
      return item in object;
    };
  __emval_in.sig = 'ipp';


  var __emval_throw = (object) => {
      object = Emval.toValue(object);
      throw object;
    };
  __emval_throw.sig = 'ip';

  var __emval_iter_begin = (iterable) => {
      iterable = Emval.toValue(iterable);
      return Emval.toHandle(iterable[Symbol.iterator]());
    };
  __emval_iter_begin.sig = 'pp';

  var __emval_iter_next = (iterator) => {
      iterator = Emval.toValue(iterator);
      var result = iterator.next();
      return result.done ? 0 : Emval.toHandle(result.value);
    };
  __emval_iter_next.sig = 'pp';

  
  var __emval_coro_suspend = (promiseHandle, awaiterPtr) => {
      Emval.toValue(promiseHandle).then(result => {
        __emval_coro_resume(awaiterPtr, Emval.toHandle(result));
      });
    };
  __emval_coro_suspend.sig = 'vpp';

  
  var __emval_coro_make_promise = (resolveHandlePtr, rejectHandlePtr) => {
      return Emval.toHandle(new Promise((resolve, reject) => {
        const rejectWithCurrentException = () => {
          try {
            // Use __cxa_rethrow which already has mechanism for generating
            // user-friendly error message and stacktrace from C++ exception
            // if EXCEPTION_STACK_TRACES is enabled and numeric exception
            // with metadata optimised out otherwise.
            ___cxa_rethrow();
          } catch (e) {
            // But catch it so that it rejects the promise instead of throwing
            // in an unpredictable place during async execution.
            reject(e);
          }
        };
  
        HEAPU32[((resolveHandlePtr)>>2)] = Emval.toHandle(resolve);
        HEAPU32[((rejectHandlePtr)>>2)] = Emval.toHandle(rejectWithCurrentException);
      }));
    };
  __emval_coro_make_promise.sig = 'ppp';

      // exports
      Module["requestFullscreen"] = Browser.requestFullscreen;
      Module["setCanvasSize"] = Browser.setCanvasSize;
      Module["getUserMedia"] = Browser.getUserMedia;
      Module["createContext"] = Browser.createContext;
    ;

      registerWasmPlugin();
      ;

  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  // Set module methods based on EXPORTED_RUNTIME_METHODS
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  ;

      // This error may happen quite a bit. To avoid overhead we reuse it (and
      // suffer a lack of stack info).
      MEMFS.doesNotExistError = new FS.ErrnoError(44);
      /** @suppress {checkTypes} */
      MEMFS.doesNotExistError.stack = '<generic error, no stack>';
      ;
embind_init_charCodes();
BindingError = Module['BindingError'] = class BindingError extends Error { constructor(message) { super(message); this.name = 'BindingError'; }};
InternalError = Module['InternalError'] = class InternalError extends Error { constructor(message) { super(message); this.name = 'InternalError'; }};
init_emval();;

      Module["requestAnimationFrame"] = MainLoop.requestAnimationFrame;
      Module["pauseMainLoop"] = MainLoop.pause;
      Module["resumeMainLoop"] = MainLoop.resume;
      MainLoop.init();;

      // Signal GL rendering layer that processing of a new frame is about to
      // start. This helps it optimize VBO double-buffering and reduce GPU stalls.
      registerPreMainLoop(() => GL.newRenderingFrameStarted());
    ;
for (var i = 0; i < 32; ++i) tempFixedLengthArray.push(new Array(i));;

    registerPreMainLoop(() => {
      // If the current GL context is an OffscreenCanvas, but it was initialized
      // with implicit swap mode, perform the swap on behalf of the user.
      if (GL.currentContext && !GL.currentContextIsProxied && !GL.currentContext.attributes.explicitSwapControl && GL.currentContext.GLctx.commit) {
        GL.currentContext.GLctx.commit();
      }
    });;

      var emSetImmediate;
      var emClearImmediate;
      if (typeof setImmediate != "undefined") {
        emSetImmediate = setImmediateWrapped;
        emClearImmediate = clearImmediateWrapped;
      } else if (typeof addEventListener == "function") {
        var __setImmediate_id_counter = 0;
        var __setImmediate_queue = [];
        var __setImmediate_message_id = "_si";
        /** @param {Event} e */
        var __setImmediate_cb = (e) => {
          if (e.data === __setImmediate_message_id) {
            e.stopPropagation();
            __setImmediate_queue.shift()();
            ++__setImmediate_id_counter;
          }
        }
        addEventListener("message", __setImmediate_cb, true);
        emSetImmediate = (func) => {
          postMessage(__setImmediate_message_id, "*");
          return __setImmediate_id_counter + __setImmediate_queue.push(func) - 1;
        }
        emClearImmediate = /**@type{function(number=)}*/((id) => {
          var index = id - __setImmediate_id_counter;
          // must preserve the order and count of elements in the queue, so replace the pending callback with an empty function
          if (index >= 0 && index < __setImmediate_queue.length) __setImmediate_queue[index] = () => {};
        })
      };
var miniTempWebGLFloatBuffersStorage = new Float32Array(288);
  // Create GL_POOL_TEMP_BUFFERS_SIZE+1 temporary buffers, for uploads of size 0 through GL_POOL_TEMP_BUFFERS_SIZE inclusive
  for (/**@suppress{duplicate}*/var i = 0; i <= 288; ++i) {
    miniTempWebGLFloatBuffers[i] = miniTempWebGLFloatBuffersStorage.subarray(0, i);
  };
var miniTempWebGLIntBuffersStorage = new Int32Array(288);
  // Create GL_POOL_TEMP_BUFFERS_SIZE+1 temporary buffers, for uploads of size 0 through GL_POOL_TEMP_BUFFERS_SIZE inclusive
  for (/**@suppress{duplicate}*/var i = 0; i <= 288; ++i) {
    miniTempWebGLIntBuffers[i] = miniTempWebGLIntBuffersStorage.subarray(0, i);
  };

      // Queue new audio data. This is important to be right after the main loop
      // invocation, so that we will immediately be able to queue the newest
      // produced audio samples.
      registerPostMainLoop(() => SDL.audio?.queueNewAudioData?.());;
UnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');;
PureVirtualError = Module['PureVirtualError'] = extendError(Error, 'PureVirtualError');;
init_RegisteredPointer();
init_ClassHandle();
var wasmImports = {
  /** @export */
  IMG_Init: _IMG_Init,
  /** @export */
  IMG_Load: _IMG_Load,
  /** @export */
  IMG_Load_RW: _IMG_Load_RW,
  /** @export */
  IMG_Quit: _IMG_Quit,
  /** @export */
  Mix_AllocateChannels: _Mix_AllocateChannels,
  /** @export */
  Mix_ChannelFinished: _Mix_ChannelFinished,
  /** @export */
  Mix_CloseAudio: _Mix_CloseAudio,
  /** @export */
  Mix_FadeInChannelTimed: _Mix_FadeInChannelTimed,
  /** @export */
  Mix_FadeInMusicPos: _Mix_FadeInMusicPos,
  /** @export */
  Mix_FadeOutChannel: _Mix_FadeOutChannel,
  /** @export */
  Mix_FadeOutMusic: _Mix_FadeOutMusic,
  /** @export */
  Mix_FadingChannel: _Mix_FadingChannel,
  /** @export */
  Mix_FreeChunk: _Mix_FreeChunk,
  /** @export */
  Mix_FreeMusic: _Mix_FreeMusic,
  /** @export */
  Mix_HaltChannel: _Mix_HaltChannel,
  /** @export */
  Mix_HaltMusic: _Mix_HaltMusic,
  /** @export */
  Mix_HookMusicFinished: _Mix_HookMusicFinished,
  /** @export */
  Mix_Init: _Mix_Init,
  /** @export */
  Mix_Linked_Version: _Mix_Linked_Version,
  /** @export */
  Mix_LoadMUS: _Mix_LoadMUS,
  /** @export */
  Mix_LoadMUS_RW: _Mix_LoadMUS_RW,
  /** @export */
  Mix_LoadWAV: _Mix_LoadWAV,
  /** @export */
  Mix_LoadWAV_RW: _Mix_LoadWAV_RW,
  /** @export */
  Mix_OpenAudio: _Mix_OpenAudio,
  /** @export */
  Mix_Pause: _Mix_Pause,
  /** @export */
  Mix_PauseMusic: _Mix_PauseMusic,
  /** @export */
  Mix_Paused: _Mix_Paused,
  /** @export */
  Mix_PausedMusic: _Mix_PausedMusic,
  /** @export */
  Mix_PlayChannelTimed: _Mix_PlayChannelTimed,
  /** @export */
  Mix_PlayMusic: _Mix_PlayMusic,
  /** @export */
  Mix_Playing: _Mix_Playing,
  /** @export */
  Mix_PlayingMusic: _Mix_PlayingMusic,
  /** @export */
  Mix_QuerySpec: _Mix_QuerySpec,
  /** @export */
  Mix_QuickLoad_RAW: _Mix_QuickLoad_RAW,
  /** @export */
  Mix_Quit: _Mix_Quit,
  /** @export */
  Mix_ReserveChannels: _Mix_ReserveChannels,
  /** @export */
  Mix_Resume: _Mix_Resume,
  /** @export */
  Mix_ResumeMusic: _Mix_ResumeMusic,
  /** @export */
  Mix_SetPanning: _Mix_SetPanning,
  /** @export */
  Mix_SetPosition: _Mix_SetPosition,
  /** @export */
  Mix_SetPostMix: _Mix_SetPostMix,
  /** @export */
  Mix_Volume: _Mix_Volume,
  /** @export */
  Mix_VolumeChunk: _Mix_VolumeChunk,
  /** @export */
  Mix_VolumeMusic: _Mix_VolumeMusic,
  /** @export */
  SDL_AddTimer: _SDL_AddTimer,
  /** @export */
  SDL_AllocRW: _SDL_AllocRW,
  /** @export */
  SDL_AudioDriverName: _SDL_AudioDriverName,
  /** @export */
  SDL_AudioQuit: _SDL_AudioQuit,
  /** @export */
  SDL_ClearError: _SDL_ClearError,
  /** @export */
  SDL_CloseAudio: _SDL_CloseAudio,
  /** @export */
  SDL_CondBroadcast: _SDL_CondBroadcast,
  /** @export */
  SDL_CondSignal: _SDL_CondSignal,
  /** @export */
  SDL_CondWait: _SDL_CondWait,
  /** @export */
  SDL_CondWaitTimeout: _SDL_CondWaitTimeout,
  /** @export */
  SDL_ConvertSurface: _SDL_ConvertSurface,
  /** @export */
  SDL_CreateCond: _SDL_CreateCond,
  /** @export */
  SDL_CreateMutex: _SDL_CreateMutex,
  /** @export */
  SDL_CreateRGBSurface: _SDL_CreateRGBSurface,
  /** @export */
  SDL_CreateRGBSurfaceFrom: _SDL_CreateRGBSurfaceFrom,
  /** @export */
  SDL_CreateThread: _SDL_CreateThread,
  /** @export */
  SDL_Delay: _SDL_Delay,
  /** @export */
  SDL_DestroyCond: _SDL_DestroyCond,
  /** @export */
  SDL_DestroyMutex: _SDL_DestroyMutex,
  /** @export */
  SDL_DestroyRenderer: _SDL_DestroyRenderer,
  /** @export */
  SDL_DestroyWindow: _SDL_DestroyWindow,
  /** @export */
  SDL_DisplayFormatAlpha: _SDL_DisplayFormatAlpha,
  /** @export */
  SDL_EnableKeyRepeat: _SDL_EnableKeyRepeat,
  /** @export */
  SDL_EnableUNICODE: _SDL_EnableUNICODE,
  /** @export */
  SDL_FillRect: _SDL_FillRect,
  /** @export */
  SDL_Flip: _SDL_Flip,
  /** @export */
  SDL_FreeRW: _SDL_FreeRW,
  /** @export */
  SDL_FreeSurface: _SDL_FreeSurface,
  /** @export */
  SDL_GL_DeleteContext: _SDL_GL_DeleteContext,
  /** @export */
  SDL_GL_ExtensionSupported: _SDL_GL_ExtensionSupported,
  /** @export */
  SDL_GL_GetAttribute: _SDL_GL_GetAttribute,
  /** @export */
  SDL_GL_GetSwapInterval: _SDL_GL_GetSwapInterval,
  /** @export */
  SDL_GL_MakeCurrent: _SDL_GL_MakeCurrent,
  /** @export */
  SDL_GL_SetAttribute: _SDL_GL_SetAttribute,
  /** @export */
  SDL_GL_SetSwapInterval: _SDL_GL_SetSwapInterval,
  /** @export */
  SDL_GL_SwapBuffers: _SDL_GL_SwapBuffers,
  /** @export */
  SDL_GL_SwapWindow: _SDL_GL_SwapWindow,
  /** @export */
  SDL_GetAppState: _SDL_GetAppState,
  /** @export */
  SDL_GetAudioDriver: _SDL_GetAudioDriver,
  /** @export */
  SDL_GetClipRect: _SDL_GetClipRect,
  /** @export */
  SDL_GetCurrentAudioDriver: _SDL_GetCurrentAudioDriver,
  /** @export */
  SDL_GetError: _SDL_GetError,
  /** @export */
  SDL_GetKeyName: _SDL_GetKeyName,
  /** @export */
  SDL_GetKeyState: _SDL_GetKeyState,
  /** @export */
  SDL_GetKeyboardState: _SDL_GetKeyboardState,
  /** @export */
  SDL_GetModState: _SDL_GetModState,
  /** @export */
  SDL_GetMouseState: _SDL_GetMouseState,
  /** @export */
  SDL_GetNumAudioDrivers: _SDL_GetNumAudioDrivers,
  /** @export */
  SDL_GetRGB: _SDL_GetRGB,
  /** @export */
  SDL_GetRGBA: _SDL_GetRGBA,
  /** @export */
  SDL_GetScancodeFromKey: _SDL_GetScancodeFromKey,
  /** @export */
  SDL_GetThreadID: _SDL_GetThreadID,
  /** @export */
  SDL_GetTicks: _SDL_GetTicks,
  /** @export */
  SDL_GetVideoInfo: _SDL_GetVideoInfo,
  /** @export */
  SDL_GetVideoSurface: _SDL_GetVideoSurface,
  /** @export */
  SDL_GetWindowFlags: _SDL_GetWindowFlags,
  /** @export */
  SDL_GetWindowSize: _SDL_GetWindowSize,
  /** @export */
  SDL_Has3DNow: _SDL_Has3DNow,
  /** @export */
  SDL_Has3DNowExt: _SDL_Has3DNowExt,
  /** @export */
  SDL_HasAltiVec: _SDL_HasAltiVec,
  /** @export */
  SDL_HasMMX: _SDL_HasMMX,
  /** @export */
  SDL_HasMMXExt: _SDL_HasMMXExt,
  /** @export */
  SDL_HasRDTSC: _SDL_HasRDTSC,
  /** @export */
  SDL_HasSSE: _SDL_HasSSE,
  /** @export */
  SDL_HasSSE2: _SDL_HasSSE2,
  /** @export */
  SDL_Init: _SDL_Init,
  /** @export */
  SDL_InitSubSystem: _SDL_InitSubSystem,
  /** @export */
  SDL_JoystickClose: _SDL_JoystickClose,
  /** @export */
  SDL_JoystickEventState: _SDL_JoystickEventState,
  /** @export */
  SDL_JoystickGetAxis: _SDL_JoystickGetAxis,
  /** @export */
  SDL_JoystickGetBall: _SDL_JoystickGetBall,
  /** @export */
  SDL_JoystickGetButton: _SDL_JoystickGetButton,
  /** @export */
  SDL_JoystickGetHat: _SDL_JoystickGetHat,
  /** @export */
  SDL_JoystickIndex: _SDL_JoystickIndex,
  /** @export */
  SDL_JoystickName: _SDL_JoystickName,
  /** @export */
  SDL_JoystickNumAxes: _SDL_JoystickNumAxes,
  /** @export */
  SDL_JoystickNumBalls: _SDL_JoystickNumBalls,
  /** @export */
  SDL_JoystickNumButtons: _SDL_JoystickNumButtons,
  /** @export */
  SDL_JoystickNumHats: _SDL_JoystickNumHats,
  /** @export */
  SDL_JoystickOpen: _SDL_JoystickOpen,
  /** @export */
  SDL_JoystickOpened: _SDL_JoystickOpened,
  /** @export */
  SDL_JoystickUpdate: _SDL_JoystickUpdate,
  /** @export */
  SDL_Linked_Version: _SDL_Linked_Version,
  /** @export */
  SDL_ListModes: _SDL_ListModes,
  /** @export */
  SDL_LoadBMP_RW: _SDL_LoadBMP_RW,
  /** @export */
  SDL_LockAudio: _SDL_LockAudio,
  /** @export */
  SDL_LockSurface: _SDL_LockSurface,
  /** @export */
  SDL_LogSetOutputFunction: _SDL_LogSetOutputFunction,
  /** @export */
  SDL_LowerBlit: _SDL_LowerBlit,
  /** @export */
  SDL_LowerBlitScaled: _SDL_LowerBlitScaled,
  /** @export */
  SDL_MapRGB: _SDL_MapRGB,
  /** @export */
  SDL_MapRGBA: _SDL_MapRGBA,
  /** @export */
  SDL_NumJoysticks: _SDL_NumJoysticks,
  /** @export */
  SDL_OpenAudio: _SDL_OpenAudio,
  /** @export */
  SDL_PauseAudio: _SDL_PauseAudio,
  /** @export */
  SDL_PeepEvents: _SDL_PeepEvents,
  /** @export */
  SDL_PollEvent: _SDL_PollEvent,
  /** @export */
  SDL_PumpEvents: _SDL_PumpEvents,
  /** @export */
  SDL_PushEvent: _SDL_PushEvent,
  /** @export */
  SDL_Quit: _SDL_Quit,
  /** @export */
  SDL_QuitSubSystem: _SDL_QuitSubSystem,
  /** @export */
  SDL_RWFromConstMem: _SDL_RWFromConstMem,
  /** @export */
  SDL_RWFromFile: _SDL_RWFromFile,
  /** @export */
  SDL_RWFromMem: _SDL_RWFromMem,
  /** @export */
  SDL_RemoveTimer: _SDL_RemoveTimer,
  /** @export */
  SDL_SaveBMP_RW: _SDL_SaveBMP_RW,
  /** @export */
  SDL_SetAlpha: _SDL_SetAlpha,
  /** @export */
  SDL_SetClipRect: _SDL_SetClipRect,
  /** @export */
  SDL_SetColorKey: _SDL_SetColorKey,
  /** @export */
  SDL_SetColors: _SDL_SetColors,
  /** @export */
  SDL_SetError: _SDL_SetError,
  /** @export */
  SDL_SetGamma: _SDL_SetGamma,
  /** @export */
  SDL_SetGammaRamp: _SDL_SetGammaRamp,
  /** @export */
  SDL_SetPalette: _SDL_SetPalette,
  /** @export */
  SDL_SetVideoMode: _SDL_SetVideoMode,
  /** @export */
  SDL_SetWindowFullscreen: _SDL_SetWindowFullscreen,
  /** @export */
  SDL_SetWindowTitle: _SDL_SetWindowTitle,
  /** @export */
  SDL_ShowCursor: _SDL_ShowCursor,
  /** @export */
  SDL_StartTextInput: _SDL_StartTextInput,
  /** @export */
  SDL_StopTextInput: _SDL_StopTextInput,
  /** @export */
  SDL_ThreadID: _SDL_ThreadID,
  /** @export */
  SDL_UnlockAudio: _SDL_UnlockAudio,
  /** @export */
  SDL_UnlockSurface: _SDL_UnlockSurface,
  /** @export */
  SDL_UpdateRect: _SDL_UpdateRect,
  /** @export */
  SDL_UpdateRects: _SDL_UpdateRects,
  /** @export */
  SDL_UpperBlit: _SDL_UpperBlit,
  /** @export */
  SDL_UpperBlitScaled: _SDL_UpperBlitScaled,
  /** @export */
  SDL_VideoDriverName: _SDL_VideoDriverName,
  /** @export */
  SDL_VideoModeOK: _SDL_VideoModeOK,
  /** @export */
  SDL_VideoQuit: _SDL_VideoQuit,
  /** @export */
  SDL_WM_GrabInput: _SDL_WM_GrabInput,
  /** @export */
  SDL_WM_IconifyWindow: _SDL_WM_IconifyWindow,
  /** @export */
  SDL_WM_SetCaption: _SDL_WM_SetCaption,
  /** @export */
  SDL_WM_SetIcon: _SDL_WM_SetIcon,
  /** @export */
  SDL_WM_ToggleFullScreen: _SDL_WM_ToggleFullScreen,
  /** @export */
  SDL_WaitThread: _SDL_WaitThread,
  /** @export */
  SDL_WarpMouse: _SDL_WarpMouse,
  /** @export */
  SDL_WasInit: _SDL_WasInit,
  /** @export */
  SDL_mutexP: _SDL_mutexP,
  /** @export */
  SDL_mutexV: _SDL_mutexV,
  /** @export */
  TTF_CloseFont: _TTF_CloseFont,
  /** @export */
  TTF_FontAscent: _TTF_FontAscent,
  /** @export */
  TTF_FontDescent: _TTF_FontDescent,
  /** @export */
  TTF_FontHeight: _TTF_FontHeight,
  /** @export */
  TTF_FontLineSkip: _TTF_FontLineSkip,
  /** @export */
  TTF_GlyphMetrics: _TTF_GlyphMetrics,
  /** @export */
  TTF_Init: _TTF_Init,
  /** @export */
  TTF_OpenFont: _TTF_OpenFont,
  /** @export */
  TTF_Quit: _TTF_Quit,
  /** @export */
  TTF_RenderText_Blended: _TTF_RenderText_Blended,
  /** @export */
  TTF_RenderText_Shaded: _TTF_RenderText_Shaded,
  /** @export */
  TTF_RenderText_Solid: _TTF_RenderText_Solid,
  /** @export */
  TTF_RenderUTF8_Solid: _TTF_RenderUTF8_Solid,
  /** @export */
  TTF_SizeText: _TTF_SizeText,
  /** @export */
  TTF_SizeUTF8: _TTF_SizeUTF8,
  /** @export */
  XChangeWindowAttributes: _XChangeWindowAttributes,
  /** @export */
  XCreateWindow: _XCreateWindow,
  /** @export */
  XInternAtom: _XInternAtom,
  /** @export */
  XMapWindow: _XMapWindow,
  /** @export */
  XOpenDisplay: _XOpenDisplay,
  /** @export */
  XPending: _XPending,
  /** @export */
  XSendEvent: _XSendEvent,
  /** @export */
  XSetWMHints: _XSetWMHints,
  /** @export */
  XStoreName: _XStoreName,
  /** @export */
  _Py_CheckEmscriptenSignals_Helper,
  /** @export */
  _Py_emscripten_runtime,
  /** @export */
  _Unwind_Backtrace: __Unwind_Backtrace,
  /** @export */
  _Unwind_DeleteException: __Unwind_DeleteException,
  /** @export */
  _Unwind_FindEnclosingFunction: __Unwind_FindEnclosingFunction,
  /** @export */
  _Unwind_GetIPInfo: __Unwind_GetIPInfo,
  /** @export */
  _Unwind_RaiseException: __Unwind_RaiseException,
  /** @export */
  __asctime_r: ___asctime_r,
  /** @export */
  __assert_fail: ___assert_fail,
  /** @export */
  __call_sighandler: ___call_sighandler,
  /** @export */
  __cxa_begin_catch: ___cxa_begin_catch,
  /** @export */
  __cxa_call_unexpected: ___cxa_call_unexpected,
  /** @export */
  __cxa_end_catch: ___cxa_end_catch,
  /** @export */
  __cxa_find_matching_catch_2: ___cxa_find_matching_catch_2,
  /** @export */
  __cxa_find_matching_catch_3: ___cxa_find_matching_catch_3,
  /** @export */
  __cxa_find_matching_catch_4: ___cxa_find_matching_catch_4,
  /** @export */
  __cxa_rethrow: ___cxa_rethrow,
  /** @export */
  __cxa_throw: ___cxa_throw,
  /** @export */
  __global_base: ___global_base,
  /** @export */
  __heap_base: ___heap_base,
  /** @export */
  __indirect_function_table: wasmTable,
  /** @export */
  __memory_base: ___memory_base,
  /** @export */
  __resumeException: ___resumeException,
  /** @export */
  __stack_high: ___stack_high,
  /** @export */
  __stack_low: ___stack_low,
  /** @export */
  __stack_pointer: ___stack_pointer,
  /** @export */
  __syscall__newselect: ___syscall__newselect,
  /** @export */
  __syscall_accept4: ___syscall_accept4,
  /** @export */
  __syscall_bind: ___syscall_bind,
  /** @export */
  __syscall_chdir: ___syscall_chdir,
  /** @export */
  __syscall_chmod: ___syscall_chmod,
  /** @export */
  __syscall_connect: ___syscall_connect,
  /** @export */
  __syscall_dup: ___syscall_dup,
  /** @export */
  __syscall_dup3: ___syscall_dup3,
  /** @export */
  __syscall_faccessat: ___syscall_faccessat,
  /** @export */
  __syscall_fadvise64: ___syscall_fadvise64,
  /** @export */
  __syscall_fallocate: ___syscall_fallocate,
  /** @export */
  __syscall_fchdir: ___syscall_fchdir,
  /** @export */
  __syscall_fchmod: ___syscall_fchmod,
  /** @export */
  __syscall_fchmodat2: ___syscall_fchmodat2,
  /** @export */
  __syscall_fchown32: ___syscall_fchown32,
  /** @export */
  __syscall_fchownat: ___syscall_fchownat,
  /** @export */
  __syscall_fcntl64: ___syscall_fcntl64,
  /** @export */
  __syscall_fdatasync: ___syscall_fdatasync,
  /** @export */
  __syscall_fstat64: ___syscall_fstat64,
  /** @export */
  __syscall_fstatfs64: ___syscall_fstatfs64,
  /** @export */
  __syscall_ftruncate64: ___syscall_ftruncate64,
  /** @export */
  __syscall_getcwd: ___syscall_getcwd,
  /** @export */
  __syscall_getdents64: ___syscall_getdents64,
  /** @export */
  __syscall_getpeername: ___syscall_getpeername,
  /** @export */
  __syscall_getsockname: ___syscall_getsockname,
  /** @export */
  __syscall_getsockopt: ___syscall_getsockopt,
  /** @export */
  __syscall_ioctl: ___syscall_ioctl,
  /** @export */
  __syscall_listen: ___syscall_listen,
  /** @export */
  __syscall_lstat64: ___syscall_lstat64,
  /** @export */
  __syscall_mkdirat: ___syscall_mkdirat,
  /** @export */
  __syscall_mknodat: ___syscall_mknodat,
  /** @export */
  __syscall_newfstatat: ___syscall_newfstatat,
  /** @export */
  __syscall_openat: ___syscall_openat,
  /** @export */
  __syscall_pipe: ___syscall_pipe,
  /** @export */
  __syscall_poll: ___syscall_poll,
  /** @export */
  __syscall_readlinkat: ___syscall_readlinkat,
  /** @export */
  __syscall_recvfrom: ___syscall_recvfrom,
  /** @export */
  __syscall_recvmsg: ___syscall_recvmsg,
  /** @export */
  __syscall_renameat: ___syscall_renameat,
  /** @export */
  __syscall_rmdir: ___syscall_rmdir,
  /** @export */
  __syscall_sendmsg: ___syscall_sendmsg,
  /** @export */
  __syscall_sendto: ___syscall_sendto,
  /** @export */
  __syscall_socket: ___syscall_socket,
  /** @export */
  __syscall_stat64: ___syscall_stat64,
  /** @export */
  __syscall_statfs64: ___syscall_statfs64,
  /** @export */
  __syscall_symlinkat: ___syscall_symlinkat,
  /** @export */
  __syscall_truncate64: ___syscall_truncate64,
  /** @export */
  __syscall_unlinkat: ___syscall_unlinkat,
  /** @export */
  __syscall_utimensat: ___syscall_utimensat,
  /** @export */
  __table_base: ___table_base,
  /** @export */
  _abort_js: __abort_js,
  /** @export */
  _dlopen_js: __dlopen_js,
  /** @export */
  _dlsym_catchup_js: __dlsym_catchup_js,
  /** @export */
  _dlsym_js: __dlsym_js,
  /** @export */
  _embind_create_inheriting_constructor: __embind_create_inheriting_constructor,
  /** @export */
  _embind_finalize_value_array: __embind_finalize_value_array,
  /** @export */
  _embind_finalize_value_object: __embind_finalize_value_object,
  /** @export */
  _embind_register_bigint: __embind_register_bigint,
  /** @export */
  _embind_register_bool: __embind_register_bool,
  /** @export */
  _embind_register_class: __embind_register_class,
  /** @export */
  _embind_register_class_class_function: __embind_register_class_class_function,
  /** @export */
  _embind_register_class_class_property: __embind_register_class_class_property,
  /** @export */
  _embind_register_class_constructor: __embind_register_class_constructor,
  /** @export */
  _embind_register_class_function: __embind_register_class_function,
  /** @export */
  _embind_register_class_property: __embind_register_class_property,
  /** @export */
  _embind_register_constant: __embind_register_constant,
  /** @export */
  _embind_register_emval: __embind_register_emval,
  /** @export */
  _embind_register_enum: __embind_register_enum,
  /** @export */
  _embind_register_enum_value: __embind_register_enum_value,
  /** @export */
  _embind_register_float: __embind_register_float,
  /** @export */
  _embind_register_function: __embind_register_function,
  /** @export */
  _embind_register_integer: __embind_register_integer,
  /** @export */
  _embind_register_memory_view: __embind_register_memory_view,
  /** @export */
  _embind_register_optional: __embind_register_optional,
  /** @export */
  _embind_register_smart_ptr: __embind_register_smart_ptr,
  /** @export */
  _embind_register_std_string: __embind_register_std_string,
  /** @export */
  _embind_register_std_wstring: __embind_register_std_wstring,
  /** @export */
  _embind_register_user_type: __embind_register_user_type,
  /** @export */
  _embind_register_value_array: __embind_register_value_array,
  /** @export */
  _embind_register_value_array_element: __embind_register_value_array_element,
  /** @export */
  _embind_register_value_object: __embind_register_value_object,
  /** @export */
  _embind_register_value_object_field: __embind_register_value_object_field,
  /** @export */
  _embind_register_void: __embind_register_void,
  /** @export */
  _emscripten_dlopen_js: __emscripten_dlopen_js,
  /** @export */
  _emscripten_fs_load_embedded_files: __emscripten_fs_load_embedded_files,
  /** @export */
  _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
  /** @export */
  _emscripten_get_progname: __emscripten_get_progname,
  /** @export */
  _emscripten_lookup_name: __emscripten_lookup_name,
  /** @export */
  _emscripten_memcpy_js: __emscripten_memcpy_js,
  /** @export */
  _emscripten_push_main_loop_blocker: __emscripten_push_main_loop_blocker,
  /** @export */
  _emscripten_push_uncounted_main_loop_blocker: __emscripten_push_uncounted_main_loop_blocker,
  /** @export */
  _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear,
  /** @export */
  _emscripten_set_offscreencanvas_size: __emscripten_set_offscreencanvas_size,
  /** @export */
  _emscripten_system: __emscripten_system,
  /** @export */
  _emscripten_throw_longjmp: __emscripten_throw_longjmp,
  /** @export */
  _emval_as: __emval_as,
  /** @export */
  _emval_as_int64: __emval_as_int64,
  /** @export */
  _emval_as_uint64: __emval_as_uint64,
  /** @export */
  _emval_call: __emval_call,
  /** @export */
  _emval_call_method: __emval_call_method,
  /** @export */
  _emval_coro_make_promise: __emval_coro_make_promise,
  /** @export */
  _emval_coro_suspend: __emval_coro_suspend,
  /** @export */
  _emval_decref: __emval_decref,
  /** @export */
  _emval_delete: __emval_delete,
  /** @export */
  _emval_equals: __emval_equals,
  /** @export */
  _emval_get_global: __emval_get_global,
  /** @export */
  _emval_get_method_caller: __emval_get_method_caller,
  /** @export */
  _emval_get_module_property: __emval_get_module_property,
  /** @export */
  _emval_get_property: __emval_get_property,
  /** @export */
  _emval_greater_than: __emval_greater_than,
  /** @export */
  _emval_in: __emval_in,
  /** @export */
  _emval_incref: __emval_incref,
  /** @export */
  _emval_instanceof: __emval_instanceof,
  /** @export */
  _emval_is_number: __emval_is_number,
  /** @export */
  _emval_is_string: __emval_is_string,
  /** @export */
  _emval_iter_begin: __emval_iter_begin,
  /** @export */
  _emval_iter_next: __emval_iter_next,
  /** @export */
  _emval_less_than: __emval_less_than,
  /** @export */
  _emval_new_array: __emval_new_array,
  /** @export */
  _emval_new_array_from_memory_view: __emval_new_array_from_memory_view,
  /** @export */
  _emval_new_cstring: __emval_new_cstring,
  /** @export */
  _emval_new_object: __emval_new_object,
  /** @export */
  _emval_new_u16string: __emval_new_u16string,
  /** @export */
  _emval_new_u8string: __emval_new_u8string,
  /** @export */
  _emval_not: __emval_not,
  /** @export */
  _emval_register_symbol: __emval_register_symbol,
  /** @export */
  _emval_run_destructors: __emval_run_destructors,
  /** @export */
  _emval_set_property: __emval_set_property,
  /** @export */
  _emval_strictly_equals: __emval_strictly_equals,
  /** @export */
  _emval_take_value: __emval_take_value,
  /** @export */
  _emval_throw: __emval_throw,
  /** @export */
  _emval_typeof: __emval_typeof,
  /** @export */
  _glGetActiveAttribOrUniform: __glGetActiveAttribOrUniform,
  /** @export */
  _gmtime_js: __gmtime_js,
  /** @export */
  _localtime_js: __localtime_js,
  /** @export */
  _mktime_js: __mktime_js,
  /** @export */
  _mmap_js: __mmap_js,
  /** @export */
  _msync_js: __msync_js,
  /** @export */
  _munmap_js: __munmap_js,
  /** @export */
  _setitimer_js: __setitimer_js,
  /** @export */
  _timegm_js: __timegm_js,
  /** @export */
  _tzset_js: __tzset_js,
  /** @export */
  alBuffer3f: _alBuffer3f,
  /** @export */
  alBuffer3i: _alBuffer3i,
  /** @export */
  alBufferData: _alBufferData,
  /** @export */
  alBufferf: _alBufferf,
  /** @export */
  alBufferfv: _alBufferfv,
  /** @export */
  alBufferi: _alBufferi,
  /** @export */
  alBufferiv: _alBufferiv,
  /** @export */
  alDeleteBuffers: _alDeleteBuffers,
  /** @export */
  alDeleteSources: _alDeleteSources,
  /** @export */
  alDisable: _alDisable,
  /** @export */
  alDistanceModel: _alDistanceModel,
  /** @export */
  alDopplerFactor: _alDopplerFactor,
  /** @export */
  alDopplerVelocity: _alDopplerVelocity,
  /** @export */
  alEnable: _alEnable,
  /** @export */
  alGenBuffers: _alGenBuffers,
  /** @export */
  alGenSources: _alGenSources,
  /** @export */
  alGetBoolean: _alGetBoolean,
  /** @export */
  alGetBooleanv: _alGetBooleanv,
  /** @export */
  alGetBuffer3f: _alGetBuffer3f,
  /** @export */
  alGetBuffer3i: _alGetBuffer3i,
  /** @export */
  alGetBufferf: _alGetBufferf,
  /** @export */
  alGetBufferfv: _alGetBufferfv,
  /** @export */
  alGetBufferi: _alGetBufferi,
  /** @export */
  alGetBufferiv: _alGetBufferiv,
  /** @export */
  alGetDouble: _alGetDouble,
  /** @export */
  alGetDoublev: _alGetDoublev,
  /** @export */
  alGetEnumValue: _alGetEnumValue,
  /** @export */
  alGetError: _alGetError,
  /** @export */
  alGetFloat: _alGetFloat,
  /** @export */
  alGetFloatv: _alGetFloatv,
  /** @export */
  alGetInteger: _alGetInteger,
  /** @export */
  alGetIntegerv: _alGetIntegerv,
  /** @export */
  alGetListener3f: _alGetListener3f,
  /** @export */
  alGetListener3i: _alGetListener3i,
  /** @export */
  alGetListenerf: _alGetListenerf,
  /** @export */
  alGetListenerfv: _alGetListenerfv,
  /** @export */
  alGetListeneri: _alGetListeneri,
  /** @export */
  alGetListeneriv: _alGetListeneriv,
  /** @export */
  alGetSource3f: _alGetSource3f,
  /** @export */
  alGetSource3i: _alGetSource3i,
  /** @export */
  alGetSourcef: _alGetSourcef,
  /** @export */
  alGetSourcefv: _alGetSourcefv,
  /** @export */
  alGetSourcei: _alGetSourcei,
  /** @export */
  alGetSourceiv: _alGetSourceiv,
  /** @export */
  alGetString: _alGetString,
  /** @export */
  alIsBuffer: _alIsBuffer,
  /** @export */
  alIsEnabled: _alIsEnabled,
  /** @export */
  alIsExtensionPresent: _alIsExtensionPresent,
  /** @export */
  alIsSource: _alIsSource,
  /** @export */
  alListener3f: _alListener3f,
  /** @export */
  alListener3i: _alListener3i,
  /** @export */
  alListenerf: _alListenerf,
  /** @export */
  alListenerfv: _alListenerfv,
  /** @export */
  alListeneri: _alListeneri,
  /** @export */
  alListeneriv: _alListeneriv,
  /** @export */
  alSource3f: _alSource3f,
  /** @export */
  alSource3i: _alSource3i,
  /** @export */
  alSourcePause: _alSourcePause,
  /** @export */
  alSourcePausev: _alSourcePausev,
  /** @export */
  alSourcePlay: _alSourcePlay,
  /** @export */
  alSourcePlayv: _alSourcePlayv,
  /** @export */
  alSourceQueueBuffers: _alSourceQueueBuffers,
  /** @export */
  alSourceRewind: _alSourceRewind,
  /** @export */
  alSourceRewindv: _alSourceRewindv,
  /** @export */
  alSourceStop: _alSourceStop,
  /** @export */
  alSourceStopv: _alSourceStopv,
  /** @export */
  alSourceUnqueueBuffers: _alSourceUnqueueBuffers,
  /** @export */
  alSourcef: _alSourcef,
  /** @export */
  alSourcefv: _alSourcefv,
  /** @export */
  alSourcei: _alSourcei,
  /** @export */
  alSourceiv: _alSourceiv,
  /** @export */
  alSpeedOfSound: _alSpeedOfSound,
  /** @export */
  alcCaptureCloseDevice: _alcCaptureCloseDevice,
  /** @export */
  alcCaptureOpenDevice: _alcCaptureOpenDevice,
  /** @export */
  alcCaptureSamples: _alcCaptureSamples,
  /** @export */
  alcCaptureStart: _alcCaptureStart,
  /** @export */
  alcCaptureStop: _alcCaptureStop,
  /** @export */
  alcCloseDevice: _alcCloseDevice,
  /** @export */
  alcCreateContext: _alcCreateContext,
  /** @export */
  alcDestroyContext: _alcDestroyContext,
  /** @export */
  alcGetContextsDevice: _alcGetContextsDevice,
  /** @export */
  alcGetCurrentContext: _alcGetCurrentContext,
  /** @export */
  alcGetEnumValue: _alcGetEnumValue,
  /** @export */
  alcGetError: _alcGetError,
  /** @export */
  alcGetIntegerv: _alcGetIntegerv,
  /** @export */
  alcGetString: _alcGetString,
  /** @export */
  alcIsExtensionPresent: _alcIsExtensionPresent,
  /** @export */
  alcMakeContextCurrent: _alcMakeContextCurrent,
  /** @export */
  alcOpenDevice: _alcOpenDevice,
  /** @export */
  alcProcessContext: _alcProcessContext,
  /** @export */
  alcSuspendContext: _alcSuspendContext,
  /** @export */
  boxColor: _boxColor,
  /** @export */
  boxRGBA: _boxRGBA,
  /** @export */
  clock_res_get: _clock_res_get,
  /** @export */
  clock_time_get: _clock_time_get,
  /** @export */
  eglBindAPI: _eglBindAPI,
  /** @export */
  eglChooseConfig: _eglChooseConfig,
  /** @export */
  eglCreateContext: _eglCreateContext,
  /** @export */
  eglCreateWindowSurface: _eglCreateWindowSurface,
  /** @export */
  eglDestroyContext: _eglDestroyContext,
  /** @export */
  eglDestroySurface: _eglDestroySurface,
  /** @export */
  eglGetConfigAttrib: _eglGetConfigAttrib,
  /** @export */
  eglGetConfigs: _eglGetConfigs,
  /** @export */
  eglGetCurrentContext: _eglGetCurrentContext,
  /** @export */
  eglGetCurrentDisplay: _eglGetCurrentDisplay,
  /** @export */
  eglGetCurrentSurface: _eglGetCurrentSurface,
  /** @export */
  eglGetDisplay: _eglGetDisplay,
  /** @export */
  eglGetError: _eglGetError,
  /** @export */
  eglInitialize: _eglInitialize,
  /** @export */
  eglMakeCurrent: _eglMakeCurrent,
  /** @export */
  eglQueryAPI: _eglQueryAPI,
  /** @export */
  eglQueryContext: _eglQueryContext,
  /** @export */
  eglQueryString: _eglQueryString,
  /** @export */
  eglQuerySurface: _eglQuerySurface,
  /** @export */
  eglReleaseThread: _eglReleaseThread,
  /** @export */
  eglSwapBuffers: _eglSwapBuffers,
  /** @export */
  eglSwapInterval: _eglSwapInterval,
  /** @export */
  eglTerminate: _eglTerminate,
  /** @export */
  eglWaitClient: _eglWaitClient,
  /** @export */
  eglWaitGL: _eglWaitGL,
  /** @export */
  eglWaitNative: _eglWaitNative,
  /** @export */
  ellipseColor: _ellipseColor,
  /** @export */
  ellipseRGBA: _ellipseRGBA,
  /** @export */
  emscripten_SDL_SetEventHandler: _emscripten_SDL_SetEventHandler,
  /** @export */
  emscripten_alcDevicePauseSOFT: _emscripten_alcDevicePauseSOFT,
  /** @export */
  emscripten_alcDeviceResumeSOFT: _emscripten_alcDeviceResumeSOFT,
  /** @export */
  emscripten_alcGetStringiSOFT: _emscripten_alcGetStringiSOFT,
  /** @export */
  emscripten_alcResetDeviceSOFT: _emscripten_alcResetDeviceSOFT,
  /** @export */
  emscripten_asm_const_async_on_main_thread: _emscripten_asm_const_async_on_main_thread,
  /** @export */
  emscripten_asm_const_double: _emscripten_asm_const_double,
  /** @export */
  emscripten_asm_const_double_sync_on_main_thread: _emscripten_asm_const_double_sync_on_main_thread,
  /** @export */
  emscripten_asm_const_int: _emscripten_asm_const_int,
  /** @export */
  emscripten_asm_const_int_sync_on_main_thread: _emscripten_asm_const_int_sync_on_main_thread,
  /** @export */
  emscripten_asm_const_ptr: _emscripten_asm_const_ptr,
  /** @export */
  emscripten_asm_const_ptr_sync_on_main_thread: _emscripten_asm_const_ptr_sync_on_main_thread,
  /** @export */
  emscripten_async_call: _emscripten_async_call,
  /** @export */
  emscripten_async_load_script: _emscripten_async_load_script,
  /** @export */
  emscripten_async_run_script: _emscripten_async_run_script,
  /** @export */
  emscripten_async_wget: _emscripten_async_wget,
  /** @export */
  emscripten_async_wget2: _emscripten_async_wget2,
  /** @export */
  emscripten_async_wget2_abort: _emscripten_async_wget2_abort,
  /** @export */
  emscripten_async_wget2_data: _emscripten_async_wget2_data,
  /** @export */
  emscripten_async_wget_data: _emscripten_async_wget_data,
  /** @export */
  emscripten_call_worker: _emscripten_call_worker,
  /** @export */
  emscripten_cancel_animation_frame: _emscripten_cancel_animation_frame,
  /** @export */
  emscripten_cancel_main_loop: _emscripten_cancel_main_loop,
  /** @export */
  emscripten_clear_immediate: _emscripten_clear_immediate,
  /** @export */
  emscripten_clear_interval: _emscripten_clear_interval,
  /** @export */
  emscripten_clear_timeout: _emscripten_clear_timeout,
  /** @export */
  emscripten_console_error: _emscripten_console_error,
  /** @export */
  emscripten_console_log: _emscripten_console_log,
  /** @export */
  emscripten_console_trace: _emscripten_console_trace,
  /** @export */
  emscripten_console_warn: _emscripten_console_warn,
  /** @export */
  emscripten_create_worker: _emscripten_create_worker,
  /** @export */
  emscripten_date_now: _emscripten_date_now,
  /** @export */
  emscripten_debugger: _emscripten_debugger,
  /** @export */
  emscripten_destroy_worker: _emscripten_destroy_worker,
  /** @export */
  emscripten_enter_soft_fullscreen: _emscripten_enter_soft_fullscreen,
  /** @export */
  emscripten_err: _emscripten_err,
  /** @export */
  emscripten_errn: _emscripten_errn,
  /** @export */
  emscripten_exit_fullscreen: _emscripten_exit_fullscreen,
  /** @export */
  emscripten_exit_pointerlock: _emscripten_exit_pointerlock,
  /** @export */
  emscripten_exit_soft_fullscreen: _emscripten_exit_soft_fullscreen,
  /** @export */
  emscripten_exit_with_live_runtime: _emscripten_exit_with_live_runtime,
  /** @export */
  emscripten_fiber_swap: _emscripten_fiber_swap,
  /** @export */
  emscripten_force_exit: _emscripten_force_exit,
  /** @export */
  emscripten_get_battery_status: _emscripten_get_battery_status,
  /** @export */
  emscripten_get_callstack: _emscripten_get_callstack,
  /** @export */
  emscripten_get_canvas_element_size: _emscripten_get_canvas_element_size,
  /** @export */
  emscripten_get_canvas_size: _emscripten_get_canvas_size,
  /** @export */
  emscripten_get_compiler_setting: _emscripten_get_compiler_setting,
  /** @export */
  emscripten_get_device_pixel_ratio: _emscripten_get_device_pixel_ratio,
  /** @export */
  emscripten_get_devicemotion_status: _emscripten_get_devicemotion_status,
  /** @export */
  emscripten_get_deviceorientation_status: _emscripten_get_deviceorientation_status,
  /** @export */
  emscripten_get_element_css_size: _emscripten_get_element_css_size,
  /** @export */
  emscripten_get_fullscreen_status: _emscripten_get_fullscreen_status,
  /** @export */
  emscripten_get_gamepad_status: _emscripten_get_gamepad_status,
  /** @export */
  emscripten_get_heap_max: _emscripten_get_heap_max,
  /** @export */
  emscripten_get_main_loop_timing: _emscripten_get_main_loop_timing,
  /** @export */
  emscripten_get_mouse_status: _emscripten_get_mouse_status,
  /** @export */
  emscripten_get_now: _emscripten_get_now,
  /** @export */
  emscripten_get_now_res: _emscripten_get_now_res,
  /** @export */
  emscripten_get_num_gamepads: _emscripten_get_num_gamepads,
  /** @export */
  emscripten_get_orientation_status: _emscripten_get_orientation_status,
  /** @export */
  emscripten_get_pointerlock_status: _emscripten_get_pointerlock_status,
  /** @export */
  emscripten_get_preloaded_image_data: _emscripten_get_preloaded_image_data,
  /** @export */
  emscripten_get_preloaded_image_data_from_FILE: _emscripten_get_preloaded_image_data_from_FILE,
  /** @export */
  emscripten_get_screen_size: _emscripten_get_screen_size,
  /** @export */
  emscripten_get_visibility_status: _emscripten_get_visibility_status,
  /** @export */
  emscripten_get_window_title: _emscripten_get_window_title,
  /** @export */
  emscripten_get_worker_queue_size: _emscripten_get_worker_queue_size,
  /** @export */
  emscripten_glActiveTexture: _emscripten_glActiveTexture,
  /** @export */
  emscripten_glAttachShader: _emscripten_glAttachShader,
  /** @export */
  emscripten_glBegin: _emscripten_glBegin,
  /** @export */
  emscripten_glBeginQuery: _emscripten_glBeginQuery,
  /** @export */
  emscripten_glBeginQueryEXT: _emscripten_glBeginQueryEXT,
  /** @export */
  emscripten_glBeginTransformFeedback: _emscripten_glBeginTransformFeedback,
  /** @export */
  emscripten_glBindAttribLocation: _emscripten_glBindAttribLocation,
  /** @export */
  emscripten_glBindBuffer: _emscripten_glBindBuffer,
  /** @export */
  emscripten_glBindBufferBase: _emscripten_glBindBufferBase,
  /** @export */
  emscripten_glBindBufferRange: _emscripten_glBindBufferRange,
  /** @export */
  emscripten_glBindFramebuffer: _emscripten_glBindFramebuffer,
  /** @export */
  emscripten_glBindRenderbuffer: _emscripten_glBindRenderbuffer,
  /** @export */
  emscripten_glBindSampler: _emscripten_glBindSampler,
  /** @export */
  emscripten_glBindTexture: _emscripten_glBindTexture,
  /** @export */
  emscripten_glBindTransformFeedback: _emscripten_glBindTransformFeedback,
  /** @export */
  emscripten_glBindVertexArray: _emscripten_glBindVertexArray,
  /** @export */
  emscripten_glBindVertexArrayOES: _emscripten_glBindVertexArrayOES,
  /** @export */
  emscripten_glBlendColor: _emscripten_glBlendColor,
  /** @export */
  emscripten_glBlendEquation: _emscripten_glBlendEquation,
  /** @export */
  emscripten_glBlendEquationSeparate: _emscripten_glBlendEquationSeparate,
  /** @export */
  emscripten_glBlendFunc: _emscripten_glBlendFunc,
  /** @export */
  emscripten_glBlendFuncSeparate: _emscripten_glBlendFuncSeparate,
  /** @export */
  emscripten_glBlitFramebuffer: _emscripten_glBlitFramebuffer,
  /** @export */
  emscripten_glBufferData: _emscripten_glBufferData,
  /** @export */
  emscripten_glBufferSubData: _emscripten_glBufferSubData,
  /** @export */
  emscripten_glCheckFramebufferStatus: _emscripten_glCheckFramebufferStatus,
  /** @export */
  emscripten_glClear: _emscripten_glClear,
  /** @export */
  emscripten_glClearBufferfi: _emscripten_glClearBufferfi,
  /** @export */
  emscripten_glClearBufferfv: _emscripten_glClearBufferfv,
  /** @export */
  emscripten_glClearBufferiv: _emscripten_glClearBufferiv,
  /** @export */
  emscripten_glClearBufferuiv: _emscripten_glClearBufferuiv,
  /** @export */
  emscripten_glClearColor: _emscripten_glClearColor,
  /** @export */
  emscripten_glClearDepth: _emscripten_glClearDepth,
  /** @export */
  emscripten_glClearDepthf: _emscripten_glClearDepthf,
  /** @export */
  emscripten_glClearStencil: _emscripten_glClearStencil,
  /** @export */
  emscripten_glClientWaitSync: _emscripten_glClientWaitSync,
  /** @export */
  emscripten_glClipControlEXT: _emscripten_glClipControlEXT,
  /** @export */
  emscripten_glColorMask: _emscripten_glColorMask,
  /** @export */
  emscripten_glCompileShader: _emscripten_glCompileShader,
  /** @export */
  emscripten_glCompressedTexImage2D: _emscripten_glCompressedTexImage2D,
  /** @export */
  emscripten_glCompressedTexImage3D: _emscripten_glCompressedTexImage3D,
  /** @export */
  emscripten_glCompressedTexSubImage2D: _emscripten_glCompressedTexSubImage2D,
  /** @export */
  emscripten_glCompressedTexSubImage3D: _emscripten_glCompressedTexSubImage3D,
  /** @export */
  emscripten_glCopyBufferSubData: _emscripten_glCopyBufferSubData,
  /** @export */
  emscripten_glCopyTexImage2D: _emscripten_glCopyTexImage2D,
  /** @export */
  emscripten_glCopyTexSubImage2D: _emscripten_glCopyTexSubImage2D,
  /** @export */
  emscripten_glCopyTexSubImage3D: _emscripten_glCopyTexSubImage3D,
  /** @export */
  emscripten_glCreateProgram: _emscripten_glCreateProgram,
  /** @export */
  emscripten_glCreateShader: _emscripten_glCreateShader,
  /** @export */
  emscripten_glCullFace: _emscripten_glCullFace,
  /** @export */
  emscripten_glDeleteBuffers: _emscripten_glDeleteBuffers,
  /** @export */
  emscripten_glDeleteFramebuffers: _emscripten_glDeleteFramebuffers,
  /** @export */
  emscripten_glDeleteProgram: _emscripten_glDeleteProgram,
  /** @export */
  emscripten_glDeleteQueries: _emscripten_glDeleteQueries,
  /** @export */
  emscripten_glDeleteQueriesEXT: _emscripten_glDeleteQueriesEXT,
  /** @export */
  emscripten_glDeleteRenderbuffers: _emscripten_glDeleteRenderbuffers,
  /** @export */
  emscripten_glDeleteSamplers: _emscripten_glDeleteSamplers,
  /** @export */
  emscripten_glDeleteShader: _emscripten_glDeleteShader,
  /** @export */
  emscripten_glDeleteSync: _emscripten_glDeleteSync,
  /** @export */
  emscripten_glDeleteTextures: _emscripten_glDeleteTextures,
  /** @export */
  emscripten_glDeleteTransformFeedbacks: _emscripten_glDeleteTransformFeedbacks,
  /** @export */
  emscripten_glDeleteVertexArrays: _emscripten_glDeleteVertexArrays,
  /** @export */
  emscripten_glDeleteVertexArraysOES: _emscripten_glDeleteVertexArraysOES,
  /** @export */
  emscripten_glDepthFunc: _emscripten_glDepthFunc,
  /** @export */
  emscripten_glDepthMask: _emscripten_glDepthMask,
  /** @export */
  emscripten_glDepthRange: _emscripten_glDepthRange,
  /** @export */
  emscripten_glDepthRangef: _emscripten_glDepthRangef,
  /** @export */
  emscripten_glDetachShader: _emscripten_glDetachShader,
  /** @export */
  emscripten_glDisable: _emscripten_glDisable,
  /** @export */
  emscripten_glDisableVertexAttribArray: _emscripten_glDisableVertexAttribArray,
  /** @export */
  emscripten_glDrawArrays: _emscripten_glDrawArrays,
  /** @export */
  emscripten_glDrawArraysInstanced: _emscripten_glDrawArraysInstanced,
  /** @export */
  emscripten_glDrawArraysInstancedANGLE: _emscripten_glDrawArraysInstancedANGLE,
  /** @export */
  emscripten_glDrawArraysInstancedARB: _emscripten_glDrawArraysInstancedARB,
  /** @export */
  emscripten_glDrawArraysInstancedBaseInstance: _emscripten_glDrawArraysInstancedBaseInstance,
  /** @export */
  emscripten_glDrawArraysInstancedBaseInstanceANGLE: _emscripten_glDrawArraysInstancedBaseInstanceANGLE,
  /** @export */
  emscripten_glDrawArraysInstancedBaseInstanceWEBGL: _emscripten_glDrawArraysInstancedBaseInstanceWEBGL,
  /** @export */
  emscripten_glDrawArraysInstancedEXT: _emscripten_glDrawArraysInstancedEXT,
  /** @export */
  emscripten_glDrawArraysInstancedNV: _emscripten_glDrawArraysInstancedNV,
  /** @export */
  emscripten_glDrawBuffers: _emscripten_glDrawBuffers,
  /** @export */
  emscripten_glDrawBuffersEXT: _emscripten_glDrawBuffersEXT,
  /** @export */
  emscripten_glDrawBuffersWEBGL: _emscripten_glDrawBuffersWEBGL,
  /** @export */
  emscripten_glDrawElements: _emscripten_glDrawElements,
  /** @export */
  emscripten_glDrawElementsInstanced: _emscripten_glDrawElementsInstanced,
  /** @export */
  emscripten_glDrawElementsInstancedANGLE: _emscripten_glDrawElementsInstancedANGLE,
  /** @export */
  emscripten_glDrawElementsInstancedARB: _emscripten_glDrawElementsInstancedARB,
  /** @export */
  emscripten_glDrawElementsInstancedBaseVertexBaseInstanceANGLE: _emscripten_glDrawElementsInstancedBaseVertexBaseInstanceANGLE,
  /** @export */
  emscripten_glDrawElementsInstancedBaseVertexBaseInstanceWEBGL: _emscripten_glDrawElementsInstancedBaseVertexBaseInstanceWEBGL,
  /** @export */
  emscripten_glDrawElementsInstancedEXT: _emscripten_glDrawElementsInstancedEXT,
  /** @export */
  emscripten_glDrawElementsInstancedNV: _emscripten_glDrawElementsInstancedNV,
  /** @export */
  emscripten_glDrawRangeElements: _emscripten_glDrawRangeElements,
  /** @export */
  emscripten_glEnable: _emscripten_glEnable,
  /** @export */
  emscripten_glEnableVertexAttribArray: _emscripten_glEnableVertexAttribArray,
  /** @export */
  emscripten_glEndQuery: _emscripten_glEndQuery,
  /** @export */
  emscripten_glEndQueryEXT: _emscripten_glEndQueryEXT,
  /** @export */
  emscripten_glEndTransformFeedback: _emscripten_glEndTransformFeedback,
  /** @export */
  emscripten_glFenceSync: _emscripten_glFenceSync,
  /** @export */
  emscripten_glFinish: _emscripten_glFinish,
  /** @export */
  emscripten_glFlush: _emscripten_glFlush,
  /** @export */
  emscripten_glFlushMappedBufferRange: _emscripten_glFlushMappedBufferRange,
  /** @export */
  emscripten_glFramebufferRenderbuffer: _emscripten_glFramebufferRenderbuffer,
  /** @export */
  emscripten_glFramebufferTexture2D: _emscripten_glFramebufferTexture2D,
  /** @export */
  emscripten_glFramebufferTextureLayer: _emscripten_glFramebufferTextureLayer,
  /** @export */
  emscripten_glFrontFace: _emscripten_glFrontFace,
  /** @export */
  emscripten_glGenBuffers: _emscripten_glGenBuffers,
  /** @export */
  emscripten_glGenFramebuffers: _emscripten_glGenFramebuffers,
  /** @export */
  emscripten_glGenQueries: _emscripten_glGenQueries,
  /** @export */
  emscripten_glGenQueriesEXT: _emscripten_glGenQueriesEXT,
  /** @export */
  emscripten_glGenRenderbuffers: _emscripten_glGenRenderbuffers,
  /** @export */
  emscripten_glGenSamplers: _emscripten_glGenSamplers,
  /** @export */
  emscripten_glGenTextures: _emscripten_glGenTextures,
  /** @export */
  emscripten_glGenTransformFeedbacks: _emscripten_glGenTransformFeedbacks,
  /** @export */
  emscripten_glGenVertexArrays: _emscripten_glGenVertexArrays,
  /** @export */
  emscripten_glGenVertexArraysOES: _emscripten_glGenVertexArraysOES,
  /** @export */
  emscripten_glGenerateMipmap: _emscripten_glGenerateMipmap,
  /** @export */
  emscripten_glGetActiveAttrib: _emscripten_glGetActiveAttrib,
  /** @export */
  emscripten_glGetActiveUniform: _emscripten_glGetActiveUniform,
  /** @export */
  emscripten_glGetActiveUniformBlockName: _emscripten_glGetActiveUniformBlockName,
  /** @export */
  emscripten_glGetActiveUniformBlockiv: _emscripten_glGetActiveUniformBlockiv,
  /** @export */
  emscripten_glGetActiveUniformsiv: _emscripten_glGetActiveUniformsiv,
  /** @export */
  emscripten_glGetAttachedShaders: _emscripten_glGetAttachedShaders,
  /** @export */
  emscripten_glGetAttribLocation: _emscripten_glGetAttribLocation,
  /** @export */
  emscripten_glGetBooleanv: _emscripten_glGetBooleanv,
  /** @export */
  emscripten_glGetBufferParameteri64v: _emscripten_glGetBufferParameteri64v,
  /** @export */
  emscripten_glGetBufferParameteriv: _emscripten_glGetBufferParameteriv,
  /** @export */
  emscripten_glGetBufferPointerv: _emscripten_glGetBufferPointerv,
  /** @export */
  emscripten_glGetBufferSubData: _emscripten_glGetBufferSubData,
  /** @export */
  emscripten_glGetError: _emscripten_glGetError,
  /** @export */
  emscripten_glGetFloatv: _emscripten_glGetFloatv,
  /** @export */
  emscripten_glGetFragDataLocation: _emscripten_glGetFragDataLocation,
  /** @export */
  emscripten_glGetFramebufferAttachmentParameteriv: _emscripten_glGetFramebufferAttachmentParameteriv,
  /** @export */
  emscripten_glGetInteger64i_v: _emscripten_glGetInteger64i_v,
  /** @export */
  emscripten_glGetInteger64v: _emscripten_glGetInteger64v,
  /** @export */
  emscripten_glGetIntegeri_v: _emscripten_glGetIntegeri_v,
  /** @export */
  emscripten_glGetIntegerv: _emscripten_glGetIntegerv,
  /** @export */
  emscripten_glGetInternalformativ: _emscripten_glGetInternalformativ,
  /** @export */
  emscripten_glGetProgramBinary: _emscripten_glGetProgramBinary,
  /** @export */
  emscripten_glGetProgramInfoLog: _emscripten_glGetProgramInfoLog,
  /** @export */
  emscripten_glGetProgramiv: _emscripten_glGetProgramiv,
  /** @export */
  emscripten_glGetQueryObjecti64vEXT: _emscripten_glGetQueryObjecti64vEXT,
  /** @export */
  emscripten_glGetQueryObjectivEXT: _emscripten_glGetQueryObjectivEXT,
  /** @export */
  emscripten_glGetQueryObjectui64vEXT: _emscripten_glGetQueryObjectui64vEXT,
  /** @export */
  emscripten_glGetQueryObjectuiv: _emscripten_glGetQueryObjectuiv,
  /** @export */
  emscripten_glGetQueryObjectuivEXT: _emscripten_glGetQueryObjectuivEXT,
  /** @export */
  emscripten_glGetQueryiv: _emscripten_glGetQueryiv,
  /** @export */
  emscripten_glGetQueryivEXT: _emscripten_glGetQueryivEXT,
  /** @export */
  emscripten_glGetRenderbufferParameteriv: _emscripten_glGetRenderbufferParameteriv,
  /** @export */
  emscripten_glGetSamplerParameterfv: _emscripten_glGetSamplerParameterfv,
  /** @export */
  emscripten_glGetSamplerParameteriv: _emscripten_glGetSamplerParameteriv,
  /** @export */
  emscripten_glGetShaderInfoLog: _emscripten_glGetShaderInfoLog,
  /** @export */
  emscripten_glGetShaderPrecisionFormat: _emscripten_glGetShaderPrecisionFormat,
  /** @export */
  emscripten_glGetShaderSource: _emscripten_glGetShaderSource,
  /** @export */
  emscripten_glGetShaderiv: _emscripten_glGetShaderiv,
  /** @export */
  emscripten_glGetString: _emscripten_glGetString,
  /** @export */
  emscripten_glGetStringi: _emscripten_glGetStringi,
  /** @export */
  emscripten_glGetSynciv: _emscripten_glGetSynciv,
  /** @export */
  emscripten_glGetTexParameterfv: _emscripten_glGetTexParameterfv,
  /** @export */
  emscripten_glGetTexParameteriv: _emscripten_glGetTexParameteriv,
  /** @export */
  emscripten_glGetTransformFeedbackVarying: _emscripten_glGetTransformFeedbackVarying,
  /** @export */
  emscripten_glGetUniformBlockIndex: _emscripten_glGetUniformBlockIndex,
  /** @export */
  emscripten_glGetUniformIndices: _emscripten_glGetUniformIndices,
  /** @export */
  emscripten_glGetUniformLocation: _emscripten_glGetUniformLocation,
  /** @export */
  emscripten_glGetUniformfv: _emscripten_glGetUniformfv,
  /** @export */
  emscripten_glGetUniformiv: _emscripten_glGetUniformiv,
  /** @export */
  emscripten_glGetUniformuiv: _emscripten_glGetUniformuiv,
  /** @export */
  emscripten_glGetVertexAttribIiv: _emscripten_glGetVertexAttribIiv,
  /** @export */
  emscripten_glGetVertexAttribIuiv: _emscripten_glGetVertexAttribIuiv,
  /** @export */
  emscripten_glGetVertexAttribPointerv: _emscripten_glGetVertexAttribPointerv,
  /** @export */
  emscripten_glGetVertexAttribfv: _emscripten_glGetVertexAttribfv,
  /** @export */
  emscripten_glGetVertexAttribiv: _emscripten_glGetVertexAttribiv,
  /** @export */
  emscripten_glHint: _emscripten_glHint,
  /** @export */
  emscripten_glInvalidateFramebuffer: _emscripten_glInvalidateFramebuffer,
  /** @export */
  emscripten_glInvalidateSubFramebuffer: _emscripten_glInvalidateSubFramebuffer,
  /** @export */
  emscripten_glIsBuffer: _emscripten_glIsBuffer,
  /** @export */
  emscripten_glIsEnabled: _emscripten_glIsEnabled,
  /** @export */
  emscripten_glIsFramebuffer: _emscripten_glIsFramebuffer,
  /** @export */
  emscripten_glIsProgram: _emscripten_glIsProgram,
  /** @export */
  emscripten_glIsQuery: _emscripten_glIsQuery,
  /** @export */
  emscripten_glIsQueryEXT: _emscripten_glIsQueryEXT,
  /** @export */
  emscripten_glIsRenderbuffer: _emscripten_glIsRenderbuffer,
  /** @export */
  emscripten_glIsSampler: _emscripten_glIsSampler,
  /** @export */
  emscripten_glIsShader: _emscripten_glIsShader,
  /** @export */
  emscripten_glIsSync: _emscripten_glIsSync,
  /** @export */
  emscripten_glIsTexture: _emscripten_glIsTexture,
  /** @export */
  emscripten_glIsTransformFeedback: _emscripten_glIsTransformFeedback,
  /** @export */
  emscripten_glIsVertexArray: _emscripten_glIsVertexArray,
  /** @export */
  emscripten_glIsVertexArrayOES: _emscripten_glIsVertexArrayOES,
  /** @export */
  emscripten_glLineWidth: _emscripten_glLineWidth,
  /** @export */
  emscripten_glLinkProgram: _emscripten_glLinkProgram,
  /** @export */
  emscripten_glLoadIdentity: _emscripten_glLoadIdentity,
  /** @export */
  emscripten_glMapBufferRange: _emscripten_glMapBufferRange,
  /** @export */
  emscripten_glMatrixMode: _emscripten_glMatrixMode,
  /** @export */
  emscripten_glMultiDrawArrays: _emscripten_glMultiDrawArrays,
  /** @export */
  emscripten_glMultiDrawArraysANGLE: _emscripten_glMultiDrawArraysANGLE,
  /** @export */
  emscripten_glMultiDrawArraysInstancedANGLE: _emscripten_glMultiDrawArraysInstancedANGLE,
  /** @export */
  emscripten_glMultiDrawArraysInstancedBaseInstanceANGLE: _emscripten_glMultiDrawArraysInstancedBaseInstanceANGLE,
  /** @export */
  emscripten_glMultiDrawArraysInstancedBaseInstanceWEBGL: _emscripten_glMultiDrawArraysInstancedBaseInstanceWEBGL,
  /** @export */
  emscripten_glMultiDrawArraysInstancedWEBGL: _emscripten_glMultiDrawArraysInstancedWEBGL,
  /** @export */
  emscripten_glMultiDrawArraysWEBGL: _emscripten_glMultiDrawArraysWEBGL,
  /** @export */
  emscripten_glMultiDrawElements: _emscripten_glMultiDrawElements,
  /** @export */
  emscripten_glMultiDrawElementsANGLE: _emscripten_glMultiDrawElementsANGLE,
  /** @export */
  emscripten_glMultiDrawElementsInstancedANGLE: _emscripten_glMultiDrawElementsInstancedANGLE,
  /** @export */
  emscripten_glMultiDrawElementsInstancedBaseVertexBaseInstanceANGLE: _emscripten_glMultiDrawElementsInstancedBaseVertexBaseInstanceANGLE,
  /** @export */
  emscripten_glMultiDrawElementsInstancedBaseVertexBaseInstanceWEBGL: _emscripten_glMultiDrawElementsInstancedBaseVertexBaseInstanceWEBGL,
  /** @export */
  emscripten_glMultiDrawElementsInstancedWEBGL: _emscripten_glMultiDrawElementsInstancedWEBGL,
  /** @export */
  emscripten_glMultiDrawElementsWEBGL: _emscripten_glMultiDrawElementsWEBGL,
  /** @export */
  emscripten_glPauseTransformFeedback: _emscripten_glPauseTransformFeedback,
  /** @export */
  emscripten_glPixelStorei: _emscripten_glPixelStorei,
  /** @export */
  emscripten_glPolygonModeWEBGL: _emscripten_glPolygonModeWEBGL,
  /** @export */
  emscripten_glPolygonOffset: _emscripten_glPolygonOffset,
  /** @export */
  emscripten_glPolygonOffsetClampEXT: _emscripten_glPolygonOffsetClampEXT,
  /** @export */
  emscripten_glProgramBinary: _emscripten_glProgramBinary,
  /** @export */
  emscripten_glProgramParameteri: _emscripten_glProgramParameteri,
  /** @export */
  emscripten_glQueryCounterEXT: _emscripten_glQueryCounterEXT,
  /** @export */
  emscripten_glReadBuffer: _emscripten_glReadBuffer,
  /** @export */
  emscripten_glReadPixels: _emscripten_glReadPixels,
  /** @export */
  emscripten_glReleaseShaderCompiler: _emscripten_glReleaseShaderCompiler,
  /** @export */
  emscripten_glRenderbufferStorage: _emscripten_glRenderbufferStorage,
  /** @export */
  emscripten_glRenderbufferStorageMultisample: _emscripten_glRenderbufferStorageMultisample,
  /** @export */
  emscripten_glResumeTransformFeedback: _emscripten_glResumeTransformFeedback,
  /** @export */
  emscripten_glSampleCoverage: _emscripten_glSampleCoverage,
  /** @export */
  emscripten_glSamplerParameterf: _emscripten_glSamplerParameterf,
  /** @export */
  emscripten_glSamplerParameterfv: _emscripten_glSamplerParameterfv,
  /** @export */
  emscripten_glSamplerParameteri: _emscripten_glSamplerParameteri,
  /** @export */
  emscripten_glSamplerParameteriv: _emscripten_glSamplerParameteriv,
  /** @export */
  emscripten_glScissor: _emscripten_glScissor,
  /** @export */
  emscripten_glShaderBinary: _emscripten_glShaderBinary,
  /** @export */
  emscripten_glShaderSource: _emscripten_glShaderSource,
  /** @export */
  emscripten_glStencilFunc: _emscripten_glStencilFunc,
  /** @export */
  emscripten_glStencilFuncSeparate: _emscripten_glStencilFuncSeparate,
  /** @export */
  emscripten_glStencilMask: _emscripten_glStencilMask,
  /** @export */
  emscripten_glStencilMaskSeparate: _emscripten_glStencilMaskSeparate,
  /** @export */
  emscripten_glStencilOp: _emscripten_glStencilOp,
  /** @export */
  emscripten_glStencilOpSeparate: _emscripten_glStencilOpSeparate,
  /** @export */
  emscripten_glTexImage2D: _emscripten_glTexImage2D,
  /** @export */
  emscripten_glTexImage3D: _emscripten_glTexImage3D,
  /** @export */
  emscripten_glTexParameterf: _emscripten_glTexParameterf,
  /** @export */
  emscripten_glTexParameterfv: _emscripten_glTexParameterfv,
  /** @export */
  emscripten_glTexParameteri: _emscripten_glTexParameteri,
  /** @export */
  emscripten_glTexParameteriv: _emscripten_glTexParameteriv,
  /** @export */
  emscripten_glTexStorage2D: _emscripten_glTexStorage2D,
  /** @export */
  emscripten_glTexStorage3D: _emscripten_glTexStorage3D,
  /** @export */
  emscripten_glTexSubImage2D: _emscripten_glTexSubImage2D,
  /** @export */
  emscripten_glTexSubImage3D: _emscripten_glTexSubImage3D,
  /** @export */
  emscripten_glTransformFeedbackVaryings: _emscripten_glTransformFeedbackVaryings,
  /** @export */
  emscripten_glUniform1f: _emscripten_glUniform1f,
  /** @export */
  emscripten_glUniform1fv: _emscripten_glUniform1fv,
  /** @export */
  emscripten_glUniform1i: _emscripten_glUniform1i,
  /** @export */
  emscripten_glUniform1iv: _emscripten_glUniform1iv,
  /** @export */
  emscripten_glUniform1ui: _emscripten_glUniform1ui,
  /** @export */
  emscripten_glUniform1uiv: _emscripten_glUniform1uiv,
  /** @export */
  emscripten_glUniform2f: _emscripten_glUniform2f,
  /** @export */
  emscripten_glUniform2fv: _emscripten_glUniform2fv,
  /** @export */
  emscripten_glUniform2i: _emscripten_glUniform2i,
  /** @export */
  emscripten_glUniform2iv: _emscripten_glUniform2iv,
  /** @export */
  emscripten_glUniform2ui: _emscripten_glUniform2ui,
  /** @export */
  emscripten_glUniform2uiv: _emscripten_glUniform2uiv,
  /** @export */
  emscripten_glUniform3f: _emscripten_glUniform3f,
  /** @export */
  emscripten_glUniform3fv: _emscripten_glUniform3fv,
  /** @export */
  emscripten_glUniform3i: _emscripten_glUniform3i,
  /** @export */
  emscripten_glUniform3iv: _emscripten_glUniform3iv,
  /** @export */
  emscripten_glUniform3ui: _emscripten_glUniform3ui,
  /** @export */
  emscripten_glUniform3uiv: _emscripten_glUniform3uiv,
  /** @export */
  emscripten_glUniform4f: _emscripten_glUniform4f,
  /** @export */
  emscripten_glUniform4fv: _emscripten_glUniform4fv,
  /** @export */
  emscripten_glUniform4i: _emscripten_glUniform4i,
  /** @export */
  emscripten_glUniform4iv: _emscripten_glUniform4iv,
  /** @export */
  emscripten_glUniform4ui: _emscripten_glUniform4ui,
  /** @export */
  emscripten_glUniform4uiv: _emscripten_glUniform4uiv,
  /** @export */
  emscripten_glUniformBlockBinding: _emscripten_glUniformBlockBinding,
  /** @export */
  emscripten_glUniformMatrix2fv: _emscripten_glUniformMatrix2fv,
  /** @export */
  emscripten_glUniformMatrix2x3fv: _emscripten_glUniformMatrix2x3fv,
  /** @export */
  emscripten_glUniformMatrix2x4fv: _emscripten_glUniformMatrix2x4fv,
  /** @export */
  emscripten_glUniformMatrix3fv: _emscripten_glUniformMatrix3fv,
  /** @export */
  emscripten_glUniformMatrix3x2fv: _emscripten_glUniformMatrix3x2fv,
  /** @export */
  emscripten_glUniformMatrix3x4fv: _emscripten_glUniformMatrix3x4fv,
  /** @export */
  emscripten_glUniformMatrix4fv: _emscripten_glUniformMatrix4fv,
  /** @export */
  emscripten_glUniformMatrix4x2fv: _emscripten_glUniformMatrix4x2fv,
  /** @export */
  emscripten_glUniformMatrix4x3fv: _emscripten_glUniformMatrix4x3fv,
  /** @export */
  emscripten_glUnmapBuffer: _emscripten_glUnmapBuffer,
  /** @export */
  emscripten_glUseProgram: _emscripten_glUseProgram,
  /** @export */
  emscripten_glValidateProgram: _emscripten_glValidateProgram,
  /** @export */
  emscripten_glVertexAttrib1f: _emscripten_glVertexAttrib1f,
  /** @export */
  emscripten_glVertexAttrib1fv: _emscripten_glVertexAttrib1fv,
  /** @export */
  emscripten_glVertexAttrib2f: _emscripten_glVertexAttrib2f,
  /** @export */
  emscripten_glVertexAttrib2fv: _emscripten_glVertexAttrib2fv,
  /** @export */
  emscripten_glVertexAttrib3f: _emscripten_glVertexAttrib3f,
  /** @export */
  emscripten_glVertexAttrib3fv: _emscripten_glVertexAttrib3fv,
  /** @export */
  emscripten_glVertexAttrib4f: _emscripten_glVertexAttrib4f,
  /** @export */
  emscripten_glVertexAttrib4fv: _emscripten_glVertexAttrib4fv,
  /** @export */
  emscripten_glVertexAttribDivisor: _emscripten_glVertexAttribDivisor,
  /** @export */
  emscripten_glVertexAttribDivisorANGLE: _emscripten_glVertexAttribDivisorANGLE,
  /** @export */
  emscripten_glVertexAttribDivisorARB: _emscripten_glVertexAttribDivisorARB,
  /** @export */
  emscripten_glVertexAttribDivisorEXT: _emscripten_glVertexAttribDivisorEXT,
  /** @export */
  emscripten_glVertexAttribDivisorNV: _emscripten_glVertexAttribDivisorNV,
  /** @export */
  emscripten_glVertexAttribI4i: _emscripten_glVertexAttribI4i,
  /** @export */
  emscripten_glVertexAttribI4iv: _emscripten_glVertexAttribI4iv,
  /** @export */
  emscripten_glVertexAttribI4ui: _emscripten_glVertexAttribI4ui,
  /** @export */
  emscripten_glVertexAttribI4uiv: _emscripten_glVertexAttribI4uiv,
  /** @export */
  emscripten_glVertexAttribIPointer: _emscripten_glVertexAttribIPointer,
  /** @export */
  emscripten_glVertexAttribPointer: _emscripten_glVertexAttribPointer,
  /** @export */
  emscripten_glVertexPointer: _emscripten_glVertexPointer,
  /** @export */
  emscripten_glViewport: _emscripten_glViewport,
  /** @export */
  emscripten_glWaitSync: _emscripten_glWaitSync,
  /** @export */
  emscripten_has_asyncify: _emscripten_has_asyncify,
  /** @export */
  emscripten_hide_mouse: _emscripten_hide_mouse,
  /** @export */
  emscripten_html5_remove_all_event_listeners: _emscripten_html5_remove_all_event_listeners,
  /** @export */
  emscripten_idb_async_clear: _emscripten_idb_async_clear,
  /** @export */
  emscripten_idb_async_delete: _emscripten_idb_async_delete,
  /** @export */
  emscripten_idb_async_exists: _emscripten_idb_async_exists,
  /** @export */
  emscripten_idb_async_load: _emscripten_idb_async_load,
  /** @export */
  emscripten_idb_async_store: _emscripten_idb_async_store,
  /** @export */
  emscripten_idb_clear: _emscripten_idb_clear,
  /** @export */
  emscripten_idb_delete: _emscripten_idb_delete,
  /** @export */
  emscripten_idb_exists: _emscripten_idb_exists,
  /** @export */
  emscripten_idb_load: _emscripten_idb_load,
  /** @export */
  emscripten_idb_store: _emscripten_idb_store,
  /** @export */
  emscripten_is_main_browser_thread: _emscripten_is_main_browser_thread,
  /** @export */
  emscripten_is_webgl_context_lost: _emscripten_is_webgl_context_lost,
  /** @export */
  emscripten_lock_orientation: _emscripten_lock_orientation,
  /** @export */
  emscripten_log: _emscripten_log,
  /** @export */
  emscripten_math_acos: _emscripten_math_acos,
  /** @export */
  emscripten_math_acosh: _emscripten_math_acosh,
  /** @export */
  emscripten_math_asin: _emscripten_math_asin,
  /** @export */
  emscripten_math_asinh: _emscripten_math_asinh,
  /** @export */
  emscripten_math_atan: _emscripten_math_atan,
  /** @export */
  emscripten_math_atan2: _emscripten_math_atan2,
  /** @export */
  emscripten_math_atanh: _emscripten_math_atanh,
  /** @export */
  emscripten_math_cbrt: _emscripten_math_cbrt,
  /** @export */
  emscripten_math_cos: _emscripten_math_cos,
  /** @export */
  emscripten_math_cosh: _emscripten_math_cosh,
  /** @export */
  emscripten_math_exp: _emscripten_math_exp,
  /** @export */
  emscripten_math_expm1: _emscripten_math_expm1,
  /** @export */
  emscripten_math_fmod: _emscripten_math_fmod,
  /** @export */
  emscripten_math_hypot: _emscripten_math_hypot,
  /** @export */
  emscripten_math_log: _emscripten_math_log,
  /** @export */
  emscripten_math_log10: _emscripten_math_log10,
  /** @export */
  emscripten_math_log1p: _emscripten_math_log1p,
  /** @export */
  emscripten_math_log2: _emscripten_math_log2,
  /** @export */
  emscripten_math_pow: _emscripten_math_pow,
  /** @export */
  emscripten_math_random: _emscripten_math_random,
  /** @export */
  emscripten_math_round: _emscripten_math_round,
  /** @export */
  emscripten_math_sign: _emscripten_math_sign,
  /** @export */
  emscripten_math_sin: _emscripten_math_sin,
  /** @export */
  emscripten_math_sinh: _emscripten_math_sinh,
  /** @export */
  emscripten_math_sqrt: _emscripten_math_sqrt,
  /** @export */
  emscripten_math_tan: _emscripten_math_tan,
  /** @export */
  emscripten_math_tanh: _emscripten_math_tanh,
  /** @export */
  emscripten_notify_memory_growth: _emscripten_notify_memory_growth,
  /** @export */
  emscripten_out: _emscripten_out,
  /** @export */
  emscripten_outn: _emscripten_outn,
  /** @export */
  emscripten_pause_main_loop: _emscripten_pause_main_loop,
  /** @export */
  emscripten_pc_get_column: _emscripten_pc_get_column,
  /** @export */
  emscripten_pc_get_file: _emscripten_pc_get_file,
  /** @export */
  emscripten_pc_get_function: _emscripten_pc_get_function,
  /** @export */
  emscripten_pc_get_line: _emscripten_pc_get_line,
  /** @export */
  emscripten_performance_now: _emscripten_performance_now,
  /** @export */
  emscripten_print_double: _emscripten_print_double,
  /** @export */
  emscripten_promise_all: _emscripten_promise_all,
  /** @export */
  emscripten_promise_all_settled: _emscripten_promise_all_settled,
  /** @export */
  emscripten_promise_any: _emscripten_promise_any,
  /** @export */
  emscripten_promise_await: _emscripten_promise_await,
  /** @export */
  emscripten_promise_create: _emscripten_promise_create,
  /** @export */
  emscripten_promise_destroy: _emscripten_promise_destroy,
  /** @export */
  emscripten_promise_race: _emscripten_promise_race,
  /** @export */
  emscripten_promise_resolve: _emscripten_promise_resolve,
  /** @export */
  emscripten_promise_then: _emscripten_promise_then,
  /** @export */
  emscripten_random: _emscripten_random,
  /** @export */
  emscripten_request_animation_frame: _emscripten_request_animation_frame,
  /** @export */
  emscripten_request_animation_frame_loop: _emscripten_request_animation_frame_loop,
  /** @export */
  emscripten_request_fullscreen: _emscripten_request_fullscreen,
  /** @export */
  emscripten_request_fullscreen_strategy: _emscripten_request_fullscreen_strategy,
  /** @export */
  emscripten_request_pointerlock: _emscripten_request_pointerlock,
  /** @export */
  emscripten_resize_heap: _emscripten_resize_heap,
  /** @export */
  emscripten_resume_main_loop: _emscripten_resume_main_loop,
  /** @export */
  emscripten_return_address: _emscripten_return_address,
  /** @export */
  emscripten_run_preload_plugins: _emscripten_run_preload_plugins,
  /** @export */
  emscripten_run_preload_plugins_data: _emscripten_run_preload_plugins_data,
  /** @export */
  emscripten_run_script: _emscripten_run_script,
  /** @export */
  emscripten_run_script_int: _emscripten_run_script_int,
  /** @export */
  emscripten_run_script_string: _emscripten_run_script_string,
  /** @export */
  emscripten_runtime_keepalive_check: _emscripten_runtime_keepalive_check,
  /** @export */
  emscripten_runtime_keepalive_pop: _emscripten_runtime_keepalive_pop,
  /** @export */
  emscripten_runtime_keepalive_push: _emscripten_runtime_keepalive_push,
  /** @export */
  emscripten_sample_gamepad_data: _emscripten_sample_gamepad_data,
  /** @export */
  emscripten_scan_registers: _emscripten_scan_registers,
  /** @export */
  emscripten_set_batterychargingchange_callback_on_thread: _emscripten_set_batterychargingchange_callback_on_thread,
  /** @export */
  emscripten_set_batterylevelchange_callback_on_thread: _emscripten_set_batterylevelchange_callback_on_thread,
  /** @export */
  emscripten_set_beforeunload_callback_on_thread: _emscripten_set_beforeunload_callback_on_thread,
  /** @export */
  emscripten_set_blur_callback_on_thread: _emscripten_set_blur_callback_on_thread,
  /** @export */
  emscripten_set_canvas_element_size: _emscripten_set_canvas_element_size,
  /** @export */
  emscripten_set_canvas_size: _emscripten_set_canvas_size,
  /** @export */
  emscripten_set_click_callback_on_thread: _emscripten_set_click_callback_on_thread,
  /** @export */
  emscripten_set_dblclick_callback_on_thread: _emscripten_set_dblclick_callback_on_thread,
  /** @export */
  emscripten_set_devicemotion_callback_on_thread: _emscripten_set_devicemotion_callback_on_thread,
  /** @export */
  emscripten_set_deviceorientation_callback_on_thread: _emscripten_set_deviceorientation_callback_on_thread,
  /** @export */
  emscripten_set_element_css_size: _emscripten_set_element_css_size,
  /** @export */
  emscripten_set_focus_callback_on_thread: _emscripten_set_focus_callback_on_thread,
  /** @export */
  emscripten_set_focusin_callback_on_thread: _emscripten_set_focusin_callback_on_thread,
  /** @export */
  emscripten_set_focusout_callback_on_thread: _emscripten_set_focusout_callback_on_thread,
  /** @export */
  emscripten_set_fullscreenchange_callback_on_thread: _emscripten_set_fullscreenchange_callback_on_thread,
  /** @export */
  emscripten_set_gamepadconnected_callback_on_thread: _emscripten_set_gamepadconnected_callback_on_thread,
  /** @export */
  emscripten_set_gamepaddisconnected_callback_on_thread: _emscripten_set_gamepaddisconnected_callback_on_thread,
  /** @export */
  emscripten_set_immediate: _emscripten_set_immediate,
  /** @export */
  emscripten_set_immediate_loop: _emscripten_set_immediate_loop,
  /** @export */
  emscripten_set_interval: _emscripten_set_interval,
  /** @export */
  emscripten_set_keydown_callback_on_thread: _emscripten_set_keydown_callback_on_thread,
  /** @export */
  emscripten_set_keypress_callback_on_thread: _emscripten_set_keypress_callback_on_thread,
  /** @export */
  emscripten_set_keyup_callback_on_thread: _emscripten_set_keyup_callback_on_thread,
  /** @export */
  emscripten_set_main_loop: _emscripten_set_main_loop,
  /** @export */
  emscripten_set_main_loop_arg: _emscripten_set_main_loop_arg,
  /** @export */
  emscripten_set_main_loop_expected_blockers: _emscripten_set_main_loop_expected_blockers,
  /** @export */
  emscripten_set_main_loop_timing: _emscripten_set_main_loop_timing,
  /** @export */
  emscripten_set_mousedown_callback_on_thread: _emscripten_set_mousedown_callback_on_thread,
  /** @export */
  emscripten_set_mouseenter_callback_on_thread: _emscripten_set_mouseenter_callback_on_thread,
  /** @export */
  emscripten_set_mouseleave_callback_on_thread: _emscripten_set_mouseleave_callback_on_thread,
  /** @export */
  emscripten_set_mousemove_callback_on_thread: _emscripten_set_mousemove_callback_on_thread,
  /** @export */
  emscripten_set_mouseout_callback_on_thread: _emscripten_set_mouseout_callback_on_thread,
  /** @export */
  emscripten_set_mouseover_callback_on_thread: _emscripten_set_mouseover_callback_on_thread,
  /** @export */
  emscripten_set_mouseup_callback_on_thread: _emscripten_set_mouseup_callback_on_thread,
  /** @export */
  emscripten_set_orientationchange_callback_on_thread: _emscripten_set_orientationchange_callback_on_thread,
  /** @export */
  emscripten_set_pointerlockchange_callback_on_thread: _emscripten_set_pointerlockchange_callback_on_thread,
  /** @export */
  emscripten_set_pointerlockerror_callback_on_thread: _emscripten_set_pointerlockerror_callback_on_thread,
  /** @export */
  emscripten_set_resize_callback_on_thread: _emscripten_set_resize_callback_on_thread,
  /** @export */
  emscripten_set_scroll_callback_on_thread: _emscripten_set_scroll_callback_on_thread,
  /** @export */
  emscripten_set_socket_close_callback: _emscripten_set_socket_close_callback,
  /** @export */
  emscripten_set_socket_connection_callback: _emscripten_set_socket_connection_callback,
  /** @export */
  emscripten_set_socket_error_callback: _emscripten_set_socket_error_callback,
  /** @export */
  emscripten_set_socket_listen_callback: _emscripten_set_socket_listen_callback,
  /** @export */
  emscripten_set_socket_message_callback: _emscripten_set_socket_message_callback,
  /** @export */
  emscripten_set_socket_open_callback: _emscripten_set_socket_open_callback,
  /** @export */
  emscripten_set_timeout: _emscripten_set_timeout,
  /** @export */
  emscripten_set_timeout_loop: _emscripten_set_timeout_loop,
  /** @export */
  emscripten_set_touchcancel_callback_on_thread: _emscripten_set_touchcancel_callback_on_thread,
  /** @export */
  emscripten_set_touchend_callback_on_thread: _emscripten_set_touchend_callback_on_thread,
  /** @export */
  emscripten_set_touchmove_callback_on_thread: _emscripten_set_touchmove_callback_on_thread,
  /** @export */
  emscripten_set_touchstart_callback_on_thread: _emscripten_set_touchstart_callback_on_thread,
  /** @export */
  emscripten_set_visibilitychange_callback_on_thread: _emscripten_set_visibilitychange_callback_on_thread,
  /** @export */
  emscripten_set_webglcontextlost_callback_on_thread: _emscripten_set_webglcontextlost_callback_on_thread,
  /** @export */
  emscripten_set_webglcontextrestored_callback_on_thread: _emscripten_set_webglcontextrestored_callback_on_thread,
  /** @export */
  emscripten_set_wheel_callback_on_thread: _emscripten_set_wheel_callback_on_thread,
  /** @export */
  emscripten_set_window_title: _emscripten_set_window_title,
  /** @export */
  emscripten_sleep: _emscripten_sleep,
  /** @export */
  emscripten_stack_snapshot: _emscripten_stack_snapshot,
  /** @export */
  emscripten_stack_unwind_buffer: _emscripten_stack_unwind_buffer,
  /** @export */
  emscripten_supports_offscreencanvas: _emscripten_supports_offscreencanvas,
  /** @export */
  emscripten_throw_number: _emscripten_throw_number,
  /** @export */
  emscripten_throw_string: _emscripten_throw_string,
  /** @export */
  emscripten_unlock_orientation: _emscripten_unlock_orientation,
  /** @export */
  emscripten_unwind_to_js_event_loop: _emscripten_unwind_to_js_event_loop,
  /** @export */
  emscripten_vibrate: _emscripten_vibrate,
  /** @export */
  emscripten_vibrate_pattern: _emscripten_vibrate_pattern,
  /** @export */
  emscripten_webgl_commit_frame: _emscripten_webgl_commit_frame,
  /** @export */
  emscripten_webgl_create_context: _emscripten_webgl_create_context,
  /** @export */
  emscripten_webgl_destroy_context: _emscripten_webgl_destroy_context,
  /** @export */
  emscripten_webgl_do_commit_frame: _emscripten_webgl_do_commit_frame,
  /** @export */
  emscripten_webgl_do_create_context: _emscripten_webgl_do_create_context,
  /** @export */
  emscripten_webgl_do_get_current_context: _emscripten_webgl_do_get_current_context,
  /** @export */
  emscripten_webgl_enable_EXT_clip_control: _emscripten_webgl_enable_EXT_clip_control,
  /** @export */
  emscripten_webgl_enable_EXT_polygon_offset_clamp: _emscripten_webgl_enable_EXT_polygon_offset_clamp,
  /** @export */
  emscripten_webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance: _emscripten_webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance,
  /** @export */
  emscripten_webgl_enable_WEBGL_multi_draw: _emscripten_webgl_enable_WEBGL_multi_draw,
  /** @export */
  emscripten_webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance: _emscripten_webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance,
  /** @export */
  emscripten_webgl_enable_WEBGL_polygon_mode: _emscripten_webgl_enable_WEBGL_polygon_mode,
  /** @export */
  emscripten_webgl_enable_extension: _emscripten_webgl_enable_extension,
  /** @export */
  emscripten_webgl_get_context_attributes: _emscripten_webgl_get_context_attributes,
  /** @export */
  emscripten_webgl_get_current_context: _emscripten_webgl_get_current_context,
  /** @export */
  emscripten_webgl_get_drawing_buffer_size: _emscripten_webgl_get_drawing_buffer_size,
  /** @export */
  emscripten_webgl_get_parameter_d: _emscripten_webgl_get_parameter_d,
  /** @export */
  emscripten_webgl_get_parameter_i64v: _emscripten_webgl_get_parameter_i64v,
  /** @export */
  emscripten_webgl_get_parameter_o: _emscripten_webgl_get_parameter_o,
  /** @export */
  emscripten_webgl_get_parameter_utf8: _emscripten_webgl_get_parameter_utf8,
  /** @export */
  emscripten_webgl_get_parameter_v: _emscripten_webgl_get_parameter_v,
  /** @export */
  emscripten_webgl_get_program_info_log_utf8: _emscripten_webgl_get_program_info_log_utf8,
  /** @export */
  emscripten_webgl_get_program_parameter_d: _emscripten_webgl_get_program_parameter_d,
  /** @export */
  emscripten_webgl_get_shader_info_log_utf8: _emscripten_webgl_get_shader_info_log_utf8,
  /** @export */
  emscripten_webgl_get_shader_parameter_d: _emscripten_webgl_get_shader_parameter_d,
  /** @export */
  emscripten_webgl_get_shader_source_utf8: _emscripten_webgl_get_shader_source_utf8,
  /** @export */
  emscripten_webgl_get_supported_extensions: _emscripten_webgl_get_supported_extensions,
  /** @export */
  emscripten_webgl_get_uniform_d: _emscripten_webgl_get_uniform_d,
  /** @export */
  emscripten_webgl_get_uniform_v: _emscripten_webgl_get_uniform_v,
  /** @export */
  emscripten_webgl_get_vertex_attrib_d: _emscripten_webgl_get_vertex_attrib_d,
  /** @export */
  emscripten_webgl_get_vertex_attrib_o: _emscripten_webgl_get_vertex_attrib_o,
  /** @export */
  emscripten_webgl_get_vertex_attrib_v: _emscripten_webgl_get_vertex_attrib_v,
  /** @export */
  emscripten_webgl_make_context_current: _emscripten_webgl_make_context_current,
  /** @export */
  emscripten_wget_data: _emscripten_wget_data,
  /** @export */
  endprotoent: _endprotoent,
  /** @export */
  environ_get: _environ_get,
  /** @export */
  environ_sizes_get: _environ_sizes_get,
  /** @export */
  exit: _exit,
  /** @export */
  fd_close: _fd_close,
  /** @export */
  fd_fdstat_get: _fd_fdstat_get,
  /** @export */
  fd_pread: _fd_pread,
  /** @export */
  fd_pwrite: _fd_pwrite,
  /** @export */
  fd_read: _fd_read,
  /** @export */
  fd_seek: _fd_seek,
  /** @export */
  fd_sync: _fd_sync,
  /** @export */
  fd_write: _fd_write,
  /** @export */
  ffi_call_js,
  /** @export */
  ffi_closure_alloc_js,
  /** @export */
  ffi_closure_free_js,
  /** @export */
  ffi_prep_closure_loc_js,
  /** @export */
  filledEllipseColor: _filledEllipseColor,
  /** @export */
  filledEllipseRGBA: _filledEllipseRGBA,
  /** @export */
  getaddrinfo: _getaddrinfo,
  /** @export */
  getnameinfo: _getnameinfo,
  /** @export */
  getprotobyname: _getprotobyname,
  /** @export */
  getprotobynumber: _getprotobynumber,
  /** @export */
  getprotoent: _getprotoent,
  /** @export */
  glActiveTexture: _glActiveTexture,
  /** @export */
  glAttachShader: _glAttachShader,
  /** @export */
  glBegin: _glBegin,
  /** @export */
  glBeginQuery: _glBeginQuery,
  /** @export */
  glBeginQueryEXT: _glBeginQueryEXT,
  /** @export */
  glBeginTransformFeedback: _glBeginTransformFeedback,
  /** @export */
  glBindAttribLocation: _glBindAttribLocation,
  /** @export */
  glBindBuffer: _glBindBuffer,
  /** @export */
  glBindBufferBase: _glBindBufferBase,
  /** @export */
  glBindBufferRange: _glBindBufferRange,
  /** @export */
  glBindFramebuffer: _glBindFramebuffer,
  /** @export */
  glBindRenderbuffer: _glBindRenderbuffer,
  /** @export */
  glBindSampler: _glBindSampler,
  /** @export */
  glBindTexture: _glBindTexture,
  /** @export */
  glBindTransformFeedback: _glBindTransformFeedback,
  /** @export */
  glBindVertexArray: _glBindVertexArray,
  /** @export */
  glBindVertexArrayOES: _glBindVertexArrayOES,
  /** @export */
  glBlendColor: _glBlendColor,
  /** @export */
  glBlendEquation: _glBlendEquation,
  /** @export */
  glBlendEquationSeparate: _glBlendEquationSeparate,
  /** @export */
  glBlendFunc: _glBlendFunc,
  /** @export */
  glBlendFuncSeparate: _glBlendFuncSeparate,
  /** @export */
  glBlitFramebuffer: _glBlitFramebuffer,
  /** @export */
  glBufferData: _glBufferData,
  /** @export */
  glBufferSubData: _glBufferSubData,
  /** @export */
  glCheckFramebufferStatus: _glCheckFramebufferStatus,
  /** @export */
  glClear: _glClear,
  /** @export */
  glClearBufferfi: _glClearBufferfi,
  /** @export */
  glClearBufferfv: _glClearBufferfv,
  /** @export */
  glClearBufferiv: _glClearBufferiv,
  /** @export */
  glClearBufferuiv: _glClearBufferuiv,
  /** @export */
  glClearColor: _glClearColor,
  /** @export */
  glClearDepth: _glClearDepth,
  /** @export */
  glClearDepthf: _glClearDepthf,
  /** @export */
  glClearStencil: _glClearStencil,
  /** @export */
  glClientWaitSync: _glClientWaitSync,
  /** @export */
  glClipControlEXT: _glClipControlEXT,
  /** @export */
  glColorMask: _glColorMask,
  /** @export */
  glCompileShader: _glCompileShader,
  /** @export */
  glCompressedTexImage2D: _glCompressedTexImage2D,
  /** @export */
  glCompressedTexImage3D: _glCompressedTexImage3D,
  /** @export */
  glCompressedTexSubImage2D: _glCompressedTexSubImage2D,
  /** @export */
  glCompressedTexSubImage3D: _glCompressedTexSubImage3D,
  /** @export */
  glCopyBufferSubData: _glCopyBufferSubData,
  /** @export */
  glCopyTexImage2D: _glCopyTexImage2D,
  /** @export */
  glCopyTexSubImage2D: _glCopyTexSubImage2D,
  /** @export */
  glCopyTexSubImage3D: _glCopyTexSubImage3D,
  /** @export */
  glCreateProgram: _glCreateProgram,
  /** @export */
  glCreateShader: _glCreateShader,
  /** @export */
  glCullFace: _glCullFace,
  /** @export */
  glDeleteBuffers: _glDeleteBuffers,
  /** @export */
  glDeleteFramebuffers: _glDeleteFramebuffers,
  /** @export */
  glDeleteProgram: _glDeleteProgram,
  /** @export */
  glDeleteQueries: _glDeleteQueries,
  /** @export */
  glDeleteQueriesEXT: _glDeleteQueriesEXT,
  /** @export */
  glDeleteRenderbuffers: _glDeleteRenderbuffers,
  /** @export */
  glDeleteSamplers: _glDeleteSamplers,
  /** @export */
  glDeleteShader: _glDeleteShader,
  /** @export */
  glDeleteSync: _glDeleteSync,
  /** @export */
  glDeleteTextures: _glDeleteTextures,
  /** @export */
  glDeleteTransformFeedbacks: _glDeleteTransformFeedbacks,
  /** @export */
  glDeleteVertexArrays: _glDeleteVertexArrays,
  /** @export */
  glDeleteVertexArraysOES: _glDeleteVertexArraysOES,
  /** @export */
  glDepthFunc: _glDepthFunc,
  /** @export */
  glDepthMask: _glDepthMask,
  /** @export */
  glDepthRange: _glDepthRange,
  /** @export */
  glDepthRangef: _glDepthRangef,
  /** @export */
  glDetachShader: _glDetachShader,
  /** @export */
  glDisable: _glDisable,
  /** @export */
  glDisableVertexAttribArray: _glDisableVertexAttribArray,
  /** @export */
  glDrawArrays: _glDrawArrays,
  /** @export */
  glDrawArraysInstanced: _glDrawArraysInstanced,
  /** @export */
  glDrawArraysInstancedANGLE: _glDrawArraysInstancedANGLE,
  /** @export */
  glDrawArraysInstancedARB: _glDrawArraysInstancedARB,
  /** @export */
  glDrawArraysInstancedBaseInstance: _glDrawArraysInstancedBaseInstance,
  /** @export */
  glDrawArraysInstancedBaseInstanceANGLE: _glDrawArraysInstancedBaseInstanceANGLE,
  /** @export */
  glDrawArraysInstancedBaseInstanceWEBGL: _glDrawArraysInstancedBaseInstanceWEBGL,
  /** @export */
  glDrawArraysInstancedEXT: _glDrawArraysInstancedEXT,
  /** @export */
  glDrawArraysInstancedNV: _glDrawArraysInstancedNV,
  /** @export */
  glDrawBuffers: _glDrawBuffers,
  /** @export */
  glDrawBuffersEXT: _glDrawBuffersEXT,
  /** @export */
  glDrawBuffersWEBGL: _glDrawBuffersWEBGL,
  /** @export */
  glDrawElements: _glDrawElements,
  /** @export */
  glDrawElementsInstanced: _glDrawElementsInstanced,
  /** @export */
  glDrawElementsInstancedANGLE: _glDrawElementsInstancedANGLE,
  /** @export */
  glDrawElementsInstancedARB: _glDrawElementsInstancedARB,
  /** @export */
  glDrawElementsInstancedBaseVertexBaseInstanceANGLE: _glDrawElementsInstancedBaseVertexBaseInstanceANGLE,
  /** @export */
  glDrawElementsInstancedBaseVertexBaseInstanceWEBGL: _glDrawElementsInstancedBaseVertexBaseInstanceWEBGL,
  /** @export */
  glDrawElementsInstancedEXT: _glDrawElementsInstancedEXT,
  /** @export */
  glDrawElementsInstancedNV: _glDrawElementsInstancedNV,
  /** @export */
  glDrawRangeElements: _glDrawRangeElements,
  /** @export */
  glEnable: _glEnable,
  /** @export */
  glEnableVertexAttribArray: _glEnableVertexAttribArray,
  /** @export */
  glEndQuery: _glEndQuery,
  /** @export */
  glEndQueryEXT: _glEndQueryEXT,
  /** @export */
  glEndTransformFeedback: _glEndTransformFeedback,
  /** @export */
  glFenceSync: _glFenceSync,
  /** @export */
  glFinish: _glFinish,
  /** @export */
  glFlush: _glFlush,
  /** @export */
  glFlushMappedBufferRange: _glFlushMappedBufferRange,
  /** @export */
  glFramebufferRenderbuffer: _glFramebufferRenderbuffer,
  /** @export */
  glFramebufferTexture2D: _glFramebufferTexture2D,
  /** @export */
  glFramebufferTextureLayer: _glFramebufferTextureLayer,
  /** @export */
  glFrontFace: _glFrontFace,
  /** @export */
  glGenBuffers: _glGenBuffers,
  /** @export */
  glGenFramebuffers: _glGenFramebuffers,
  /** @export */
  glGenQueries: _glGenQueries,
  /** @export */
  glGenQueriesEXT: _glGenQueriesEXT,
  /** @export */
  glGenRenderbuffers: _glGenRenderbuffers,
  /** @export */
  glGenSamplers: _glGenSamplers,
  /** @export */
  glGenTextures: _glGenTextures,
  /** @export */
  glGenTransformFeedbacks: _glGenTransformFeedbacks,
  /** @export */
  glGenVertexArrays: _glGenVertexArrays,
  /** @export */
  glGenVertexArraysOES: _glGenVertexArraysOES,
  /** @export */
  glGenerateMipmap: _glGenerateMipmap,
  /** @export */
  glGetActiveAttrib: _glGetActiveAttrib,
  /** @export */
  glGetActiveUniform: _glGetActiveUniform,
  /** @export */
  glGetActiveUniformBlockName: _glGetActiveUniformBlockName,
  /** @export */
  glGetActiveUniformBlockiv: _glGetActiveUniformBlockiv,
  /** @export */
  glGetActiveUniformsiv: _glGetActiveUniformsiv,
  /** @export */
  glGetAttachedShaders: _glGetAttachedShaders,
  /** @export */
  glGetAttribLocation: _glGetAttribLocation,
  /** @export */
  glGetBooleanv: _glGetBooleanv,
  /** @export */
  glGetBufferParameteri64v: _glGetBufferParameteri64v,
  /** @export */
  glGetBufferParameteriv: _glGetBufferParameteriv,
  /** @export */
  glGetBufferPointerv: _glGetBufferPointerv,
  /** @export */
  glGetBufferSubData: _glGetBufferSubData,
  /** @export */
  glGetError: _glGetError,
  /** @export */
  glGetFloatv: _glGetFloatv,
  /** @export */
  glGetFragDataLocation: _glGetFragDataLocation,
  /** @export */
  glGetFramebufferAttachmentParameteriv: _glGetFramebufferAttachmentParameteriv,
  /** @export */
  glGetInteger64i_v: _glGetInteger64i_v,
  /** @export */
  glGetInteger64v: _glGetInteger64v,
  /** @export */
  glGetIntegeri_v: _glGetIntegeri_v,
  /** @export */
  glGetIntegerv: _glGetIntegerv,
  /** @export */
  glGetInternalformativ: _glGetInternalformativ,
  /** @export */
  glGetProgramBinary: _glGetProgramBinary,
  /** @export */
  glGetProgramInfoLog: _glGetProgramInfoLog,
  /** @export */
  glGetProgramiv: _glGetProgramiv,
  /** @export */
  glGetQueryObjecti64vEXT: _glGetQueryObjecti64vEXT,
  /** @export */
  glGetQueryObjectivEXT: _glGetQueryObjectivEXT,
  /** @export */
  glGetQueryObjectui64vEXT: _glGetQueryObjectui64vEXT,
  /** @export */
  glGetQueryObjectuiv: _glGetQueryObjectuiv,
  /** @export */
  glGetQueryObjectuivEXT: _glGetQueryObjectuivEXT,
  /** @export */
  glGetQueryiv: _glGetQueryiv,
  /** @export */
  glGetQueryivEXT: _glGetQueryivEXT,
  /** @export */
  glGetRenderbufferParameteriv: _glGetRenderbufferParameteriv,
  /** @export */
  glGetSamplerParameterfv: _glGetSamplerParameterfv,
  /** @export */
  glGetSamplerParameteriv: _glGetSamplerParameteriv,
  /** @export */
  glGetShaderInfoLog: _glGetShaderInfoLog,
  /** @export */
  glGetShaderPrecisionFormat: _glGetShaderPrecisionFormat,
  /** @export */
  glGetShaderSource: _glGetShaderSource,
  /** @export */
  glGetShaderiv: _glGetShaderiv,
  /** @export */
  glGetString: _glGetString,
  /** @export */
  glGetStringi: _glGetStringi,
  /** @export */
  glGetSynciv: _glGetSynciv,
  /** @export */
  glGetTexParameterfv: _glGetTexParameterfv,
  /** @export */
  glGetTexParameteriv: _glGetTexParameteriv,
  /** @export */
  glGetTransformFeedbackVarying: _glGetTransformFeedbackVarying,
  /** @export */
  glGetUniformBlockIndex: _glGetUniformBlockIndex,
  /** @export */
  glGetUniformIndices: _glGetUniformIndices,
  /** @export */
  glGetUniformLocation: _glGetUniformLocation,
  /** @export */
  glGetUniformfv: _glGetUniformfv,
  /** @export */
  glGetUniformiv: _glGetUniformiv,
  /** @export */
  glGetUniformuiv: _glGetUniformuiv,
  /** @export */
  glGetVertexAttribIiv: _glGetVertexAttribIiv,
  /** @export */
  glGetVertexAttribIuiv: _glGetVertexAttribIuiv,
  /** @export */
  glGetVertexAttribPointerv: _glGetVertexAttribPointerv,
  /** @export */
  glGetVertexAttribfv: _glGetVertexAttribfv,
  /** @export */
  glGetVertexAttribiv: _glGetVertexAttribiv,
  /** @export */
  glHint: _glHint,
  /** @export */
  glInvalidateFramebuffer: _glInvalidateFramebuffer,
  /** @export */
  glInvalidateSubFramebuffer: _glInvalidateSubFramebuffer,
  /** @export */
  glIsBuffer: _glIsBuffer,
  /** @export */
  glIsEnabled: _glIsEnabled,
  /** @export */
  glIsFramebuffer: _glIsFramebuffer,
  /** @export */
  glIsProgram: _glIsProgram,
  /** @export */
  glIsQuery: _glIsQuery,
  /** @export */
  glIsQueryEXT: _glIsQueryEXT,
  /** @export */
  glIsRenderbuffer: _glIsRenderbuffer,
  /** @export */
  glIsSampler: _glIsSampler,
  /** @export */
  glIsShader: _glIsShader,
  /** @export */
  glIsSync: _glIsSync,
  /** @export */
  glIsTexture: _glIsTexture,
  /** @export */
  glIsTransformFeedback: _glIsTransformFeedback,
  /** @export */
  glIsVertexArray: _glIsVertexArray,
  /** @export */
  glIsVertexArrayOES: _glIsVertexArrayOES,
  /** @export */
  glLineWidth: _glLineWidth,
  /** @export */
  glLinkProgram: _glLinkProgram,
  /** @export */
  glLoadIdentity: _glLoadIdentity,
  /** @export */
  glMapBufferRange: _glMapBufferRange,
  /** @export */
  glMatrixMode: _glMatrixMode,
  /** @export */
  glMultiDrawArrays: _glMultiDrawArrays,
  /** @export */
  glMultiDrawArraysANGLE: _glMultiDrawArraysANGLE,
  /** @export */
  glMultiDrawArraysInstancedANGLE: _glMultiDrawArraysInstancedANGLE,
  /** @export */
  glMultiDrawArraysInstancedBaseInstanceANGLE: _glMultiDrawArraysInstancedBaseInstanceANGLE,
  /** @export */
  glMultiDrawArraysInstancedBaseInstanceWEBGL: _glMultiDrawArraysInstancedBaseInstanceWEBGL,
  /** @export */
  glMultiDrawArraysInstancedWEBGL: _glMultiDrawArraysInstancedWEBGL,
  /** @export */
  glMultiDrawArraysWEBGL: _glMultiDrawArraysWEBGL,
  /** @export */
  glMultiDrawElements: _glMultiDrawElements,
  /** @export */
  glMultiDrawElementsANGLE: _glMultiDrawElementsANGLE,
  /** @export */
  glMultiDrawElementsInstancedANGLE: _glMultiDrawElementsInstancedANGLE,
  /** @export */
  glMultiDrawElementsInstancedBaseVertexBaseInstanceANGLE: _glMultiDrawElementsInstancedBaseVertexBaseInstanceANGLE,
  /** @export */
  glMultiDrawElementsInstancedBaseVertexBaseInstanceWEBGL: _glMultiDrawElementsInstancedBaseVertexBaseInstanceWEBGL,
  /** @export */
  glMultiDrawElementsInstancedWEBGL: _glMultiDrawElementsInstancedWEBGL,
  /** @export */
  glMultiDrawElementsWEBGL: _glMultiDrawElementsWEBGL,
  /** @export */
  glPauseTransformFeedback: _glPauseTransformFeedback,
  /** @export */
  glPixelStorei: _glPixelStorei,
  /** @export */
  glPolygonModeWEBGL: _glPolygonModeWEBGL,
  /** @export */
  glPolygonOffset: _glPolygonOffset,
  /** @export */
  glPolygonOffsetClampEXT: _glPolygonOffsetClampEXT,
  /** @export */
  glProgramBinary: _glProgramBinary,
  /** @export */
  glProgramParameteri: _glProgramParameteri,
  /** @export */
  glQueryCounterEXT: _glQueryCounterEXT,
  /** @export */
  glReadBuffer: _glReadBuffer,
  /** @export */
  glReadPixels: _glReadPixels,
  /** @export */
  glReleaseShaderCompiler: _glReleaseShaderCompiler,
  /** @export */
  glRenderbufferStorage: _glRenderbufferStorage,
  /** @export */
  glRenderbufferStorageMultisample: _glRenderbufferStorageMultisample,
  /** @export */
  glResumeTransformFeedback: _glResumeTransformFeedback,
  /** @export */
  glSampleCoverage: _glSampleCoverage,
  /** @export */
  glSamplerParameterf: _glSamplerParameterf,
  /** @export */
  glSamplerParameterfv: _glSamplerParameterfv,
  /** @export */
  glSamplerParameteri: _glSamplerParameteri,
  /** @export */
  glSamplerParameteriv: _glSamplerParameteriv,
  /** @export */
  glScissor: _glScissor,
  /** @export */
  glShaderBinary: _glShaderBinary,
  /** @export */
  glShaderSource: _glShaderSource,
  /** @export */
  glStencilFunc: _glStencilFunc,
  /** @export */
  glStencilFuncSeparate: _glStencilFuncSeparate,
  /** @export */
  glStencilMask: _glStencilMask,
  /** @export */
  glStencilMaskSeparate: _glStencilMaskSeparate,
  /** @export */
  glStencilOp: _glStencilOp,
  /** @export */
  glStencilOpSeparate: _glStencilOpSeparate,
  /** @export */
  glTexImage2D: _glTexImage2D,
  /** @export */
  glTexImage3D: _glTexImage3D,
  /** @export */
  glTexParameterf: _glTexParameterf,
  /** @export */
  glTexParameterfv: _glTexParameterfv,
  /** @export */
  glTexParameteri: _glTexParameteri,
  /** @export */
  glTexParameteriv: _glTexParameteriv,
  /** @export */
  glTexStorage2D: _glTexStorage2D,
  /** @export */
  glTexStorage3D: _glTexStorage3D,
  /** @export */
  glTexSubImage2D: _glTexSubImage2D,
  /** @export */
  glTexSubImage3D: _glTexSubImage3D,
  /** @export */
  glTransformFeedbackVaryings: _glTransformFeedbackVaryings,
  /** @export */
  glUniform1f: _glUniform1f,
  /** @export */
  glUniform1fv: _glUniform1fv,
  /** @export */
  glUniform1i: _glUniform1i,
  /** @export */
  glUniform1iv: _glUniform1iv,
  /** @export */
  glUniform1ui: _glUniform1ui,
  /** @export */
  glUniform1uiv: _glUniform1uiv,
  /** @export */
  glUniform2f: _glUniform2f,
  /** @export */
  glUniform2fv: _glUniform2fv,
  /** @export */
  glUniform2i: _glUniform2i,
  /** @export */
  glUniform2iv: _glUniform2iv,
  /** @export */
  glUniform2ui: _glUniform2ui,
  /** @export */
  glUniform2uiv: _glUniform2uiv,
  /** @export */
  glUniform3f: _glUniform3f,
  /** @export */
  glUniform3fv: _glUniform3fv,
  /** @export */
  glUniform3i: _glUniform3i,
  /** @export */
  glUniform3iv: _glUniform3iv,
  /** @export */
  glUniform3ui: _glUniform3ui,
  /** @export */
  glUniform3uiv: _glUniform3uiv,
  /** @export */
  glUniform4f: _glUniform4f,
  /** @export */
  glUniform4fv: _glUniform4fv,
  /** @export */
  glUniform4i: _glUniform4i,
  /** @export */
  glUniform4iv: _glUniform4iv,
  /** @export */
  glUniform4ui: _glUniform4ui,
  /** @export */
  glUniform4uiv: _glUniform4uiv,
  /** @export */
  glUniformBlockBinding: _glUniformBlockBinding,
  /** @export */
  glUniformMatrix2fv: _glUniformMatrix2fv,
  /** @export */
  glUniformMatrix2x3fv: _glUniformMatrix2x3fv,
  /** @export */
  glUniformMatrix2x4fv: _glUniformMatrix2x4fv,
  /** @export */
  glUniformMatrix3fv: _glUniformMatrix3fv,
  /** @export */
  glUniformMatrix3x2fv: _glUniformMatrix3x2fv,
  /** @export */
  glUniformMatrix3x4fv: _glUniformMatrix3x4fv,
  /** @export */
  glUniformMatrix4fv: _glUniformMatrix4fv,
  /** @export */
  glUniformMatrix4x2fv: _glUniformMatrix4x2fv,
  /** @export */
  glUniformMatrix4x3fv: _glUniformMatrix4x3fv,
  /** @export */
  glUnmapBuffer: _glUnmapBuffer,
  /** @export */
  glUseProgram: _glUseProgram,
  /** @export */
  glValidateProgram: _glValidateProgram,
  /** @export */
  glVertexAttrib1f: _glVertexAttrib1f,
  /** @export */
  glVertexAttrib1fv: _glVertexAttrib1fv,
  /** @export */
  glVertexAttrib2f: _glVertexAttrib2f,
  /** @export */
  glVertexAttrib2fv: _glVertexAttrib2fv,
  /** @export */
  glVertexAttrib3f: _glVertexAttrib3f,
  /** @export */
  glVertexAttrib3fv: _glVertexAttrib3fv,
  /** @export */
  glVertexAttrib4f: _glVertexAttrib4f,
  /** @export */
  glVertexAttrib4fv: _glVertexAttrib4fv,
  /** @export */
  glVertexAttribDivisor: _glVertexAttribDivisor,
  /** @export */
  glVertexAttribDivisorANGLE: _glVertexAttribDivisorANGLE,
  /** @export */
  glVertexAttribDivisorARB: _glVertexAttribDivisorARB,
  /** @export */
  glVertexAttribDivisorEXT: _glVertexAttribDivisorEXT,
  /** @export */
  glVertexAttribDivisorNV: _glVertexAttribDivisorNV,
  /** @export */
  glVertexAttribI4i: _glVertexAttribI4i,
  /** @export */
  glVertexAttribI4iv: _glVertexAttribI4iv,
  /** @export */
  glVertexAttribI4ui: _glVertexAttribI4ui,
  /** @export */
  glVertexAttribI4uiv: _glVertexAttribI4uiv,
  /** @export */
  glVertexAttribIPointer: _glVertexAttribIPointer,
  /** @export */
  glVertexAttribPointer: _glVertexAttribPointer,
  /** @export */
  glVertexPointer: _glVertexPointer,
  /** @export */
  glViewport: _glViewport,
  /** @export */
  glWaitSync: _glWaitSync,
  /** @export */
  glewGetErrorString: _glewGetErrorString,
  /** @export */
  glewGetExtension: _glewGetExtension,
  /** @export */
  glewGetString: _glewGetString,
  /** @export */
  glewInit: _glewInit,
  /** @export */
  glewIsSupported: _glewIsSupported,
  /** @export */
  glfwCreateCursor: _glfwCreateCursor,
  /** @export */
  glfwCreateStandardCursor: _glfwCreateStandardCursor,
  /** @export */
  glfwCreateWindow: _glfwCreateWindow,
  /** @export */
  glfwDefaultWindowHints: _glfwDefaultWindowHints,
  /** @export */
  glfwDestroyCursor: _glfwDestroyCursor,
  /** @export */
  glfwDestroyWindow: _glfwDestroyWindow,
  /** @export */
  glfwExtensionSupported: _glfwExtensionSupported,
  /** @export */
  glfwFocusWindow: _glfwFocusWindow,
  /** @export */
  glfwGetClipboardString: _glfwGetClipboardString,
  /** @export */
  glfwGetCurrentContext: _glfwGetCurrentContext,
  /** @export */
  glfwGetCursorPos: _glfwGetCursorPos,
  /** @export */
  glfwGetFramebufferSize: _glfwGetFramebufferSize,
  /** @export */
  glfwGetGammaRamp: _glfwGetGammaRamp,
  /** @export */
  glfwGetInputMode: _glfwGetInputMode,
  /** @export */
  glfwGetJoystickAxes: _glfwGetJoystickAxes,
  /** @export */
  glfwGetJoystickButtons: _glfwGetJoystickButtons,
  /** @export */
  glfwGetJoystickGUID: _glfwGetJoystickGUID,
  /** @export */
  glfwGetJoystickHats: _glfwGetJoystickHats,
  /** @export */
  glfwGetJoystickName: _glfwGetJoystickName,
  /** @export */
  glfwGetJoystickUserPointer: _glfwGetJoystickUserPointer,
  /** @export */
  glfwGetKey: _glfwGetKey,
  /** @export */
  glfwGetKeyName: _glfwGetKeyName,
  /** @export */
  glfwGetKeyScancode: _glfwGetKeyScancode,
  /** @export */
  glfwGetMonitorContentScale: _glfwGetMonitorContentScale,
  /** @export */
  glfwGetMonitorName: _glfwGetMonitorName,
  /** @export */
  glfwGetMonitorPhysicalSize: _glfwGetMonitorPhysicalSize,
  /** @export */
  glfwGetMonitorPos: _glfwGetMonitorPos,
  /** @export */
  glfwGetMonitorWorkarea: _glfwGetMonitorWorkarea,
  /** @export */
  glfwGetMonitors: _glfwGetMonitors,
  /** @export */
  glfwGetMouseButton: _glfwGetMouseButton,
  /** @export */
  glfwGetPrimaryMonitor: _glfwGetPrimaryMonitor,
  /** @export */
  glfwGetRequiredInstanceExtensions: _glfwGetRequiredInstanceExtensions,
  /** @export */
  glfwGetTime: _glfwGetTime,
  /** @export */
  glfwGetTimerFrequency: _glfwGetTimerFrequency,
  /** @export */
  glfwGetTimerValue: _glfwGetTimerValue,
  /** @export */
  glfwGetVersion: _glfwGetVersion,
  /** @export */
  glfwGetVersionString: _glfwGetVersionString,
  /** @export */
  glfwGetVideoMode: _glfwGetVideoMode,
  /** @export */
  glfwGetVideoModes: _glfwGetVideoModes,
  /** @export */
  glfwGetWindowAttrib: _glfwGetWindowAttrib,
  /** @export */
  glfwGetWindowContentScale: _glfwGetWindowContentScale,
  /** @export */
  glfwGetWindowFrameSize: _glfwGetWindowFrameSize,
  /** @export */
  glfwGetWindowMonitor: _glfwGetWindowMonitor,
  /** @export */
  glfwGetWindowOpacity: _glfwGetWindowOpacity,
  /** @export */
  glfwGetWindowPos: _glfwGetWindowPos,
  /** @export */
  glfwGetWindowSize: _glfwGetWindowSize,
  /** @export */
  glfwGetWindowUserPointer: _glfwGetWindowUserPointer,
  /** @export */
  glfwHideWindow: _glfwHideWindow,
  /** @export */
  glfwIconifyWindow: _glfwIconifyWindow,
  /** @export */
  glfwInit: _glfwInit,
  /** @export */
  glfwJoystickIsGamepad: _glfwJoystickIsGamepad,
  /** @export */
  glfwJoystickPresent: _glfwJoystickPresent,
  /** @export */
  glfwMakeContextCurrent: _glfwMakeContextCurrent,
  /** @export */
  glfwMaximizeWindow: _glfwMaximizeWindow,
  /** @export */
  glfwPollEvents: _glfwPollEvents,
  /** @export */
  glfwPostEmptyEvent: _glfwPostEmptyEvent,
  /** @export */
  glfwRawMouseMotionSupported: _glfwRawMouseMotionSupported,
  /** @export */
  glfwRequestWindowAttention: _glfwRequestWindowAttention,
  /** @export */
  glfwRestoreWindow: _glfwRestoreWindow,
  /** @export */
  glfwSetCharCallback: _glfwSetCharCallback,
  /** @export */
  glfwSetCharModsCallback: _glfwSetCharModsCallback,
  /** @export */
  glfwSetClipboardString: _glfwSetClipboardString,
  /** @export */
  glfwSetCursor: _glfwSetCursor,
  /** @export */
  glfwSetCursorEnterCallback: _glfwSetCursorEnterCallback,
  /** @export */
  glfwSetCursorPos: _glfwSetCursorPos,
  /** @export */
  glfwSetCursorPosCallback: _glfwSetCursorPosCallback,
  /** @export */
  glfwSetDropCallback: _glfwSetDropCallback,
  /** @export */
  glfwSetErrorCallback: _glfwSetErrorCallback,
  /** @export */
  glfwSetFramebufferSizeCallback: _glfwSetFramebufferSizeCallback,
  /** @export */
  glfwSetGamma: _glfwSetGamma,
  /** @export */
  glfwSetGammaRamp: _glfwSetGammaRamp,
  /** @export */
  glfwSetInputMode: _glfwSetInputMode,
  /** @export */
  glfwSetJoystickCallback: _glfwSetJoystickCallback,
  /** @export */
  glfwSetJoystickUserPointer: _glfwSetJoystickUserPointer,
  /** @export */
  glfwSetKeyCallback: _glfwSetKeyCallback,
  /** @export */
  glfwSetMonitorCallback: _glfwSetMonitorCallback,
  /** @export */
  glfwSetMouseButtonCallback: _glfwSetMouseButtonCallback,
  /** @export */
  glfwSetScrollCallback: _glfwSetScrollCallback,
  /** @export */
  glfwSetTime: _glfwSetTime,
  /** @export */
  glfwSetWindowAspectRatio: _glfwSetWindowAspectRatio,
  /** @export */
  glfwSetWindowAttrib: _glfwSetWindowAttrib,
  /** @export */
  glfwSetWindowCloseCallback: _glfwSetWindowCloseCallback,
  /** @export */
  glfwSetWindowContentScaleCallback: _glfwSetWindowContentScaleCallback,
  /** @export */
  glfwSetWindowFocusCallback: _glfwSetWindowFocusCallback,
  /** @export */
  glfwSetWindowIcon: _glfwSetWindowIcon,
  /** @export */
  glfwSetWindowIconifyCallback: _glfwSetWindowIconifyCallback,
  /** @export */
  glfwSetWindowMaximizeCallback: _glfwSetWindowMaximizeCallback,
  /** @export */
  glfwSetWindowMonitor: _glfwSetWindowMonitor,
  /** @export */
  glfwSetWindowOpacity: _glfwSetWindowOpacity,
  /** @export */
  glfwSetWindowPos: _glfwSetWindowPos,
  /** @export */
  glfwSetWindowPosCallback: _glfwSetWindowPosCallback,
  /** @export */
  glfwSetWindowRefreshCallback: _glfwSetWindowRefreshCallback,
  /** @export */
  glfwSetWindowShouldClose: _glfwSetWindowShouldClose,
  /** @export */
  glfwSetWindowSize: _glfwSetWindowSize,
  /** @export */
  glfwSetWindowSizeCallback: _glfwSetWindowSizeCallback,
  /** @export */
  glfwSetWindowSizeLimits: _glfwSetWindowSizeLimits,
  /** @export */
  glfwSetWindowTitle: _glfwSetWindowTitle,
  /** @export */
  glfwSetWindowUserPointer: _glfwSetWindowUserPointer,
  /** @export */
  glfwShowWindow: _glfwShowWindow,
  /** @export */
  glfwSwapBuffers: _glfwSwapBuffers,
  /** @export */
  glfwSwapInterval: _glfwSwapInterval,
  /** @export */
  glfwTerminate: _glfwTerminate,
  /** @export */
  glfwVulkanSupported: _glfwVulkanSupported,
  /** @export */
  glfwWaitEvents: _glfwWaitEvents,
  /** @export */
  glfwWaitEventsTimeout: _glfwWaitEventsTimeout,
  /** @export */
  glfwWindowHint: _glfwWindowHint,
  /** @export */
  glfwWindowHintString: _glfwWindowHintString,
  /** @export */
  glfwWindowShouldClose: _glfwWindowShouldClose,
  /** @export */
  glutCreateWindow: _glutCreateWindow,
  /** @export */
  glutDestroyWindow: _glutDestroyWindow,
  /** @export */
  glutDisplayFunc: _glutDisplayFunc,
  /** @export */
  glutFullScreen: _glutFullScreen,
  /** @export */
  glutGet: _glutGet,
  /** @export */
  glutGetModifiers: _glutGetModifiers,
  /** @export */
  glutIdleFunc: _glutIdleFunc,
  /** @export */
  glutInit: _glutInit,
  /** @export */
  glutInitDisplayMode: _glutInitDisplayMode,
  /** @export */
  glutInitWindowPosition: _glutInitWindowPosition,
  /** @export */
  glutInitWindowSize: _glutInitWindowSize,
  /** @export */
  glutKeyboardFunc: _glutKeyboardFunc,
  /** @export */
  glutKeyboardUpFunc: _glutKeyboardUpFunc,
  /** @export */
  glutMainLoop: _glutMainLoop,
  /** @export */
  glutMotionFunc: _glutMotionFunc,
  /** @export */
  glutMouseFunc: _glutMouseFunc,
  /** @export */
  glutPassiveMotionFunc: _glutPassiveMotionFunc,
  /** @export */
  glutPositionWindow: _glutPositionWindow,
  /** @export */
  glutPostRedisplay: _glutPostRedisplay,
  /** @export */
  glutReshapeFunc: _glutReshapeFunc,
  /** @export */
  glutReshapeWindow: _glutReshapeWindow,
  /** @export */
  glutSetCursor: _glutSetCursor,
  /** @export */
  glutSpecialFunc: _glutSpecialFunc,
  /** @export */
  glutSpecialUpFunc: _glutSpecialUpFunc,
  /** @export */
  glutSwapBuffers: _glutSwapBuffers,
  /** @export */
  glutTimerFunc: _glutTimerFunc,
  /** @export */
  lineColor: _lineColor,
  /** @export */
  lineRGBA: _lineRGBA,
  /** @export */
  llvm_eh_typeid_for: _llvm_eh_typeid_for,
  /** @export */
  memory: wasmMemory,
  /** @export */
  pixelRGBA: _pixelRGBA,
  /** @export */
  proc_exit: _proc_exit,
  /** @export */
  random_get: _random_get,
  /** @export */
  rectangleColor: _rectangleColor,
  /** @export */
  rectangleRGBA: _rectangleRGBA,
  /** @export */
  rotozoomSurface: _rotozoomSurface,
  /** @export */
  setNetworkCallback: _setNetworkCallback,
  /** @export */
  setprotoent: _setprotoent,
  /** @export */
  stackAlloc: _stackAlloc,
  /** @export */
  stackRestore: _stackRestore,
  /** @export */
  stackSave: _stackSave,
  /** @export */
  strptime: _strptime,
  /** @export */
  strptime_l: _strptime_l,
  /** @export */
  uuid_clear: _uuid_clear,
  /** @export */
  uuid_compare: _uuid_compare,
  /** @export */
  uuid_copy: _uuid_copy,
  /** @export */
  uuid_generate: _uuid_generate,
  /** @export */
  uuid_is_null: _uuid_is_null,
  /** @export */
  uuid_parse: _uuid_parse,
  /** @export */
  uuid_type: _uuid_type,
  /** @export */
  uuid_unparse: _uuid_unparse,
  /** @export */
  uuid_unparse_lower: _uuid_unparse_lower,
  /** @export */
  uuid_unparse_upper: _uuid_unparse_upper,
  /** @export */
  uuid_variant: _uuid_variant,
  /** @export */
  zoomSurface: _zoomSurface
};
var wasmExports;
createWasm();
var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports['__wasm_call_ctors'])();
var __wget_callback = Module['__wget_callback'] = (a0, a1, a2) => (__wget_callback = Module['__wget_callback'] = wasmExports['_wget_callback'])(a0, a1, a2);
var __py_notify_done = Module['__py_notify_done'] = (a0, a1) => (__py_notify_done = Module['__py_notify_done'] = wasmExports['_py_notify_done'])(a0, a1);
var __py_call = Module['__py_call'] = (a0, a1, a2, a3, a4) => (__py_call = Module['__py_call'] = wasmExports['_py_call'])(a0, a1, a2, a3, a4);
var _free = (a0) => (_free = wasmExports['free'])(a0);
var __Py_DecRefShared = Module['__Py_DecRefShared'] = (a0) => (__Py_DecRefShared = Module['__Py_DecRefShared'] = wasmExports['_Py_DecRefShared'])(a0);
var __Py_GetThreadLocal_Addr = Module['__Py_GetThreadLocal_Addr'] = () => (__Py_GetThreadLocal_Addr = Module['__Py_GetThreadLocal_Addr'] = wasmExports['_Py_GetThreadLocal_Addr'])();
var __Py_MergeZeroLocalRefcount = Module['__Py_MergeZeroLocalRefcount'] = (a0) => (__Py_MergeZeroLocalRefcount = Module['__Py_MergeZeroLocalRefcount'] = wasmExports['_Py_MergeZeroLocalRefcount'])(a0);
var _fileno = (a0) => (_fileno = wasmExports['fileno'])(a0);
var _egl_ChooseConfig = Module['_egl_ChooseConfig'] = (a0, a1, a2, a3, a4) => (_egl_ChooseConfig = Module['_egl_ChooseConfig'] = wasmExports['egl_ChooseConfig'])(a0, a1, a2, a3, a4);
var _egl_GetCurrentDisplay = Module['_egl_GetCurrentDisplay'] = () => (_egl_GetCurrentDisplay = Module['_egl_GetCurrentDisplay'] = wasmExports['egl_GetCurrentDisplay'])();
var _egl_test = Module['_egl_test'] = () => (_egl_test = Module['_egl_test'] = wasmExports['egl_test'])();
var _main = Module['_main'] = (a0, a1) => (_main = Module['_main'] = wasmExports['__main_argc_argv'])(a0, a1);
var _calloc = (a0, a1) => (_calloc = wasmExports['calloc'])(a0, a1);
var _memcpy = (a0, a1, a2) => (_memcpy = wasmExports['memcpy'])(a0, a1, a2);
var _memcmp = (a0, a1, a2) => (_memcmp = wasmExports['memcmp'])(a0, a1, a2);
var ___errno_location = () => (___errno_location = wasmExports['__errno_location'])();
var _malloc = (a0) => (_malloc = wasmExports['malloc'])(a0);
var _realloc = (a0, a1) => (_realloc = wasmExports['realloc'])(a0, a1);
var _strerror = (a0) => (_strerror = wasmExports['strerror'])(a0);
var _ntohs = (a0) => (_ntohs = wasmExports['ntohs'])(a0);
var _htons = (a0) => (_htons = wasmExports['htons'])(a0);
var _htonl = (a0) => (_htonl = wasmExports['htonl'])(a0);
var ___getTypeName = (a0) => (___getTypeName = wasmExports['__getTypeName'])(a0);
var __emval_coro_resume = (a0, a1) => (__emval_coro_resume = wasmExports['_emval_coro_resume'])(a0, a1);
var ___dl_seterr = (a0, a1) => (___dl_seterr = wasmExports['__dl_seterr'])(a0, a1);
var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports['emscripten_builtin_memalign'])(a0, a1);
var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports['_emscripten_timeout'])(a0, a1);
var _setThrew = (a0, a1) => (_setThrew = wasmExports['setThrew'])(a0, a1);
var __emscripten_tempret_set = (a0) => (__emscripten_tempret_set = wasmExports['_emscripten_tempret_set'])(a0);
var __emscripten_tempret_get = () => (__emscripten_tempret_get = wasmExports['_emscripten_tempret_get'])();
var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports['_emscripten_stack_restore'])(a0);
var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports['_emscripten_stack_alloc'])(a0);
var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports['emscripten_stack_get_current'])();
var ___cxa_demangle = (a0, a1, a2, a3) => (___cxa_demangle = wasmExports['__cxa_demangle'])(a0, a1, a2, a3);
var ___cxa_increment_exception_refcount = (a0) => (___cxa_increment_exception_refcount = wasmExports['__cxa_increment_exception_refcount'])(a0);
var ___cxa_decrement_exception_refcount = (a0) => (___cxa_decrement_exception_refcount = wasmExports['__cxa_decrement_exception_refcount'])(a0);
var ___cxa_can_catch = (a0, a1, a2) => (___cxa_can_catch = wasmExports['__cxa_can_catch'])(a0, a1, a2);
var ___cxa_get_exception_ptr = (a0) => (___cxa_get_exception_ptr = wasmExports['__cxa_get_exception_ptr'])(a0);
var ___wasm_apply_data_relocs = () => (___wasm_apply_data_relocs = wasmExports['__wasm_apply_data_relocs'])();
var _Py_EMSCRIPTEN_SIGNAL_HANDLING = Module['_Py_EMSCRIPTEN_SIGNAL_HANDLING'] = 4227280;

// include: postamble.js
// === Auto-generated postamble setup entry stuff ===

Module['addRunDependency'] = addRunDependency;
Module['removeRunDependency'] = removeRunDependency;
Module['FS_createPreloadedFile'] = FS_createPreloadedFile;
Module['FS_unlink'] = FS_unlink;
Module['FS_createPath'] = FS_createPath;
Module['FS_createDevice'] = FS_createDevice;
Module['FS'] = FS;
Module['FS_createDataFile'] = FS_createDataFile;
Module['FS_createLazyFile'] = FS_createLazyFile;
Module['LZ4'] = LZ4;
Module['print'] = print;


var calledRun;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};

function callMain(args = []) {

  var entryFunction = resolveGlobalSymbol('main').sym;;

  // Main modules can't tell if they have main() at compile time, since it may
  // arrive from a dynamic library.
  if (!entryFunction) return;

  args.unshift(thisProgram);

  var argc = args.length;
  var argv = stackAlloc((argc + 1) * 4);
  var argv_ptr = argv;
  args.forEach((arg) => {
    HEAPU32[((argv_ptr)>>2)] = stringToUTF8OnStack(arg);
    argv_ptr += 4;
  });
  HEAPU32[((argv_ptr)>>2)] = 0;

  try {

    var ret = entryFunction(argc, argv);

    // if we're not running an evented main loop, it's time to exit
    exitJS(ret, /* implicit = */ true);
    return ret;
  }
  catch (e) {
    return handleException(e);
  }
}

function run(args = arguments_) {

  if (runDependencies > 0) {
    return;
  }

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    preMain();

    Module['onRuntimeInitialized']?.();

    if (shouldRunNow) callMain(args);

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(() => {
      setTimeout(() => Module['setStatus'](''), 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;

if (Module['noInitialRun']) shouldRunNow = false;

run();

// end include: postamble.js

